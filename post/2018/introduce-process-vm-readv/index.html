<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.42.1" />

  <title>process_vm_readv: 一种新的IPC解决方案 &middot; 乐Coding</title>


  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.2/css/all.css" integrity="sha384-/rXc/GQVaYpyDdyxK+ecHPVYJSN9bmVFBvjA/9eOB+pb3F2w2N6fc5qB9Ew5yIns" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/lecoding.css">
  
  


  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.4.0/styles/atelier-forest-light.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.4.0/highlight.min.js"></script>
  <script>
  
  hljs.initHighlightingOnLoad();

  </script>
  
  
  <script src="/js/main.js"></script>

  <link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon" />

</head>


<body data-url="">
<div id="layout">
  <div id="main">
  
<div class="nav">

  <div class="side-menu">
      
        <a class="side-menu-link" href="/">Home</a>
      
        <a class="side-menu-link" href="/archives/">Archives</a>
      
        <a class="side-menu-link" href="/tags/">Tags</a>
      
        <a class="side-menu-link" href="/about/">About</a>
      
  </div>

</div>



<div class="content">
<div class="header">
  <h1>process_vm_readv: 一种新的IPC解决方案</h1>
</div>


<div class="single-content">
  

<p>Linux 3.2 引入了两个新的接口 <a href="http://man7.org/linux/man-pages/man2/process_vm_readv.2.html">process_vm_ready</a> 和 <a href="https://linux.die.net/man/2/process_vm_writev">process_vm_writev</a>。这两个函数的功能非常直观。</p>

<h2 id="接口介绍">接口介绍</h2>

<p>下面是这两个接口的原型定义，其并不是 POSIX 标准，因此只能在 Linux 下使用。</p>

<pre><code>#include &lt;sys/uio.h&gt;

ssize_t process_vm_readv(pid_t pid,
                         const struct iovec *local_iov,
                         unsigned long liovcnt,
                         const struct iovec *remote_iov,
                         unsigned long riovcnt,
                         unsigned long flags);

ssize_t process_vm_writev(pid_t pid,
                          const struct iovec *local_iov,
                          unsigned long liovcnt,
                          const struct iovec *remote_iov,
                          unsigned long riovcnt,
                          unsigned long flags);
</code></pre>

<p><code>process_vm_readv</code>的作用，是将某个目标进程的一块内存区域读取到当前的进程，类似于生产一个 <code>core</code>，但是其控制粒度要更加精确，并且可以以编程的方式分析读取出来的内存。同样，<code>process_vm_writev</code> 的作用是反过来的，就是将当前进程
的一块内存写入到目标进程。 这两个接口是系统调用，直接在用户地址空间进行的拷贝，无需通过内核空间中转，因此效率非常之高。我能想到的有以下几个应用场景：</p>

<h3 id="应用场景">应用场景</h3>

<ol>
<li>提供进程的查探接口
之前我们要查看线上的进程运行状况，会有几种解决方案。一是编写接口，如telnet、http之类；这些接口的编写往往有一定的工作量并且在程序无响应时没法使用，一般作为高层逻辑的查看接口；比如说看游戏占用内存啊、服务器人数之类。另一个是通过
<code>gcore</code> 或 <code>gdb</code> 来查看，这一般用来做很底层的逻辑分析，分析<code>core</code>文件需要一定的基础，并且无法常态化运行，你总不能程序每隔30s生产一份 <code>core</code> 文件然后分析这个文件从而生成统计数据吧，既不优雅又对磁盘又较大的开销。</li>
</ol>

<p>这个时候, <code>process_vm_readv</code> 的作用就显现了，只需要程序在运行时将某些关键数据结构的地址写入到文件，便可以编写一个探针程序来读取这个地址内容，然后分析输出从而可以实现实时的统计结果。由于进程间是隔离的，对主程序没有任何的影响，一旦
探针程序崩溃只需重启即可。甚至可以在部署的时候，一台机器一个探针程序，监控所有的游戏进程并定期汇报。游戏进程无需做任何与外界交流的事情，无需写文件（文件还可能会满）、写网络、写消息队列就可以将状态暴露出来，并且是0开销。</p>

<ol>
<li><p>提供进程的修改接口
通过<code>process_vm_writev</code>我们可以直接修改目标进程的内容了，并且目标程序无需编写相关的代码。这里的典型场景是配置文件的 reload。目前常用的方式是先修改文件然后通知目标重新读取文件，通过新的接口可以直接修改目标进程的内存配置，更加地直观。
同时，由于内存拷贝的原因，当我们需要大量传输数据的时候也能减少系统的响应时间。</p></li>

<li><p>作为一种 IPC 方式
现在常用的进程间通信主要就是 unix socket ，其效率相对共享内存来说是比较低的。但是共享内存的配置是相当负责并且容易出错的。而使用新的接口后，实现起来会比较简单。</p></li>
</ol>

<p>基本的流程是通过 <code>sendmsg</code> 发送 <code>eventfd</code> 或 <code>pipe</code> 之类的接口将要传输的内容地址等信息发送给目标进程，然后由目标进程来主动读取，读取完了在通知这边准备下一份数据，如此往复。由于没有数据共享，因此也不存在竞争等问题，一对多的情况下
也无需加锁，程序的复杂度比较低。</p>

<h3 id="参数介绍">参数介绍</h3>

<p>这两个接口有一个很重要的参数类型是 <code>iovec</code>，这个我们在<code>writev</code>等接口中有接触过，其表示的是多块内存。比如说当网络发包的时候，用户程序可能是一个一个包过来，表示就是链表。如果使用<code>write</code>调用则每个节点都需要调用一次，如果使用<code>writev</code>
的话只需要一次系统调用就可以完成，提升了效率。</p>

<h3 id="代码示例">代码示例</h3>

<p>这里是一个可以运行的<code>process_vm_readv</code>的代码示例 <a href="https://gist.github.com/usbuild/5af20dcd9bb954b7deda987ed79eda4a">https://gist.github.com/usbuild/5af20dcd9bb954b7deda987ed79eda4a</a>。其通过 <code>socket</code> 来传输事件，通过
内存来分享数据。</p>

</div>

  <div class="eof">--EOF--</div>

  <div class="post-meta">
    发表于 <time>03 Nov 2018, 17:17</time>
  
  
  
  
  , 标签: 「
    
      <a class="post-taxonomy-tag" href="tags/linux">linux</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="tags/ipc">IPC</a>
    
」
  
  

</div>


  
<div class="prev-next-post">
  <div class="prev-link" style="text-align: left;">
    
    <nav class="prev">
      <a href="/post/2018/implement-naive-jit-calc/">« 实现一个带 JIT 的计算器</a>
    </nav>
    
  </div>
  <div class="next-link">
    
    <nav class="next">
      <a href="/post/2018/weird-function-strfry-memfrob/">glibc中两个另类的函数 »</a>
    </nav>
    
  </div>
</div>



  


  
</div>

</div>
</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-19710645-12', 'auto');
  ga('send', 'pageview');

</script>


</script>
</body>
</html>

