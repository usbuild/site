<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.42.1" />

  <title>glibc 中两个另类的函数 &middot; 乐Coding</title>


  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.2/css/all.css" integrity="sha384-/rXc/GQVaYpyDdyxK+ecHPVYJSN9bmVFBvjA/9eOB+pb3F2w2N6fc5qB9Ew5yIns" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/lecoding.css">
  
  


  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.4.0/styles/atelier-forest-light.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.4.0/highlight.min.js"></script>
  <script>
  hljs.initHighlightingOnLoad();
  </script>
  
  
  
 
 <script>
   (function(u, c) {
     var d = document, t = 'script', o = d.createElement(t),
         s = d.getElementsByTagName(t)[0];
     o.src = u;
     if (c) { o.addEventListener('load', function(e) { c(e); }); }
     s.parentNode.insertBefore(o, s);
   })('//cdn.bootcss.com/pangu/3.3.0/pangu.min.js', function() {
     pangu.spacingPage();
   });
 </script>


  <script src="/js/main.js"></script>

  <link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon" />

</head>


<body data-url="">
<div id="layout">
  <div id="main">
  
<div class="nav">

  <div class="side-menu">
      
        <a class="side-menu-link" href="/">Home</a>
      
        <a class="side-menu-link" href="/archives/">Archives</a>
      
        <a class="side-menu-link" href="/tags/">Tags</a>
      
        <a class="side-menu-link" href="/about/">About</a>
      
  </div>

</div>



<div class="content">
<div class="header">
  <h1>glibc 中两个另类的函数</h1>
</div>


<div class="single-content">
  <p>glibc 作为使用最广泛的 libc 库，其接口设计必然也是十分精良的。出去 ANSI C 所规定的必须要拥有的接口外， glibc 也有大量自己的私有函数。
比如各种平台私有函数等。在这些私有函数中，有两个方法显得很容易被忽略，那就是 <code>strfry</code> 和 <code>memfrob</code>。你可能根本不知道有这两个函数，也
压根不会在代码中使用这两个函数。我敢说，如果 glibc 完全重新设计的话，这两个函数一定会被拿掉。这是为什么？</p>

<p>首先看看这两个函数的定义：</p>

<pre><code>#define _GNU_SOURCE        
#include &lt;string.h&gt;

char *strfry(char *string);
void *memfrob(void *s, size_t n);
</code></pre>

<p>从函数形参上看，并没有什么特别的。这两个函数都是 <code>string.h</code> 中的，因此符合一贯的命名和参数方式。<code>strfry</code> 和 <code>strchr</code>、<code>strdup</code>之类的函数命名是统一的，唯一注意的是
其参数是<code>char *</code>类型，和大部分<code>strxxx</code>函数以<code>const char*</code>作为参数的做法是不一致的。这说明<code>strfry</code>会修改参数内容，这就极大限制了其适用范围。然后是<code>memfrob</code>函数，
他也和<code>memcpy</code>、<code>memmove</code>之类的类似，由于这些函数的形参类型都是<code>void *</code>，因此放在<code>string.h</code>中也不会显得违和。既然<code>strfry</code>会修改<code>string</code>内容，为什么不改成<code>memfry</code>?
难道其职能作用在字符串上么？</p>

<p>然而不是。下面来看看这两个函数的功能</p>

<blockquote>
<p>strfry:  The strfry() function randomizes the contents of string by using rand(3) to randomly swap characters in the string.  The result is an anagram of string.</p>
</blockquote>

<p>功能和和shuffle类似，并且使用了 <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates algorithm</a> , 但是当你使用的时候，就会发现虽然生成的内容是随机的，但是
并不是公平的。当我们使用<code>abc</code>这三个字母进行 <code>strfry</code> 时，输出的结果是</p>

<pre><code>abc: 165547
acb: 167887
bac: 164850
bca: 168791
cab: 167259
cba: 165666
</code></pre>

<p>其中出现最多的<code>bca</code>和<code>bac</code>之间相差了<code>2%</code>。这个其实已经不能算是特别公平的<code>shuffle</code>了。其原因是为什么？下面是<code>strfry</code>的代码</p>

<pre><code>char * strfry (char *string)
{
  static int init;
  static struct random_data rdata;

  if (!init)
    {
      static char state[32];
      rdata.state = NULL;
      __initstate_r (time ((time_t *) NULL) ^ getpid (),
		     state, sizeof (state), &amp;rdata);
      init = 1;
    }

  size_t len = strlen (string);
  if (len &gt; 0)
    for (size_t i = 0; i &lt; len - 1; ++i)
      {
	int32_t j;
	__random_r (&amp;rdata, &amp;j);
	j = j % (len - i) + i;

	char c = string[i];
	string[i] = string[j];
	string[j] = c;
      }

  return string;
}
</code></pre>

<p><code>strfry</code> 使用了自有的<code>random</code>函数，因此不会污染全局的<code>random</code>序列。下面那就是 <code>Fisher-Yates</code> 算法了。那为什么会出现不平均的分布？其实原因很简单。</p>

<p>首先， <code>j</code> 是一个 <code>int32_t</code> 类型，其最大最大也就是 <code>2^32 - 1</code>(这里由于后面取余，因此<code>int32_t</code>和<code>uint32_t</code>没什么区别)。假设 <code>j</code> 在 <code>0 ~ 2^32 - 1</code>
之间是均匀分布的。另外又假设输入的字符串是一个很大的数据，比如说<code>10000</code>，由于<code>2^32 - 1</code>不能被<code>10000</code> 整除，余数是<code>7295</code>。也就是说，当<code>10000</code>后面
的<code>10000- 7295</code> 被随机到的次数比前<code>7295</code>少了一次，这就造成了数据的偏差。因此一种解决方案是，当随机到后面的<code>10000</code>时重新<code>random</code>。</p>

<p>也就是说，<code>strpry</code> 作为 shuffle 的替代者，可能是不够合格的。</p>

<p>那么，<code>strpry</code>的应用场景是啥呢？另一个场景可能就是把原本有序的数据变成垃圾了，向咱们扔垃圾一样，先划掉字迹，然后揉成一团或塞进碎纸机。因此可以用作销毁数据，
但是既然有了<code>memset</code>，为什么需要<code>strpry</code>函数呢？效率还更高。这一应用场景也就没啥必要了。 所以，<code>strpry</code>被人忽略也就不奇怪了。</p>

<p>下面来谈谈<code>memfrob</code>。</p>

<p>这个函数更加奇葩，根据描述</p>

<blockquote>
<p>The memfrob() function encrypts the first n bytes of the memory area s by exclusive-ORing each character with the number 42.  The effect can be reversed by using memfrob() on the encrypted memory area.</p>

<p>Note that this function is not a proper encryption routine as the XOR constant is fixed, and is suitable only for hiding strings.</p>
</blockquote>

<p>这玩意儿就是对一块内存中的每个字节取一个对<code>42</code>的<code>XOR</code>操作。异或操作常用于加密领域，因为其是可以恢复的，一个数两次异或之后还是自身。那么问题来了，<code>memfrob</code>为什么要
异或<code>42</code> ？ 显然这个<code>42</code>就是拍脑袋想出来的，因为它是<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E5%91%BD%E3%80%81%E5%AE%87%E5%AE%99%E4%BB%A5%E5%8F%8A%E4%BB%BB%E4%BD%95%E4%BA%8B%E6%83%85%E7%9A%84%E7%B5%82%E6%A5%B5%E7%AD%94%E6%A1%88">生命、宇宙以及一切的终极答案</a>，
来自 银河系漫游指南 。但是这里对于这里的程序是没有什么作用的，而且你也没办法修改它，它就这样写死在代码里面。</p>

<p>或许有人认为，<code>memfrob</code>可以用来加密，但是文档上明确说它并不能用于加密，因为太容易被破解了，如果需要加密应该使用更成熟的一些解决方案，如<code>des</code>、<code>aes</code>之类。
另外还有一个作用，是防止被人用<code>strings</code>这样的程序窥探可执行文件中的内容，这确实可以蒙过一些初级玩家，但是对于一些稍微掌握点破解的人来说也是徒劳无功的。而且这样也会
代码编码上的不利，因为通过<code>strings</code>查看的字符串很多都不能被修改，因此你在使用的时候还得先拷贝一份再使用。</p>

<p>从上面看来<code>memfrob</code>绝不推荐使用，就算使用异或，那也应该自行实现而不是用这个写死<code>42</code>的版本。</p>

<p>今天我们介绍的这两个函数可以说是非常奇葩了，而且往往还经常在网上被拉出来鞭尸一顿。但是我们能从其中却能学习到一下函数设计的基本坑点，在下次使用某些库的时候也需要更深入思考其局限性和使用场景。</p>

</div>

  <div class="eof">--EOF--</div>
  
<div class="wxqrbox">
    <span class="qrintro">欢迎关注我的微信公众号</span>
    <img class="qrimg" src="https://open.weixin.qq.com/qr/code?username=gh_950f5a94ae02"></img>
</div>


  <div class="post-meta">
    发表于 <time>06 Nov 2018, 09:54</time>
  
  
  
  
  , 标签: 「
    
      <a class="post-taxonomy-tag" href="tags/glibc">glibc</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="tags/design">design</a>
    
」
  
  

</div>


  
<div class="prev-next-post">
  <div class="prev-link" style="text-align: left;">
    
    <nav class="prev">
      <a href="/post/2018/introduce-process-vm-readv/">« process_vm_readv: 一种新的IPC解决方案</a>
    </nav>
    
  </div>
  <div class="next-link">
    
    <nav class="next">
      <a href="/post/2018/yet-another-c-coroutine/">[造轮子] 一个 c&#43;&#43; coroutine 的实现 »</a>
    </nav>
    
  </div>
</div>



  


  

</div>

</div>
</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-19710645-12', 'auto');
  ga('send', 'pageview');

</script>


</script>
</body>
</html>

