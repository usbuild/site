<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on sys🔱fork</title>
    <link>http://sysfork.com/post/</link>
    <description>Recent content in Posts on sys🔱fork</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Tue, 30 May 2017 17:03:21 +0800</lastBuildDate>
    <atom:link href="http://sysfork.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>在 vue 中使用 semantic-ui</title>
      <link>http://sysfork.com/post/2017/use-semantic-ui-with-vue/</link>
      <pubDate>Tue, 30 May 2017 17:03:21 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/use-semantic-ui-with-vue/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://cn.vuejs.org/&#34;&gt;Vue&lt;/a&gt; 是一个很好呀的 MVVM 框架，我最近在一个内部使用的管理后台初次使用。而 &lt;a href=&#34;https://semantic-ui.com/&#34;&gt;semantic-ui&lt;/a&gt; 则是
一个比较美观全面的 css 框架，也是我比较偏好使用的。所以，在这次重构管理后台时，这两者就被我选择使用。PS： 服务器端用的是 &lt;a href=&#34;https://www.djangoproject.com/&#34;&gt;Django&lt;/a&gt;，
也是第一次使用。&lt;/p&gt;

&lt;p&gt;semantic-ui 大部分情况下使用其 css 部分是没问题的，如 &lt;a href=&#34;https://semantic-ui.com/elements/button.html&#34;&gt;button&lt;/a&gt;, &lt;a href=&#34;https://semantic-ui.com/collections/table.html&#34;&gt;table&lt;/a&gt;
等，直接套用对应的 css 样式即可。但是对于某些需要 js 初始化的控件，如 &lt;a href=&#34;https://semantic-ui.com/modules/dropdown.html&#34;&gt;dropdown&lt;/a&gt;, &lt;a href=&#34;https://semantic-ui.com/modules/popup.html&#34;&gt;popup&lt;/a&gt;
等，都需要调用对应的函数，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;.ui.dropdown&#39;)
  .dropdown()
;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么对于 Vue 中动态生成的控件要怎么处理呢？ 我们希望在控件加入到 dom 后能够调用对应的 semnatic-ui 初始化函数，但是由于 Vue 的插入是自动完成的，我们不好判断时机，好在 Vue 提供了
&lt;a href=&#34;https://cn.vuejs.org/v2/guide/custom-directive.html&#34;&gt;自定义指令&lt;/a&gt;，我们可以按照下面的方法来做：&lt;/p&gt;

&lt;p&gt;首先假设我们的 html 是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;main&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后 Vue 实例为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let data = {
    data: [&amp;quot;Male&amp;quot;, &amp;quot;Female&amp;quot;]
}
new Vue({
    el: &amp;quot;#main&amp;quot;,
    data,
    template: `
    &amp;lt;select class=&amp;quot;ui dropdown&amp;quot;&amp;gt;
        &amp;lt;option value=&amp;quot;&amp;quot;&amp;gt;Gender&amp;lt;/option&amp;gt;
        &amp;lt;option v-for=&amp;quot;(v, k) in data&amp;quot; :value=&amp;quot;k&amp;quot;&amp;gt;{{ v }}&amp;lt;/option&amp;gt;
    &amp;lt;/select&amp;gt;
    `
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们以 dropdown 控件为例，按照以往的做法，我们此时可以调用&lt;code&gt;$(&amp;quot;.ui.dropdown&amp;quot;).dropdown()&lt;/code&gt;来处理，但是对于 Vue 则可以使用自定义指令。假设我们定义一个指令名为&lt;code&gt;v-sudropdown&lt;/code&gt;，
然后将其加到 &lt;code&gt;select&lt;/code&gt; 中，于是变为&lt;code&gt;&amp;lt;select class=&amp;quot;ui dropdown&amp;quot; v-sudropdown&amp;gt;&lt;/code&gt;，那这个 directive 该怎么写呢：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Vue.directive (&amp;quot;sudropdown&amp;quot;, {
        inserted: el =&amp;gt; $(el).dropdown({})
    })

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;inserted&lt;/code&gt; 是一个钩子函数，一旦带有这个 &lt;code&gt;directive&lt;/code&gt; 的元素被插入到 dom 时，这个钩子函数会被调用，从而完成我们的初始化操作。这样 vue 和 semantic-ui 就能完美共存了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lua 5.1 分支语句 bytecode 的生成（二）</title>
      <link>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-2/</link>
      <pubDate>Thu, 25 May 2017 14:26:47 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-2/</guid>
      <description>&lt;p&gt;上篇我们谈到了 IF 语句的 bytecode 生成，今天来谈谈布尔表达式与短路求值。&lt;/p&gt;

&lt;p&gt;考虑到下面的表达式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;a = a or 1024
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其生成的字节码为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1       [1]     GETGLOBAL       0 -1    ; a
2       [1]     TEST            0 0 1
3       [1]     JMP             1       ; to 5
4       [1]     LOADK           0 -2    ; 1024
5       [1]     SETGLOBAL       0 -1    ; a
6       [1]     RETURN          0 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实与&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;if not a then
    a = 1024
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成的代码几乎一致，只是少了像自己赋值的那部分。现在我们看看这条短路求值语句的字节码是怎么生成的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a = a or 1024&lt;/code&gt; 这是一个赋值语句，所以调用使用的是&lt;code&gt;assignment&lt;/code&gt;函数，其中我们关注的调用链是
&lt;code&gt;assignment -&amp;gt; luaK_storeevar -&amp;gt; luaK_exp2anyreg -&amp;gt; luaK_exp2nextreg -&amp;gt; exp2reg&lt;/code&gt; 由于 &lt;code&gt;a or 1024&lt;/code&gt;是个二元运算符，
在代码中可以看到，在读到&lt;code&gt;or&lt;/code&gt;之前是&lt;code&gt;luaK_infix&lt;/code&gt;，读到&lt;code&gt;or&lt;/code&gt;之后是&lt;code&gt;luaK_postfix&lt;/code&gt;，我们看看两者的做法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- luaK_infix
716	    case OPR_OR: {
717	      luaK_goiffalse(fs, v);
718	      break;
719	    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;-- luaK_postfix
746	    case OPR_OR: {
747	      lua_assert(e1-&amp;gt;f == NO_JUMP);  /* list must be closed */
748	      luaK_dischargevars(fs, e2);
749	      luaK_concat(fs, &amp;amp;e2-&amp;gt;t, e1-&amp;gt;t);
750	      *e1 = *e2;
751	      break;
752	    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键还是上文说到的&lt;code&gt;luaK_goiffalse&lt;/code&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;580	  luaK_concat(fs, &amp;amp;e-&amp;gt;t, pc);  /* insert last jump in `t&#39; list */
581	  luaK_patchtohere(fs, e-&amp;gt;f);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果返回 true 的话，那么跳转到某个“未知”的地方，false 的话直接执行下一句。那么这个“未知”的地方是怎么确定的呢？
答案在&lt;code&gt;exp2reg&lt;/code&gt;里面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;394	  if (hasjumps(e)) {
395	    int final;  /* position after whole expression */
396	    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
397	    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
398	    if (need_value(fs, e-&amp;gt;t) || need_value(fs, e-&amp;gt;f)) {
399	      int fj = (e-&amp;gt;k == VJMP) ? NO_JUMP : luaK_jump(fs);
400	      p_f = code_label(fs, reg, 0, 1);
401	      p_t = code_label(fs, reg, 1, 0);
402	      luaK_patchtohere(fs, fj);
403	    }
404	    final = luaK_getlabel(fs);
405	    patchlistaux(fs, e-&amp;gt;f, final, reg, p_f);
406	    patchlistaux(fs, e-&amp;gt;t, final, reg, p_t);
407	  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们设置了&lt;code&gt;e-&amp;gt;t&lt;/code&gt;或&lt;code&gt;e-&amp;gt;f&lt;/code&gt;，所以&lt;code&gt;hasjumps&lt;/code&gt;判断成立。由于&lt;code&gt;TESTSET&lt;/code&gt;已经提供了赋值的寄存器，因此是不需要额外记录判断结果的。而对于其他的入&lt;code&gt;LT&lt;/code&gt;、&lt;code&gt;JMP&lt;/code&gt;等，其本身是不记录任何判断结果的，为了记录只能在 JMP 完成之后，设置到寄存器中，
这也就是此处&lt;code&gt;code_label&lt;/code&gt;存在的原因。接下来是&lt;code&gt;patchlistaux&lt;/code&gt;，其定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;150	static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
151	                          int dtarget) {
152	  while (list != NO_JUMP) {
153	    int next = getjump(fs, list);
154	    if (patchtestreg(fs, list, reg))
155	      fixjump(fs, list, vtarget);
156	    else
157	      fixjump(fs, list, dtarget);  /* jump to default target */
158	    list = next;
159	  }
160	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;patchtestreg&lt;/code&gt;定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;131	static int patchtestreg (FuncState *fs, int node, int reg) {
132	  Instruction *i = getjumpcontrol(fs, node);
133	  if (GET_OPCODE(*i) != OP_TESTSET)
134	    return 0;  /* cannot patch other instructions */
135	  if (reg != NO_REG &amp;amp;&amp;amp; reg != GETARG_B(*i))
136	    SETARG_A(*i, reg);
137	  else  /* no register to put value or register already has the value */
138	    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));
139	
140	  return 1;
141	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;vtarget&lt;/code&gt;是我们当前的位置&lt;code&gt;final&lt;/code&gt;，而&lt;code&gt;dtarget&lt;/code&gt;是&lt;code&gt;p_f&lt;/code&gt;或&lt;code&gt;p_t&lt;/code&gt;。这两条语句的作用其实是将最终&lt;code&gt;TESTSET&lt;/code&gt;指令的结果传送到&lt;code&gt;reg&lt;/code&gt;，
如果不是&lt;code&gt;TESTSET&lt;/code&gt;的话那么说明不产生值，那&lt;code&gt;reg&lt;/code&gt;就需要上面的&lt;code&gt;codelabel&lt;/code&gt;来产生了。至此这部分代码分析完成。&lt;/p&gt;

&lt;p&gt;下面是一些函数的简单解释，可以稍微看看：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaK_nil&lt;/code&gt;函数，生成的是&lt;code&gt;LOADNIL&lt;/code&gt;字节码，其作用是将from ~ from + n之间的寄存器设置成nil，这里做了一些优化如：如果合并相邻的&lt;code&gt;LOADNIL&lt;/code&gt;，函数初始化时可以不需要重复初始化等。
注意优化的前提是&lt;code&gt;fs-&amp;gt;pc &amp;gt; fs-&amp;gt;lasttarget&lt;/code&gt;，即这条指令必须可以省略。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaK_jump&lt;/code&gt;函数，其目的是生成一个&lt;code&gt;JMP&lt;/code&gt;指令。这是个无条件跳转指令。那么其目标呢？其实就是 &lt;code&gt;fs-&amp;gt;jps&lt;/code&gt;。注意后面的&lt;code&gt;luaK_contat&lt;/code&gt;，其目的是将l2链接到l1的后面，这是为了连续跳转
考虑的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;condjump&lt;/code&gt; 生成条件跳转语句，lua为了生成字节码的便利性，每个条件调转语句如&lt;code&gt;LT&lt;/code&gt;, &lt;code&gt;TEST&lt;/code&gt;等后面都跟着一个&lt;code&gt;JMP&lt;/code&gt;，当条件不满足时直接指向&lt;code&gt;JMP&lt;/code&gt;语句，否则就跳到&lt;code&gt;JMP&lt;/code&gt;的下一条，
减少了编码的复杂度啊&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fixjump&lt;/code&gt;把&lt;code&gt;PC&lt;/code&gt;处的指令（当然是JMP指令）改成目标为&lt;code&gt;dest&lt;/code&gt;，当然是相对地址了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaK_getlabel&lt;/code&gt;，标记一下，把当前的lasttarget改成pc，这个lasttarget就是和上面的&lt;code&gt;luaK_nil&lt;/code&gt;结合起来的，防止上面的误优化。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getjump&lt;/code&gt;和上面的fixjump相对应，返回PC所在那条指令的跳转目标。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getjumpcontrol&lt;/code&gt; 由于&lt;code&gt;JMP&lt;/code&gt;上一条很多情况下都是跟着条件跳转指令的，那么这条指令就是获取这条条件跳转指令的。如果是那么返回上一条，否则返回当前pc。除了&lt;code&gt;jmp&lt;/code&gt;之外，其他如&lt;code&gt;FORLOOP&lt;/code&gt;, &lt;code&gt;FORPREP&lt;/code&gt;等指令也会产生跳转&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchtestreg&lt;/code&gt; 修改&lt;code&gt;TESTSET&lt;/code&gt;指令，这个指令一般用于短路求值，&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchlistaux&lt;/code&gt; 对于一个jump list，如果是&lt;code&gt;TESTSET&lt;/code&gt;，那么将赋值寄存器修改为reg并将jump目的地修改为vtarget, 否则修改为dtarget。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dischargejpc&lt;/code&gt; 对jpc进行&lt;code&gt;patchlistaux&lt;/code&gt;，其中vtarget和dtarget都是pc&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchlist&lt;/code&gt; 如果target为pc，那么调用patchtohere；否则调用patchlistaux&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchtohere&lt;/code&gt;先getlabel标记一下，然后将当前的list放到jpc后面&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jpc&lt;/code&gt;那些将要跳到当前位置的链表，由于所有code的增加的欧式&lt;code&gt;luaK_code&lt;/code&gt;，所以会在这个函数中调用&lt;code&gt;dischargejpc&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lua 5.1 分支语句 bytecode 的生成（一）</title>
      <link>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-1/</link>
      <pubDate>Sat, 20 May 2017 15:57:13 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-1/</guid>
      <description>

&lt;p&gt;本文只对 &lt;code&gt;IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END&lt;/code&gt; 语法的字节码生成过程进行描述。&lt;/p&gt;

&lt;h2 id=&#34;生成的结果&#34;&gt;生成的结果&lt;/h2&gt;

&lt;p&gt;首先我们看下面的示例，仅为演示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local cond1 = true
local cond2 = true
if cond1 then
    cond1 = false
elseif cond2 then
    cond2 = false
else
    cond1 = false
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;luac -l -l&lt;/code&gt;选项列出来的结果为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main &amp;lt;test.lua:0,0&amp;gt; (12 instructions, 48 bytes at 0x184e530)
0+ params, 2 slots, 0 upvalues, 2 locals, 0 constants, 0 functions
        1       [1]     LOADBOOL        0 1 0
        2       [2]     LOADBOOL        1 1 0
        3       [3]     TEST            0 0 0
        4       [3]     JMP             2       ; to 7
        5       [4]     LOADBOOL        0 0 0
        6       [4]     JMP             5       ; to 12
        7       [5]     TEST            1 0 0
        8       [5]     JMP             2       ; to 11
        9       [6]     LOADBOOL        1 0 0
        10      [6]     JMP             1       ; to 12
        11      [8]     LOADBOOL        0 0 0
        12      [9]     RETURN          0 1
constants (0) for 0x184e530:
locals (2) for 0x184e530:
        0       cond1   2       12
        1       cond2   3       12
upvalues (0) for 0x184e530:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们可以看到最终的生成结果。我们关注的是其中的&lt;code&gt;TEST&lt;/code&gt;和&lt;code&gt;JUMP&lt;/code&gt;。在第3行的&lt;code&gt;TEST&lt;/code&gt;，其意思是如果0号寄存器中的内容(cond1)
为false(0)的话，那么就执行下面的&lt;code&gt;JMP&lt;/code&gt;语句，否则就调过&lt;code&gt;JMP&lt;/code&gt;直接到第5行。&lt;code&gt;LUA&lt;/code&gt;中的分支实现都是使用&lt;code&gt;TEST&lt;/code&gt;等后面紧跟&lt;code&gt;JMP&lt;/code&gt;实现的，
从主 dispatch 代码中可以看到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // ...
      case OP_TEST: {
        if (l_isfalse(ra) != GETARG_C(i))
          dojump(L, pc, GETARG_sBx(*pc));
        pc++;
        continue;
      }
      case OP_TESTSET: {
        TValue *rb = RB(i);
        if (l_isfalse(rb) != GETARG_C(i)) {
          setobjs2s(L, ra, rb);
          dojump(L, pc, GETARG_sBx(*pc));
        }
        pc++;
        continue;
      }
      // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;JMP&lt;/code&gt;跳转，永远都是分支不成立的情况，而&lt;code&gt;TEST&lt;/code&gt;成功后的跳转永远是跳过下一行，失败的话继续执行接下来的JMP。&lt;code&gt;if&lt;/code&gt;语句的字节码解析就到这里，后面的&lt;code&gt;elseif&lt;/code&gt;等都是比较简单的，再了解这个事实之后。
那么这种字节码是怎么生成的呢？下面来分析下。&lt;/p&gt;

&lt;h2 id=&#34;生成的过程&#34;&gt;生成的过程&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt;语句的代码在&lt;code&gt;lparser.c&lt;/code&gt;里面，最上层如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void ifstat (LexState *ls, int line) {
  /* ifstat -&amp;gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
  FuncState *fs = ls-&amp;gt;fs;
  int flist;
  int escapelist = NO_JUMP;
  flist = test_then_block(ls);  /* IF cond THEN block */
  while (ls-&amp;gt;t.token == TK_ELSEIF) {
    luaK_concat(fs, &amp;amp;escapelist, luaK_jump(fs)); // 将 escapelist 串起来，这里的 luaK_jump 会跳转到 end
    luaK_patchtohere(fs, flist); // 把上面那个`JMP(1/3)` 地址修改对
    flist = test_then_block(ls);  /* ELSEIF cond THEN block */
  }
  if (ls-&amp;gt;t.token == TK_ELSE) {
    luaK_concat(fs, &amp;amp;escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    luaX_next(ls);  /* skip ELSE (after patch, for correct line info) */
    block(ls);  /* `else&#39; part */
  }
  else
    luaK_concat(fs, &amp;amp;escapelist, flist); // 这里把 flist 串起来了，意思是没有 else 语句，此时 flist 指向就是 end
  luaK_patchtohere(fs, escapelist); // 修改 escapelist 到 end 语句的结尾
  check_match(ls, TK_END, TK_IF, line);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在读取 token 的时候，遇到 &lt;code&gt;if ... then&lt;/code&gt; 会生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TEST reg 0 predict
JMP ??? (1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们不知道后面代码的内容，所以无法确定&lt;code&gt;???&lt;/code&gt;该填写多少，但是我们还是要记住这个位置，将来我们要把值填写进去，这个值其实就存
在&lt;code&gt;flist&lt;/code&gt;。然后我们读到&lt;code&gt;elseif cond then&lt;/code&gt;语句，这就意味着第一段代码的结束此时应该要跳转出这个&lt;code&gt;if&lt;/code&gt;
语句，所以此时应该插入一个&lt;code&gt;JMP(2)&lt;/code&gt;到整个语句的结束，因为有多个 block 的存在，后面可能会有很多这种类似的
&lt;code&gt;JMP&lt;/code&gt;，如上面示例中的各种&lt;code&gt;to 12&lt;/code&gt;，这些位置都无法确定，所以我们使用一个escapelist来指向这个地址，方便后面处理。
现在回头看&lt;code&gt;JMP(1)&lt;/code&gt;位置就确定了，所以当前的PC就是&lt;code&gt;flist&lt;/code&gt;的指向由于&lt;code&gt;elseif&lt;/code&gt;又是一个分支语句，所以又可以生成一段 &lt;code&gt;TEST &amp;amp; JMP(3)&lt;/code&gt;代码了。同样&lt;code&gt;JMP(2)&lt;/code&gt;的位置是无法确定的。
现在来谈谈&lt;code&gt;escapelist&lt;/code&gt;，定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int escapelist = NO_JUMP;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是个 int 啊，对于多个位置的&lt;code&gt;JMP(2)&lt;/code&gt;要怎么处理？lua 采用了一种巧妙的机制，由于此时的&lt;code&gt;JMP&lt;/code&gt;是无效的，还没有解析到正式地址的，
所以其中的目标地址域是没有使用的。因此，可以采用串起来的方式，escapcelist指向第一个没有解析的&lt;code&gt;JMP&lt;/code&gt;，然后这个&lt;code&gt;JMP&lt;/code&gt;的指向地址
是下一个没有解析的&lt;code&gt;JMP&lt;/code&gt;，这样一来就形成了链表的结构。后面可以一起修改目标地址通过&lt;code&gt;luaK_patchtohere&lt;/code&gt;来实现。&lt;/p&gt;

&lt;h2 id=&#34;事情没那么简单&#34;&gt;事情没那么简单&lt;/h2&gt;

&lt;p&gt;我们我们详细查看的话，&lt;code&gt;test_then_block&lt;/code&gt; -&amp;gt; &lt;code&gt;cond&lt;/code&gt; -&amp;gt; &lt;code&gt;luaK_goiftrue&lt;/code&gt;，看看&lt;code&gt;luaK_goiftrue&lt;/code&gt;函数的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void luaK_goiftrue (FuncState *fs, expdesc *e) {
  int pc;  /* pc of last jump */
  luaK_dischargevars(fs, e);
  switch (e-&amp;gt;k) {
    case VK: case VKNUM: case VTRUE: {
      pc = NO_JUMP;  /* always true; do nothing */
      break;
    }
    case VFALSE: {
      pc = luaK_jump(fs);  /* always jump */
      break;
    }
    case VJMP: {
      invertjump(fs, e);
      pc = e-&amp;gt;u.s.info;
      break;
    }
    default: {
      pc = jumponcond(fs, e, 0);
      break;
    }
  }
  luaK_concat(fs, &amp;amp;e-&amp;gt;f, pc);  /* insert last jump in `f&#39; list */
  luaK_patchtohere(fs, e-&amp;gt;t);
  e-&amp;gt;t = NO_JUMP;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面的几种，如VK、VKNUM、VTRUE都是始终成立的，所以其&lt;code&gt;e-&amp;gt;f&lt;/code&gt;是不存在的，因此为&lt;code&gt;NO_JUMP&lt;/code&gt;，而对于 VFALSE，其始终应该走错误分支，因此其&lt;code&gt;e-&amp;gt;f&lt;/code&gt;为一条JMP。&lt;code&gt;VJUMP&lt;/code&gt;是比较语句生成的, 所以其值就是代表了&lt;code&gt;e-&amp;gt;t&lt;/code&gt;和&lt;code&gt;e-&amp;gt;f&lt;/code&gt;，因此其&lt;code&gt;e-&amp;gt;f&lt;/code&gt;
就是&lt;code&gt;invertjump&lt;/code&gt;了。在各种错误JMP都生成完之后，接下来就是正确分支了，所以直接就&lt;code&gt;luaK_patchtohere&lt;/code&gt;了，当前的就是正确的逻辑。&lt;/p&gt;

&lt;p&gt;我们关注的重点其实是 &lt;code&gt;jumponcond&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static int jumponcond (FuncState *fs, expdesc *e, int cond) {
  if (e-&amp;gt;k == VRELOCABLE) {
    Instruction ie = getcode(fs, e);
    if (GET_OPCODE(ie) == OP_NOT) {
      fs-&amp;gt;pc--;  /* remove previous OP_NOT */
      return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
    }
    /* else go through */
  }
  discharge2anyreg(fs, e);
  freeexp(fs, e);
  return condjump(fs, OP_TESTSET, NO_REG, e-&amp;gt;u.s.info, cond);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于 &lt;code&gt;if not xxxx then&lt;/code&gt;之类的语句，显然其判断结果值不会被引用（只是被判断语句使用而已）所以这里使用&lt;code&gt;OP_TEST&lt;/code&gt;，其他所有情况
都是使用的&lt;code&gt;OP_TESTSET&lt;/code&gt;。我们可以看看&lt;code&gt;TESTSET&lt;/code&gt;的定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TESTSET A B C if (R(B) &amp;lt;=&amp;gt; C) then R(A) := R(B) else PC++&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Used to implement and and or logical operators, or for testing a single
register in a conditional statement.&lt;/p&gt;

&lt;p&gt;For TESTSET, register R(B) is coerced into a boolean and compared to
the boolean field C. If R(B) matches C, the next instruction is skipped,
otherwise R(B) is assigned to R(A) and the VM continues with the next
instruction. The and operator uses a C of 0 (false) while or uses a C value
of 1 (true).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果 B转换为 boolean后 和 C相等，则跳过下一条指令；否则将B赋给A然后继续执行。这条指令的目的是为短路求值服务的。那么&lt;code&gt;TESTSET&lt;/code&gt;怎
么到后面变成了&lt;code&gt;TEST&lt;/code&gt;呢？其过程就在&lt;code&gt;dischargejpc&lt;/code&gt;-&amp;gt;&lt;code&gt;patchlistaux&lt;/code&gt;-&amp;gt;&lt;code&gt;patchtestreg&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;上面我们说到&lt;code&gt;luaK_patchtohere&lt;/code&gt;将待定&lt;code&gt;JMP&lt;/code&gt;改成当前pc的功能，其实并不是直接修改的，而是通过每次生成新的字节码的时候，调用&lt;code&gt;dischargejpc&lt;/code&gt;实现的，patch 的时候只是将这个位置串起来，然后 &lt;code&gt;dischargejpc&lt;/code&gt;会便利这个链表进行修改&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;patchlistaux(fs, fs-&amp;gt;jpc, fs-&amp;gt;pc, NO_REG, fs-&amp;gt;pc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，&lt;code&gt;patchlistaux&lt;/code&gt;还进行的一项操作就是&lt;code&gt;patchtestreg&lt;/code&gt;，它的作用就是处理&lt;code&gt;TESTSET&lt;/code&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;131	static int patchtestreg (FuncState *fs, int node, int reg) {
132	  Instruction *i = getjumpcontrol(fs, node);
133	  if (GET_OPCODE(*i) != OP_TESTSET)
134	    return 0;  /* cannot patch other instructions */
135	  if (reg != NO_REG &amp;amp;&amp;amp; reg != GETARG_B(*i)) // 前者表示不需要寄存，后者两者相同的话也是不需要修改的
136	    SETARG_A(*i, reg);
137	  else  /* no register to put value or register already has the value */
138	    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i)); // 对于不需要返回值的情况，直接修改为 TEST
139	
140	  return 1;
141	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的介绍只是 条件语句的一部分，后面的文章会对短路求值，compare 运算符等做解释。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解析lua gc 中的参数控制</title>
      <link>http://sysfork.com/post/2017/lua-gc-paramter-internal/</link>
      <pubDate>Wed, 10 May 2017 20:05:41 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-gc-paramter-internal/</guid>
      <description>&lt;p&gt;lua gc 调优主要涉及到两个两个参数&lt;code&gt;setpause&lt;/code&gt;和&lt;code&gt;setstepmul&lt;/code&gt;，使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;collectgarbage(&amp;quot;setpause&amp;quot;, 200)
collectgarbage(&amp;quot;setstepmul&amp;quot;, 200)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个值的默认值都是&lt;code&gt;200&lt;/code&gt;，那么这代表着什么意思呢？通过查看代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static const char *const opts[] = {&amp;quot;stop&amp;quot;, &amp;quot;restart&amp;quot;, &amp;quot;collect&amp;quot;,
  &amp;quot;count&amp;quot;, &amp;quot;step&amp;quot;, &amp;quot;setpause&amp;quot;, &amp;quot;setstepmul&amp;quot;, NULL};
static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
  LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实&lt;code&gt;collectgarbage&lt;/code&gt;对应的就是&lt;code&gt;lua_gc&lt;/code&gt;方法，下面是其中的部分逻辑的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;LUA_API int lua_gc (lua_State *L, int what, int data) {
  switch (what) {
    case LUA_GCSTOP: g-&amp;gt;GCthreshold = MAX_LUMEM;
    case LUA_GCRESTART: g-&amp;gt;GCthreshold = g-&amp;gt;totalbytes;
    case LUA_GCCOLLECT: luaC_fullgc(L);
    case LUA_GCCOUNT: res = cast_int(g-&amp;gt;totalbytes &amp;gt;&amp;gt; 10);
    case LUA_GCCOUNTB:  res = cast_int(g-&amp;gt;totalbytes &amp;amp; 0x3ff);
    case LUA_GCSTEP: {
      lu_mem a = (cast(lu_mem, data) &amp;lt;&amp;lt; 10);
      if (a &amp;lt;= g-&amp;gt;totalbytes)
        g-&amp;gt;GCthreshold = g-&amp;gt;totalbytes - a;
      else
        g-&amp;gt;GCthreshold = 0;
      while (g-&amp;gt;GCthreshold &amp;lt;= g-&amp;gt;totalbytes) {
        luaC_step(L);
        if (g-&amp;gt;gcstate == GCSpause) {  /* end of cycle? */
          res = 1;  /* signal it */
          break;
        }
      }
      break;
    }
    case LUA_GCSETPAUSE: res = g-&amp;gt;gcpause; g-&amp;gt;gcpause = data;
    case LUA_GCSETSTEPMUL: res = g-&amp;gt;gcstepmul; g-&amp;gt;gcstepmul = data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中我们看到一些有意思的参数，在&lt;code&gt;g(global_State)&lt;/code&gt;中有如下定义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
** `global state&#39;, shared by all threads of this state
*/
typedef struct global_State {
//.....
  lu_mem GCthreshold;
  lu_mem totalbytes;  /* number of bytes currently allocated */
  lu_mem estimate;  /* an estimate of number of bytes actually in use */
  lu_mem gcdept;  /* how much GC is `behind schedule&#39; */
  int gcpause;  /* size of pause between successive GCs */
  int gcstepmul;  /* GC `granularity&#39; */
//......
} global_State;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，对于&lt;code&gt;LUA_GCSTOP&lt;/code&gt;是将&lt;code&gt;GCthreshold&lt;/code&gt;设置成一个很大的值&lt;code&gt;MAX_LUMEM&lt;/code&gt;(&lt;code&gt;~(size_t)0)-2&lt;/code&gt;)，而&lt;code&gt;LUA_GCRESTART&lt;/code&gt;则将&lt;code&gt;GCthreshold&lt;/code&gt;设置成&lt;code&gt;totalbytes&lt;/code&gt;。对于&lt;code&gt;LUA_GCSETPAUSE&lt;/code&gt;和&lt;code&gt;LUA_GCSETSTEPMUL&lt;/code&gt;则是分别设置了&lt;code&gt;gcpause&lt;/code&gt;和&lt;code&gt;gcstepmul&lt;/code&gt;的值。从注释中我们可以看到各自值的解释。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GCthreshold&lt;/td&gt;
&lt;td&gt;GC的门槛，当totalbytes大于这个值时触发gc step&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;totalbytes&lt;/td&gt;
&lt;td&gt;由内存分配器分配的&lt;strong&gt;实际&lt;/strong&gt;内存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;estimate&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;估计&lt;/strong&gt;的，正在使用的内存大小，小于 &lt;code&gt;totalbytes&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;下面这段代码是代码中随处可见，如&lt;code&gt;lua_createtable&lt;/code&gt;等，在执行操作之前都会检查是否需要触发&lt;code&gt;gc&lt;/code&gt;，以保证内存利用率。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;80	#define luaC_checkGC(L) { \
81	  condhardstacktests(luaD_reallocstack(L, L-&amp;gt;stacksize - EXTRA_STACK - 1)); \
82	  if (G(L)-&amp;gt;totalbytes &amp;gt;= G(L)-&amp;gt;GCthreshold) \
83		luaC_step(L); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 &lt;code&gt;totalbytes &amp;gt;= GCthreshold&lt;/code&gt;时触发step。因此&lt;code&gt;LUA_GCRESTART&lt;/code&gt;之后，下一次&lt;code&gt;checkGC&lt;/code&gt;的时候会立即出发&lt;code&gt;luaC_step&lt;/code&gt;。可以看到
&lt;code&gt;totalbytes&lt;/code&gt;和&lt;code&gt;GCthreshold&lt;/code&gt;是控制&lt;code&gt;GC&lt;/code&gt;的关键参数。&lt;/p&gt;

&lt;p&gt;每个回收周期结束重置&lt;code&gt;GCthreshold&lt;/code&gt; ，这里用到了的estimate。因为带有 __gc 元方法的 &lt;code&gt;userdata&lt;/code&gt; 需要两个gc周期
才能回收，在第一个gc周期中其 &lt;code&gt;__gc&lt;/code&gt;元方法会被调用，而在第二个回收周期内内存会被真正回收。因此，&lt;code&gt;estimate&lt;/code&gt;是不包含那些&lt;code&gt;__gc&lt;/code&gt;元方法被调用的&lt;code&gt;userdata&lt;/code&gt;的，而&lt;code&gt;totalbytes&lt;/code&gt;会包含（因为其反映的是真实内存占用情况）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define setthreshold(g)  (g-&amp;gt;GCthreshold = (g-&amp;gt;estimate/100) * g-&amp;gt;gcpause)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由这段代码可以看出，我们设置的&lt;code&gt;gcpause&lt;/code&gt;值影响的是下一周期开始的事件，默认&lt;code&gt;200&lt;/code&gt;的意思时，当当前&lt;strong&gt;真实&lt;/strong&gt;内存占用超过当前&lt;strong&gt;估计&lt;/strong&gt;内存占用的两倍时，才开启下一回收周期。所以如果你含&lt;code&gt;__gc&lt;/code&gt;方法的&lt;code&gt;userdata&lt;/code&gt;过大的话，很可能在第一次周期结束后立马开启了第二周期。如果设置的&lt;code&gt;gcpause&lt;/code&gt;值小于&lt;code&gt;100&lt;/code&gt;的话，那么同样两次&lt;code&gt;gc&lt;/code&gt;周期中间是没有间隔的。&lt;/p&gt;

&lt;p&gt;接下来看&lt;code&gt;luaC_step&lt;/code&gt;的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;610	void luaC_step (lua_State *L) {
611	  global_State *g = G(L);
612	  l_mem lim = (GCSTEPSIZE/100) * g-&amp;gt;gcstepmul;
613	  if (lim == 0)
614	    lim = (MAX_LUMEM-1)/2;  /* no limit */
615	  g-&amp;gt;gcdept += g-&amp;gt;totalbytes - g-&amp;gt;GCthreshold;
616	  do {
617	    lim -= singlestep(L);
618	    if (g-&amp;gt;gcstate == GCSpause)
619	      break;
620	  } while (lim &amp;gt; 0);
621	  if (g-&amp;gt;gcstate != GCSpause) {
622	    if (g-&amp;gt;gcdept &amp;lt; GCSTEPSIZE)
623	      g-&amp;gt;GCthreshold = g-&amp;gt;totalbytes + GCSTEPSIZE;  /* - lim/g-&amp;gt;gcstepmul;*/
624	    else {
625	      g-&amp;gt;gcdept -= GCSTEPSIZE;
626	      g-&amp;gt;GCthreshold = g-&amp;gt;totalbytes;
627	    }
628	  }
629	  else {
630	    setthreshold(g);
631	  }
632	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里&lt;code&gt;stepmul&lt;/code&gt;控制的就是&lt;code&gt;step&lt;/code&gt;的长度，越大则每步所进行的操作也就越多，拥有更多的「费」。其中&lt;code&gt;GCSTEPSIZE&lt;/code&gt;的值为&lt;code&gt;1024&lt;/code&gt;。也就是说默认&lt;code&gt;stepmul&lt;/code&gt;为200的情况下，大约可已进行&lt;code&gt;2048&lt;/code&gt;「费」，那么「费」是怎么定义的呢？从代码可以看到清除一条&lt;code&gt;string&lt;/code&gt;表和任意一个&lt;code&gt;gc&lt;/code&gt;对象为&lt;code&gt;10&lt;/code&gt;「费」，调用&lt;code&gt;__gc&lt;/code&gt;元方法为&lt;code&gt;100&lt;/code&gt;「费」，除非是&lt;code&gt;sweep&lt;/code&gt;阶段否则内存不会减少，因此不能使用内存差值来表示工作进度，所以引入了「费」。如果你把&lt;code&gt;stepmul&lt;/code&gt;设置为&lt;code&gt;0&lt;/code&gt;的话，那么&lt;code&gt;lim&lt;/code&gt;就是&lt;code&gt;(MAX_LUMEM-1)/2&lt;/code&gt;
为什么是这么奇怪的数值？因为&lt;code&gt;MAX_LUAEME&lt;/code&gt;是&lt;code&gt;~(size_t)0)-2&lt;/code&gt;，无符号整型，而&lt;code&gt;l_mem&lt;/code&gt;是有符号的，直接赋值会溢出的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaC_step&lt;/code&gt;的设计思路是： 每当新增分配的内存数超过&lt;code&gt;GCSTEPSIZE&lt;/code&gt;就触发一次。由于lua只会在gc过程中释放对象，所以
&lt;code&gt;totalbytes&lt;/code&gt;在gc过程外时只增不减的，因此&lt;code&gt;luaC_step&lt;/code&gt;总是会得以触发。为了准确记录新增内存使用量，lua 使用了&lt;code&gt;gcdept&lt;/code&gt;变量。
这种设计是为了防止&lt;code&gt;luaC_step&lt;/code&gt;被频繁触发，控制一个较合理的粒度。&lt;/p&gt;

&lt;p&gt;另外，&lt;code&gt;gcdept&lt;/code&gt;在每个周期末尾会清零。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;592	    case GCSfinalize: {
593	      if (g-&amp;gt;tmudata) {
594	        GCTM(L);
595	        if (g-&amp;gt;estimate &amp;gt; GCFINALIZECOST)
596	          g-&amp;gt;estimate -= GCFINALIZECOST;
597	        return GCFINALIZECOST;
598	      }
599	      else {
600	        g-&amp;gt;gcstate = GCSpause;  /* end collection */
601	        g-&amp;gt;gcdept = 0;
602	        return 0;
603	      }
604	    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>一个由 libcurl 导致的 core 分析</title>
      <link>http://sysfork.com/post/2017/a-core-cause-by-curl-sighandler/</link>
      <pubDate>Wed, 10 May 2017 15:31:06 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/a-core-cause-by-curl-sighandler/</guid>
      <description>&lt;p&gt;最近我们的项目有多个core， 使用gdb查看如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) info threads
  Id   Target Id         Frame 
  5    Thread 0x7f28943d9700 (LWP 11079) 0x00007f2895cc5c03 in epoll_wait () at ../sysdeps/unix/syscall-template.S:81
  4    Thread 0x7f2895bdc700 (LWP 11076) 0x00007f2895cbcaed in poll () at ../sysdeps/unix/syscall-template.S:81
  3    Thread 0x7f28953db700 (LWP 11077) 0x00007f2895cc5c03 in epoll_wait () at ../sysdeps/unix/syscall-template.S:81
  2    Thread 0x7f2894bda700 (LWP 11078) 0x00007f2895cc5c03 in epoll_wait () at ../sysdeps/unix/syscall-template.S:81
* 1    Thread 0x7f28983af780 (LWP 11036) 0x00007f2895c12067 in __GI_raise (sig=sig@entry=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:56
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gameapp启动了4个子线程，就是上面的2345，1是主线程，从LWP编号中也可以看出。从这里可以看到，是主线程挂掉了，bt一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#0  0x00007f2895c12067 in __GI_raise (sig=sig@entry=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:56
#1  0x00007f2895c13448 in __GI_abort () at abort.c:89
#2  0x00007f2895c0b266 in __assert_fail_base (fmt=0x7f2895d43f18 &amp;quot;%s%s%s:%u: %s%sAssertion `%s&#39; failed.\n%n&amp;quot;, assertion=assertion@entry=0x7f2897e30a7e &amp;quot;inMainThread()&amp;quot;, 
    file=file@entry=0x7f2897e30a48 &amp;quot;/home/shiwan/publish/engine/src/base/base_context.hpp&amp;quot;, line=line@entry=57, 
    function=function@entry=0x7f2897e313c0 &amp;lt;pm::common::BaseContext::assertInThisThread() const::__PRETTY_FUNCTION__&amp;gt; &amp;quot;void pm::common::BaseContext::assertInThisThread() const&amp;quot;) at assert.c:92
#3  0x00007f2895c0b312 in __GI___assert_fail (assertion=0x7f2897e30a7e &amp;quot;inMainThread()&amp;quot;, file=0x7f2897e30a48 &amp;quot;/home/shiwan/publish/engine/src/base/base_context.hpp&amp;quot;, line=57, 
    function=0x7f2897e313c0 &amp;lt;pm::common::BaseContext::assertInThisThread() const::__PRETTY_FUNCTION__&amp;gt; &amp;quot;void pm::common::BaseContext::assertInThisThread() const&amp;quot;) at assert.c:101
#4  0x00007f289777b26d in pm::common::BaseContext::assertInThisThread (this=0x7f28998d4250) at /home/shiwan/publish/engine/src/base/base_context.hpp:57
...
#27 0x00007f2896555970 in ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#28 0x00007f2896bbe0a4 in start_thread (arg=0x7f2895bdc700) at pthread_create.c:309
#29 0x00007f2895cc562d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从栈顶可以看出，是代码中调用了&lt;code&gt;assert&lt;/code&gt;失败了。因为我们的多线程模型属于&lt;code&gt;one loop per thread&lt;/code&gt;模式，跨线程调用必须通过&lt;code&gt;event loop&lt;/code&gt;来转发，这里的assert就是为了防止跨线程调用了别的线程中实例的方法。所以继续追踪栈看看调用来源。看到栈低&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#28 0x00007f2896bbe0a4 in start_thread (arg=0x7f2895bdc700) at pthread_create.c:309
#29 0x00007f2895cc562d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;WTF?主线程调用不应该是从&lt;code&gt;main&lt;/code&gt;开始的么？难道别的线程是主线程？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) thread apply all bt  -2                                                                                                                                                                                     

Thread 5 (Thread 0x7f28943d9700 (LWP 11079)):
#10 0x00007f2896bbe0a4 in start_thread (arg=0x7f28943d9700) at pthread_create.c:309
#11 0x00007f2895cc562d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 4 (Thread 0x7f2895bdc700 (LWP 11076)):
#56 0x00007f2896bbe0a4 in start_thread (arg=0x7f2895bdc700) at pthread_create.c:309
#57 0x00007f2895cc562d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 3 (Thread 0x7f28953db700 (LWP 11077)):
#10 0x00007f2896bbe0a4 in start_thread (arg=0x7f28953db700) at pthread_create.c:309
#11 0x00007f2895cc562d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 2 (Thread 0x7f2894bda700 (LWP 11078)):
#10 0x00007f2896bbe0a4 in start_thread (arg=0x7f2894bda700) at pthread_create.c:309
#11 0x00007f2895cc562d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 1 (Thread 0x7f28983af780 (LWP 11036)):
#28 0x00007f2896bbe0a4 in start_thread (arg=0x7f2895bdc700) at pthread_create.c:309
#29 0x00007f2895cc562d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看所有线程堆栈可以看到所有线程的启动函数都是&lt;code&gt;clone&lt;/code&gt;，这是不正常的。所以问题是主线程的堆栈被覆盖了，那是被哪个线程覆盖了呢？继续在主线程下查看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) f 4
#4  0x00007f289777b26d in pm::common::BaseContext::assertInThisThread (this=0x7f28998d4250) at /home/shiwan/publish/engine/src/base/base_context.hpp:57
57          void assertInThisThread() const { assert(inMainThread()); }
(gdb) p /x this-&amp;gt;dispatch_thread_id_
$3 = {_M_thread = 0x7f2895bdc700}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据线程的ID可以看出这个堆栈本来是线程4(LWP 11076)的。查看线程4的堆栈如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#0  0x00007f2895cbcaed in poll () at ../sysdeps/unix/syscall-template.S:81                                                                                                                               [38/1614]
#1  0x00007f289339dcc0 in send_dg (ansp2_malloced=0x7f2895bdac08, resplen2=0x7f2895bdac04, anssizp2=0x7f2895bdac00, ansp2=0x7f2895bdac20, anscp=0x7f2895bdac10, gotsomewhere=&amp;lt;synthetic pointer&amp;gt;, 
    v_circuit=&amp;lt;synthetic pointer&amp;gt;, ns=0, terrno=0x7f2895bd95c8, anssizp=0x7f2895bd9700, ansp=0x7f2895bd95b8, buflen2=47, buf2=0x7f2895bd9760 &amp;quot;\vd\001&amp;quot;, buflen=47, buf=0x7f2895bd9730 &amp;quot;\344A\001&amp;quot;, 
    statp=0x7f2895bdcdb8) at res_send.c:1200
#2  __libc_res_nsend (statp=statp@entry=0x7f2895bdcdb8, buf=buf@entry=0x7f2895bd9730 &amp;quot;\344A\001&amp;quot;, buflen=47, buf2=buf2@entry=0x7f2895bd9760 &amp;quot;\vd\001&amp;quot;, buflen2=buflen2@entry=47, 
    ans=ans@entry=0x7f2895bda3d0 &amp;quot;\344A\201\200&amp;quot;, anssiz=anssiz@entry=2048, ansp=ansp@entry=0x7f2895bdac10, ansp2=ansp2@entry=0x7f2895bdac20, nansp2=0x7f2895bdac00, nansp2@entry=0x7f2897e5f1c0, 
    resplen2=resplen2@entry=0x7f2895bdac04, ansp2_malloced=0x7f2895bdac08, ansp2_malloced@entry=0x7f2895bdb800) at res_send.c:545
#3  0x00007f289339bc0c in __GI___libc_res_nquery (statp=statp@entry=0x7f2895bdcdb8, name=0x7f288002ef50 &amp;quot;x&amp;quot;, class=32552, class@entry=1, type=type@entry=62321, 
    answer=answer@entry=0x7f2895bda3d0 &amp;quot;\344A\201\200&amp;quot;, anslen=2048, anslen@entry=3, answerp=answerp@entry=0x7f2895bdac10, answerp2=answerp2@entry=0x7f2895bdac20, nanswerp2=nanswerp2@entry=0x7f2895bdac00, 
    resplen2=resplen2@entry=0x7f2895bdac04, answerp2_malloced=answerp2_malloced@entry=0x7f2895bdac08) at res_query.c:227
#4  0x00007f289339c210 in __libc_res_nquerydomain (statp=0x7f2895bdcdb8, statp@entry=0x74007f2895bdcdb8, name=name@entry=0x7f288002ef50 &amp;quot;x&amp;quot;, domain=domain@entry=0x0, class=class@entry=1, 
    type=type@entry=62321, answer=answer@entry=0x7f2895bda3d0 &amp;quot;\344A\201\200&amp;quot;, anslen=3, anslen@entry=-1751285904, answerp=0x0, answerp@entry=0x7f2895bdb4f0, answerp2=0x0, answerp2@entry=0x7f2895bdb4c0, 
    nanswerp2=0x2d7, nanswerp2@entry=0x7f2895bdac00, resplen2=0x7f2895bdac04, resplen2@entry=0x7f2897e5f045, answerp2_malloced=answerp2_malloced@entry=0x7f2895bdac08) at res_query.c:594
#5  0x00007f289339c7a9 in __GI___libc_res_nsearch (statp=0x74007f2895bdcdb8, name=name@entry=0x7f288002ef50 &amp;quot;x&amp;quot;, class=class@entry=1, type=type@entry=62321, answer=answer@entry=0x7f2895bda3d0 &amp;quot;\344A\201\200&amp;quot;, 
    anslen=-1751285904, anslen@entry=2048, answerp=answerp@entry=0x7f2895bdac10, answerp2=answerp2@entry=0x7f2895bdac20, nanswerp2=nanswerp2@entry=0x7f2895bdac00, resplen2=resplen2@entry=0x7f2895bdac04, 
    answerp2_malloced=answerp2_malloced@entry=0x7f2895bdac08) at res_query.c:381
#6  0x00007f28935adacb in _nss_dns_gethostbyname4_r (name=0x7f288002ef50 &amp;quot;x&amp;quot;, name@entry=0x7f2895f83060 &amp;lt;_IO_2_1_stderr_&amp;gt; &amp;quot;\207(\255&amp;quot;, &amp;lt;incomplete sequence \373&amp;gt;, pat=0x7f2895bdb1f8, pat@entry=0xfbad2086, 
    buffer=buffer@entry=0x7f2895bdaca0 &amp;quot;H\025&amp;quot;, &amp;lt;incomplete sequence \310&amp;gt;, buflen=buflen@entry=1064, errnop=0x7f2895bdb1e8, errnop@entry=0x7f2895bdb7b0, herrnop=0x7f2895bdb210, herrnop@entry=0x7f2895d42acf, 
    ttlp=ttlp@entry=0x0) at nss_dns/dns-host.c:315
#7  0x00007f2895cb113c in gaih_inet (name=&amp;lt;optimized out&amp;gt;, service=&amp;lt;optimized out&amp;gt;, req=&amp;lt;optimized out&amp;gt;, pai=&amp;lt;optimized out&amp;gt;, naddrs=&amp;lt;optimized out&amp;gt;) at ../sysdeps/posix/getaddrinfo.c:870
#8  0x00007f2895bdb800 in ?? ()
#9  0x00007f289994d1e0 in ?? ()
#10 0x00007f2895bdb49f in ?? ()
.....
#29 0x00007f2897e30a48 in ?? ()
#30 0x0000000000000039 in ?? ()
#31 0x00007f2895c0b312 in __GI___assert_fail (assertion=0x7f2897e30a7e &amp;quot;inMainThread()&amp;quot;, 
    file=0x7f2897e313c0 &amp;lt;pm::common::BaseContext::assertInThisThread() const::__PRETTY_FUNCTION__&amp;gt; &amp;quot;void pm::common::BaseContext::assertInThisThread() const&amp;quot;, line=2548241344, function=0x7f28998d6280 &amp;quot;&amp;quot;)
    at assert.c:101
#32 0x00007f289777b26d in pm::common::BaseContext::assertInThisThread (this=0x7f28998d4250) at /home/shiwan/publish/engine/src/base/base_context.hpp:57
.....
#54 0x00007f289790e56c in std::thread::_Impl&amp;lt;std::_Bind_simple&amp;lt;pm::common::ThreadBase::start()::&amp;lt;lambda()&amp;gt;()&amp;gt; &amp;gt;::_M_run(void) (this=0x7f28998d0e80) at /usr/include/c++/4.9/thread:115
#55 0x00007f2896555970 in ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#56 0x00007f2896bbe0a4 in start_thread (arg=0x7f2895bdc700) at pthread_create.c:309
#57 0x00007f2895cc562d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;堆栈下面的内容和刚刚在主线程中的堆栈一致，各种变量的值都是一样的。从31号frame往上就不正常了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#29 0x00007f2897e30a48 in ?? ()
#30 0x0000000000000039 in ?? ()
#31 0x00007f2895c0b312 in __GI___assert_fail (assertion=0x7f2897e30a7e &amp;quot;inMainThread()&amp;quot;, 
    file=0x7f2897e313c0 &amp;lt;pm::common::BaseContext::assertInThisThread() const::__PRETTY_FUNCTION__&amp;gt; &amp;quot;void pm::common::BaseContext::assertInThisThread() const&amp;quot;, line=2548241344, function=0x7f28998d6280 &amp;quot;&amp;quot;)
    at assert.c:101
#32 0x00007f289777b26
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以出现的情景是子线程4运行过程中，主线程的栈指针&lt;code&gt;%rsp&lt;/code&gt;被修改到子线程4的栈空间了。由于&lt;code&gt;%rsp&lt;/code&gt;被破坏，函数返回时，保存的pc就不是原来的返回点，而是线程4的控制流，调用栈就被错误地设置了。在开始debug的时候，我错误的以为由于线程4的栈
被破坏，加上其中一堆&amp;rdquo;???&amp;ldquo;，所以没什么参考价值。但是仔细看看栈顶&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#0  0x00007f2895cbcaed in poll () at ../sysdeps/unix/syscall-template.S:81                                                                                                                               [38/1614]
#1  0x00007f289339dcc0 in send_dg (ansp2_malloced=0x7f2895bdac08, resplen2=0x7f2895bdac04, anssizp2=0x7f2895bdac00, ansp2=0x7f2895bdac20, anscp=0x7f2895bdac10, gotsomewhere=&amp;lt;synthetic pointer&amp;gt;, 
    v_circuit=&amp;lt;synthetic pointer&amp;gt;, ns=0, terrno=0x7f2895bd95c8, anssizp=0x7f2895bd9700, ansp=0x7f2895bd95b8, buflen2=47, buf2=0x7f2895bd9760 &amp;quot;\vd\001&amp;quot;, buflen=47, buf=0x7f2895bd9730 &amp;quot;\344A\001&amp;quot;, 
    statp=0x7f2895bdcdb8) at res_send.c:1200
#2  __libc_res_nsend (statp=statp@entry=0x7f2895bdcdb8, buf=buf@entry=0x7f2895bd9730 &amp;quot;\344A\001&amp;quot;, buflen=47, buf2=buf2@entry=0x7f2895bd9760 &amp;quot;\vd\001&amp;quot;, buflen2=buflen2@entry=47, 
    ans=ans@entry=0x7f2895bda3d0 &amp;quot;\344A\201\200&amp;quot;, anssiz=anssiz@entry=2048, ansp=ansp@entry=0x7f2895bdac10, ansp2=ansp2@entry=0x7f2895bdac20, nansp2=0x7f2895bdac00, nansp2@entry=0x7f2897e5f1c0, 
    resplen2=resplen2@entry=0x7f2895bdac04, ansp2_malloced=0x7f2895bdac08, ansp2_malloced@entry=0x7f2895bdb800) at res_send.c:545
#3  0x00007f289339bc0c in __GI___libc_res_nquery (statp=statp@entry=0x7f2895bdcdb8, name=0x7f288002ef50 &amp;quot;x&amp;quot;, class=32552, class@entry=1, type=type@entry=62321, 
    answer=answer@entry=0x7f2895bda3d0 &amp;quot;\344A\201\200&amp;quot;, anslen=2048, anslen@entry=3, answerp=answerp@entry=0x7f2895bdac10, answerp2=answerp2@entry=0x7f2895bdac20, nanswerp2=nanswerp2@entry=0x7f2895bdac00, 
    resplen2=resplen2@entry=0x7f2895bdac04, answerp2_malloced=answerp2_malloced@entry=0x7f2895bdac08) at res_query.c:227
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程正在poll，从上一层的调用来看应该是在做DNS查询, gameapp的最后一行log是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;I0223 15:06:34.988075 11076 http_manager.cpp:237] Adding curl task url: http://pm01.gmsdk.gameyw.netease.com/app/gen_token.json?game_server=20001&amp;amp;game_uid=4212937&amp;amp;lang=zh_cn&amp;amp;nickname=%E4%BA%8E%E5%AE%B6%E6%AD%8C&amp;amp;pid=pm01&amp;amp;platform=android&amp;amp;refer=%2Fsprite.html&amp;amp;sign=e17e1efcf43bfd036e4410e4b1b844b8&amp;amp;time=1487833594&amp;amp;type=1&amp;amp;uid=aebfpu46xuf3q3ag%40ad.netease.win.163.com&amp;amp;vip=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这行log是线程4打出来的，所以可以判定，此时线程4正在做DNS查询，而调用这个这个DNS的正是curl。那一个简单的DNS查询怎么会导致程序挂掉呢？我们来分析一下CURL的源码：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Curl_resolv_timeout&lt;/code&gt;是curl用于做dns解析的入口，从函数名可以看出这是个支持timeout的DNS解析函数，然而我们操作系统的如&lt;code&gt;getaddrinfo&lt;/code&gt;，&lt;code&gt;gethostbyname&lt;/code&gt;之类的函数都是同步阻塞调用，不支持超时参数的啊。仔细看&lt;code&gt;Curl_resolv_timeout&lt;/code&gt;
的实现发现其使用&lt;code&gt;SIGALRM&lt;/code&gt;信号的机制来实现在线程阻塞等待时，依然能够在一定时间之后得到通知，从而放弃继续等待的目的。下面是一个简化后的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static RETSIGTYPE alarmfunc(int sig)
{
  siglongjmp(curl_jmpenv, 1);
  return;
}

int Curl_resolv_timeout()
{
if(sigsetjmp(curl_jmpenv, 1)) {
  failf(data, &amp;quot;name lookup timed out&amp;quot;);
  rc = CURLRESOLV_ERROR;
  goto clean_up;
}

keep_sigact = signal(SIGALRM, alarmfunc);
alarm(curlx_sltoui(timeout/1000L));
Curl_resolv(conn, hostname, port, entry);
signal(SIGALRM, keep_sigact);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过alarm触发超时，在调用&lt;code&gt;Curl_resolv&lt;/code&gt;之前设置好jumppoint，一旦alarm触发，调用&lt;code&gt;alarmfunc&lt;/code&gt;，再&lt;code&gt;longjump&lt;/code&gt;到jumppoint位置，间接实现了目的。&lt;/p&gt;

&lt;p&gt;&lt;b&gt;然而这种做法在多线程情况下是灾难&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;在多线程情况下，当一个面向进程的信号事件发生时，系统会选择任意一个可以处理该信号的线程来处理。其中SIGALRM正是一个面向进程的信号事件，所以其可能会被其他线程处理。
这个信号被主线程捕捉到了。现在来还原整个事件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;子线程发起设置好alarm，发起DNS请求并等待&lt;/li&gt;
&lt;li&gt;由于DNS查询速度比较慢，ALARM信号事件触发&lt;/li&gt;
&lt;li&gt;主线程捕捉到这一信号，调用&lt;code&gt;alarmfunc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alarmfunc&lt;/code&gt;的作用是&lt;code&gt;longjump&lt;/code&gt;，所以主线程的执行环境被替换成子线程的执行环境，栈被破坏&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;解决方案：
通过查看curl代码，发现其还有一种异步dns模式，但是需要使用&lt;a href=&#34;https://c-ares.haxx.se&#34;&gt;c-ares&lt;/a&gt;库，所以最终引进了这个库，替换掉了原来的使用系统DNS查询方案。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>嵌入 luajit 时同时使用 ffi 和 c api 的解决方案</title>
      <link>http://sysfork.com/post/2017/compatible-embed-luajit-ffi-load/</link>
      <pubDate>Tue, 09 May 2017 22:05:47 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/compatible-embed-luajit-ffi-load/</guid>
      <description>&lt;p&gt;我们都喜欢&lt;a href=&#34;http://luajit.org/ext_ffi.html&#34;&gt;ffi&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;ffi 的接口简单易用，当使用第三方没有提供 lua 接口的库来说，使用 ffi 接入相当容易。
而且效率比较高，通过 ffi 调用的接口是可以被 jit 编译的，效率相对于使用传统的 &lt;a href=&#34;https://www.lua.org/pil/24.html&#34;&gt;lua c api&lt;/a&gt;来说要
高得多。ffi 直接使用了操作系统的调用模型，除了数据结构转化的代价外没有额外的负担。而使用传统 c api 则是
通过 lua 虚拟栈来实现，并且需要和 lua 的调用模型兼容，实现起来比较复杂。&lt;/p&gt;

&lt;p&gt;但是，对于接入 lua 的程序而言，仅仅支持 luajit 是有一定风险的，相对于 &lt;a href=&#34;https://www.lua.org/&#34;&gt;puc lua&lt;/a&gt;， luajit 的主要开发者和维护者
比较少，应用面也不如 lua。所以大部分的面相 lua 的程序都会同时支持 luajit 和 lua。ffi 是 luajit 内置的模块，而 lua 却不携带这个模块，
有一些开源的项目， 如 facebook 开发的&lt;a href=&#34;https://github.com/facebook/luaffifb&#34;&gt;这个&lt;/a&gt;，但是经过我们的测试其效率比普通的c api还慢: (。
所以一个比较折中的方案是同时提供 ffi binding 和 c binding 的方案，这是大部分 lua 库的选择。&lt;/p&gt;

&lt;p&gt;如果提供的是一个 so 库，那么只需要提供个 lua 入口文件，如果使用 ffi 的话，则调用相关的 lua 文件。如果是 c binding 的话，那就调用具体的
so文件。然而这在我们的项目中是不可行的，为了保证部署的简化，我们的程序只有一个可执行文件，不会依赖除一些核心 so 库之外的 so 库。所有的
c binding 代码都是在可执行文件里面的。这就意味着我们需要 &lt;code&gt;ffi.load&lt;/code&gt; 我们自己的可执行文件。大概的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;// main.c

char* encode(const char* input, size_t size, size_t *out_size) { // 假设这是我们的工作函数
    //...
}

// c api
int l_encode(lua_State* L) { // 为了让上面的接口能被 lua 调用，需要转换一下
    size_t length, out_size;
    char *in_data, *out_data;
    in_data = lua_tolstring(L, 1, &amp;amp;length);
    out_data = encode(in_data, length, &amp;amp;out_size);
    lua_pushlstring(L, out_data, out_size);
    return 1;
}

// register in some place 
lua_pushcfunction(L, l_encode); // 注册到 lua 虚拟机中
lua_setglobal(L, &amp;quot;c_encode&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是统一的入口文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;-- ffi.lua

if ffi then -- 如果能使用 ffi 的话
    lib = ffi.load(????) -- 这里改怎么写
    ffi.cdef[[
        char* encode(const char* input, size_t size, size_t *out_size);
    ]]
    -- do some dirty jobs
    lib.encode -- ...
else
    encode = c_encode -- 使用 c api 版本
end


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而这是不可行的。&lt;/p&gt;

&lt;p&gt;ffi load 调用的其实就是&lt;a href=&#34;http://man7.org/linux/man-pages/man3/dlopen.3.html&#34;&gt;dlopen&lt;/a&gt;。如果我们有一个可执行文件 &lt;code&gt;a.out&lt;/code&gt;，在这里面
调用 &lt;code&gt;dlopen(&amp;quot;a.out&amp;quot;, ...)&lt;/code&gt;，其作用是将 &lt;code&gt;a.out&lt;/code&gt; 的内容加载到内存中，加上我们之前运行 &lt;code&gt;a.out&lt;/code&gt; 的程序（其实也是用 &lt;code&gt;/lib64/ld-linux-x86-64.so&lt;/code&gt; 加载的）。
这样内存中就有了两份一样的镜像，一个全局变量会对应两个内存地址。这种产生的原因可以参考&lt;a href=&#34;https://book.douban.com/subject/3652388/&#34;&gt;程序员的自我修养&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;使用现有的 luajit 接口是无法做到的。但是 &lt;code&gt;dlopen&lt;/code&gt; 可以&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If filename is  NULL,  then  the  returned handle  is for the main program&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当 filename 为 NULL 时，直接返回当前程序的 dl handle，可以取得各种 symbol 的地址。所以我们可以稍微修改下 luajit 的实现:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// in lj_clib.c
static const char *clib_extname(lua_State *L, const char *name
{
  if (!name[0]) return NULL; // 添加这一行
  if (!strchr(name, &#39;/&#39;)
#if LJ_TARGET_CYGWIN
      &amp;amp;&amp;amp; !strchr(name, &#39;\\&#39;)
#endif
     ) {
    if (!strchr(name, &#39;.&#39;)) {
      name = lj_strfmt_pushf(L, CLIB_SOEXT, name);
      L-&amp;gt;top--;
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么在应用中就可以这样使用了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local ffi = require(&amp;quot;ffi&amp;quot;)
local lib = ffi.load(&amp;quot;&amp;quot;)
ffi.cdef[[...]]
-- lib.doSomething
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样对于单可执行文件就可以是的 c binding 和 ffi binding 共存了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>让disqus支持大陆访问</title>
      <link>http://sysfork.com/post/2017/use-disqus-in-china/</link>
      <pubDate>Sun, 07 May 2017 18:11:51 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/use-disqus-in-china/</guid>
      <description>

&lt;p&gt;由于众所周知的原因，&lt;a href=&#34;https://disqus.com/&#34;&gt;disqus&lt;/a&gt; 在大陆难以访问，随着&lt;a href=&#34;https://duoshuo.com&#34;&gt;多说&lt;/a&gt;的关闭，无法正常地使用评论功能已经成为
「静态博客生成器类博客」的一个问题。 好在 disqus 提供了一些 &lt;a href=&#34;https://disqus.com/api/docs/&#34;&gt;api&lt;/a&gt; ，在这里我们可以使用一些方法实现评论的功能。&lt;/p&gt;

&lt;h1 id=&#34;后端&#34;&gt;后端&lt;/h1&gt;

&lt;p&gt;之前已经有部分的解决方案，其中最完善的是 &lt;a href=&#34;https://shijianan.com/2017/01/02/build-your-own-disqus/&#34;&gt;这里&lt;/a&gt; ，其中使用的方法是创建一个
&lt;a href=&#34;https://disqus.com/api/applications/&#34;&gt;disqus application&lt;/a&gt; ，
然后使用各种 api ，这里可以使用 python 或者直接使用 nginx 的反向代理。我也更新这段 &lt;a href=&#34;https://github.com/shijn/disqus-proxy&#34;&gt;python&lt;/a&gt; 代码，但是在
创建评论的时候总是出错， 提示 &lt;code&gt;This application cannot create posts on the chosen forum (code 12)&lt;/code&gt; 。在尝试了多种
&lt;a href=&#34;http://stackoverflow.com/questions/15416688/disqus-api-create-comment-as-guest&#34;&gt;方法&lt;/a&gt;，查阅了众多网页均没有解决。后来找到一种说法，说是这个接口无法使用
自己创建的&lt;code&gt;api_key&lt;/code&gt;，最终找到了&lt;a href=&#34;http://spirytoos.blogspot.com/2013/12/not-so-easy-posting-as-guest-via-disqus.html&#34;&gt;解决方案&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;其实答案就在 disqus 的前端 js 里面。使用 chrome network tools 可以看到有一些访问：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Request URL:https://disqus.com/api/3.0/embed/threadDetails.json?thread=5781899723
&amp;amp;api_key=E8Uh5l5fHZ6gD8U3KycjAIAk46f68Zw7C6eW8WSjZvCLXebZ7p0r1yrYDrLilk2F
Request Method:GET
Status Code:200 OK
Remote Address:127.0.0.1:1081
Referrer Policy:no-referrer-when-downgrade
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 disqus 官方的 js 也是使用了这套 api ，其中 api_key 赫然在列，并且在3年后的今天这个 key 依然有效，并且这个 key cd 是无限的，不像 &lt;a href=&#34;https://data.disqus.com/capabilities/&#34;&gt;disqus application &lt;/a&gt;
有着 1000 次/hour 的全局限制。值得注意的是，使用这个 api_key 要求必须提供 Referer 和 Origin，并且都要是官方的地址：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Referer https://disqus.com;
Origin https://disqus.com;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以本站采用的一个反向代理的配置为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location ~ ^/disqus/(.*) {
    proxy_pass https://disqus.com/api/3.0/$1?api_key=E8Uh5l5fHZ6gD8U3KycjAIAk46f68Zw7C6eW8WSjZvCLXebZ7p0r1yrYDrLilk2F&amp;amp;$args;
    proxy_set_header Referer https://disqus.com;
    proxy_set_header Origin https://disqus.com;
    proxy_redirect off;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来就可以直接使用正常的接口了。大部分的接口都是支持 jsonp 的，所以可以跨域调用，对于 POST 请求如发表评论等无法使用 jsonp 的情况，只能放在同一个服务器下面了。期待有人能做一个支持跨域的公共接口 :)。&lt;/p&gt;

&lt;h1 id=&#34;前端&#34;&gt;前端&lt;/h1&gt;

&lt;p&gt;前端的部分有点麻烦，但是至少是有解决方案的，可以使用各种插件如&lt;a href=&#34;https://github.com/Viima/jquery-comments&#34;&gt;jquery comments&lt;/a&gt;等，本站使用的是一个自己随便写的实现，所以界面比较挫，有兴趣的可以看看
本站的&lt;a href=&#34;https://github.com/usbuild/site&#34;&gt;代码实现&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;对于一些有「梯子」的用户，我们还是希望能够这些用户能够正常访问，所以使用了一个策略：当能够正常加载 disqus 官方 js 时就使用官方版本，否则就使用简易版本，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function RenderComment(forum, apiPath, selector, url) {
  var done = false;
  var dsq = document.createElement(&#39;script&#39;);
  dsq.src = &#39;//&#39;+forum+&#39;.disqus.com/embed.js&#39;;
  dsq.onload = function()  {
    done = true;
  };
  document.head.appendChild(dsq);
  setTimeout(function () { if (!done)
    api = new CommentAPI(forum, apiPath, selector, url);
  }, 2000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本站的代码实现相当简陋，仅仅提供一个思路，希望能有所帮助。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一种在elf中集成脚本文件的方案</title>
      <link>http://sysfork.com/post/2017/a-solution-for-elf-integrate-scripts/</link>
      <pubDate>Mon, 01 May 2017 22:30:00 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/a-solution-for-elf-integrate-scripts/</guid>
      <description>

&lt;p&gt;进行游戏服务器开发时，我们将&lt;code&gt;C++&lt;/code&gt;的部分称之为引擎层，而&lt;code&gt;lua&lt;/code&gt;称之为脚本层。但是往往有些核心逻辑是各个游戏公用的，
或者说有些引擎层的代码用&lt;code&gt;C++&lt;/code&gt;写起来十分麻烦，我们还是会使用&lt;code&gt;lua&lt;/code&gt;来编写。这就带来了一些问题，我们的游戏目录结构如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├─bin               // 可执行文件
└─scripts           // 脚本目录，lua文件
    ├─framework     // 核心lua文件，各个项目公用的
    └─server        // 游戏逻辑lua文件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;scripts/framework&lt;/code&gt;是各个项目公用的，并且和&lt;code&gt;bin&lt;/code&gt;目录中的可执行文件同时发布和更新。所以有一个想法，就是将&lt;code&gt;framework&lt;/code&gt;中
的lua文件集成到可执行文件中，减少维护的成本。&lt;/p&gt;

&lt;h1 id=&#34;文件存储&#34;&gt;文件存储&lt;/h1&gt;

&lt;p&gt;下面是elf文件的示意图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Elf-layout--en.svg/260px-Elf-layout--en.svg.png&#34; alt=&#34;elf&#34; /&gt;&lt;/p&gt;

&lt;p&gt;elf文件有多个section，除了一些预定义的section如&lt;code&gt;.rodata&lt;/code&gt;、&lt;code&gt;.text&lt;/code&gt;、&lt;code&gt;.init&lt;/code&gt;等，我们也可以定义一些自己的section。所以我们可以将所需要的lua文件
放进这个section中，在执行的时候动态读出来，实现目的。我们可以使用&lt;a href=&#34;https://linux.die.net/man/1/objcopy&#34;&gt;objcopy&lt;/a&gt;命令来实现创建自定义section的功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objcopy infile.out --add-section .lua-data=section_file outfile.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而&lt;code&gt;framework&lt;/code&gt;里面有多个文件，而且包含嵌套的文件夹，我们需要一个将文件夹变成单个文件的功能，类似于&lt;a href=&#34;https://linux.die.net/man/1/tar&#34;&gt;tar&lt;/a&gt;。虽然创建
section时使用&lt;code&gt;tar&lt;/code&gt;命令是简单的，但是在读取的时候需要一些第三方的库来支持，这是比较麻烦的。而由于我们的目录中只包含&lt;code&gt;lua&lt;/code&gt;文件，所以可以简化设计。
首先空文件夹对于我们是无意义的，只需要&lt;code&gt;lua&lt;/code&gt;文件就可以。所以最终我们得到如下的表:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;┌────────────────────┐
│ libs/json.lua      │
├────────────────────┤
│ core/entity.lua    │
├────────────────────┤
│ app/game.lua       │
├────────────────────┤
│ libs/bson.lua      │
└────────────────────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以按照如下的格式转换成单个文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;┌────────┬───────────┐
│name_len│content_len│
├────────┴───────────┤
│ core.entity        │
├────────────────────┤
│name_len│content_len│
├────────────────────┤
│ libs.bson          │
├────────────────────┤
│ .................  │
└────────────────────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;name_len&lt;/code&gt;为文件名的长度，这里直接转换成了lua中&lt;code&gt;require&lt;/code&gt;的格式，使用点符号。&lt;code&gt;content_len&lt;/code&gt;是文件内容的长度，即文件的具体内容长度。最后我们可以使用&lt;code&gt;zip&lt;/code&gt;指令
将这部分内容压缩存储在&lt;code&gt;elf&lt;/code&gt;文件中。完整的代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
#coding: utf-8

import os, struct, StringIO, zlib, subprocess, sys, tempfile, argparse

argParser = argparse.ArgumentParser()

argParser.add_argument(&amp;quot;luafolder&amp;quot;, type=str)
argParser.add_argument(&amp;quot;exe&amp;quot;, type=str)
argParser.add_argument(&amp;quot;out&amp;quot;, type=str)

args = argParser.parse_args()

files = []

path = args.luafolder

for (dirpath, dirname, filenames) in os.walk(path):
    dirp = dirpath[len(path):]
    if dirp:
        if dirp[-1] != &amp;quot;/&amp;quot;:
            dirp += &amp;quot;/&amp;quot;

        while dirp[0] == &amp;quot;/&amp;quot;:
            dirp = dirp[1:]

    files.extend([dirp + x for x in filenames])

output = StringIO.StringIO()

for fpath in files:
    realp = path + &amp;quot;/&amp;quot; + fpath
    filesize = os.path.getsize(realp)

    if fpath.endswith(&amp;quot;.lua&amp;quot;):
        fpath = fpath[:-4]
    elif fpath.endswith(&amp;quot;.luac&amp;quot;):
        fpath = fpath[:-5]
    else:
        continue

    package_pattern = fpath.replace(&amp;quot;/&amp;quot;, &amp;quot;.&amp;quot;)
    package_pattern = &amp;quot;pg.&amp;quot; + package_pattern
    with open(realp, &amp;quot;rb&amp;quot;) as rf:
        content = rf.read()
        output.write(struct.pack(&amp;quot;=hL&amp;quot;, len(package_pattern), len(content)))
        output.write(package_pattern)
        output.write(content)

f = tempfile.NamedTemporaryFile()

outdata = output.getvalue()
f.write(struct.pack(&amp;quot;=L&amp;quot;, len(outdata)))
f.write(zlib.compress(output.getvalue()))
f.flush()

subprocess.call(&amp;quot;objcopy %s --remove-section .lua-data&amp;quot;%(args.exe, ), shell=True)
subprocess.call(&amp;quot;objcopy %s --add-section .lua-data=%s %s&amp;quot;%(args.exe, f.name, args.out), shell=True)

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;文件内容的读取&#34;&gt;文件内容的读取&lt;/h1&gt;

&lt;p&gt;我们需要使用&lt;code&gt;elf.h&lt;/code&gt;文件来读取文件内容。根据上述的格式示意图，&lt;code&gt;elf&lt;/code&gt;文件开头的是Header，其格式为&lt;code&gt;ElfXX_Ehdr&lt;/code&gt;，
我们可以直接读取文件内容到内存。然后读取&lt;code&gt;e_shoff&lt;/code&gt;字段获得section header的位置，定位到位置并依次读取内容到&lt;code&gt;ElfXX_Shdr&lt;/code&gt;
结构体中，然后通过各个entry的&lt;code&gt;sh_name&lt;/code&gt;得到最终section，然后读取文件达到目的。完整代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static std::map&amp;lt;std::string, std::string&amp;gt; readElfLuaData(const std::string &amp;amp;filepath) {
    std::map&amp;lt;std::string, std::string&amp;gt; files;
#if __x86_64__
    typedef Elf64_Ehdr ELF_EHDR;
    typedef Elf64_Shdr ELF_SHDR;
#else
    typedef Elf32_Ehdr ELF_EHDR;
    typedef Elf32_Shdr ELF_SHDR;
#endif

    std::ifstream ifs(filepath);

    ELF_EHDR hdr;
    ifs.read(reinterpret_cast&amp;lt;char *&amp;gt;(&amp;amp;hdr), sizeof(hdr));

    std::vector&amp;lt;ELF_SHDR&amp;gt; sh_tables(hdr.e_shnum);
    ifs.seekg(static_cast&amp;lt;long&amp;gt;(hdr.e_shoff));

    for (size_t i = 0; i &amp;lt; hdr.e_shnum; ++i) {
        ifs.read(reinterpret_cast&amp;lt;char *&amp;gt;(&amp;amp;sh_tables[i]), sizeof(sh_tables[i]));
    }

    // read shstr

    std::vector&amp;lt;char&amp;gt; shstr(sh_tables[hdr.e_shstrndx].sh_size);
    ifs.seekg(static_cast&amp;lt;long&amp;gt;(sh_tables[hdr.e_shstrndx].sh_offset));
    ifs.read(shstr.data(), static_cast&amp;lt;long&amp;gt;(shstr.size()));

    ELF_SHDR *lua_sh = nullptr;

    for (size_t i = 0; i &amp;lt; hdr.e_shnum; ++i) {
        char *name = shstr.data() + sh_tables[i].sh_name;
        if (strcmp(name, &amp;quot;.lua-data&amp;quot;) == 0) {
            lua_sh = &amp;amp;sh_tables[i];
            break;
        }
    }

    if (lua_sh) {
        std::vector&amp;lt;char&amp;gt; buf(lua_sh-&amp;gt;sh_size);
        ifs.seekg(static_cast&amp;lt;long&amp;gt;(lua_sh-&amp;gt;sh_offset));
        ifs.read(buf.data(), static_cast&amp;lt;std::streamsize&amp;gt;(buf.size()));

        size_t idx = 0;
#define READ_TO(TARGET, SIZE)                                                                      \
    memcpy(TARGET, buf.data() + idx, SIZE);                                                        \
    idx += SIZE;

        uint32_t raw_len = 0;
        READ_TO(&amp;amp;raw_len, sizeof(raw_len));

        std::vector&amp;lt;char&amp;gt; tmp(raw_len);
        uLongf dest_len = tmp.size();
        uncompress(reinterpret_cast&amp;lt;Bytef *&amp;gt;(tmp.data()), &amp;amp;dest_len,
                   reinterpret_cast&amp;lt;Bytef *&amp;gt;(buf.data() + idx), buf.size() - idx);

        buf.swap(tmp);
        idx = 0;

        while (idx &amp;lt; dest_len) {
            uint16_t name_len;
            uint32_t content_len;
            READ_TO(&amp;amp;name_len, sizeof(name_len));
            READ_TO(&amp;amp;content_len, sizeof(content_len));
            std::string filename(name_len, 0), content(content_len, 0);
            READ_TO(&amp;amp;*filename.begin(), filename.size());
            READ_TO(&amp;amp;*content.begin(), content.size());
            files.emplace(std::piecewise_construct, std::forward_as_tuple(std::move(filename)),
                          std::forward_as_tuple(std::move(content)));
        }
#undef READ_TO
    }
    return files;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来便可以通过添加到&lt;code&gt;package.preload&lt;/code&gt;实现在lua中调用这些文件的目的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用C&#43;&#43; map实现注册回调的功能</title>
      <link>http://sysfork.com/post/2017/cpp-function-container/</link>
      <pubDate>Sat, 29 Apr 2017 15:38:38 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/cpp-function-container/</guid>
      <description>

&lt;p&gt;在&lt;code&gt;C++/lua&lt;/code&gt;混合编程中，往往存在需要回调的情况。比如在游戏中，逻辑进程中的脚本需要一个数据库访问操作，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;dbmgr.query({name=&amp;quot;hello&amp;quot;}, function(ret)
-- do something
end)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于&lt;code&gt;dbmgr.query&lt;/code&gt;是异步操作，这条语句是立即返回的。内部执行过程中是通过向&lt;code&gt;dbmgr&lt;/code&gt;进程发送一个&lt;code&gt;query&lt;/code&gt;请求，然后逻辑进程继续执行。当&lt;code&gt;dbmgr&lt;/code&gt;收到请求后，其执行数据库查询操作，得到
结果然后也是通过网络将其发送给逻辑进程。逻辑进程收到结果后调用到&lt;code&gt;lua&lt;/code&gt;的回调函数里。&lt;/p&gt;

&lt;p&gt;这里有一个简化方案，如果时仅仅针对&lt;code&gt;lua&lt;/code&gt;的话，只需要在向&lt;code&gt;dbmgr&lt;/code&gt;进程发送请求的时候带上&lt;code&gt;lua function&lt;/code&gt;的注册ID就好了，查询到结果后返回过来就能直接调用。但是我们希望这个接口不仅仅在
&lt;code&gt;lua&lt;/code&gt;中使用，希望在&lt;code&gt;C++&lt;/code&gt;中也能调用，并且希望提供一个统一的模块来负责这类事情，该如何设计？一个简化后的问题如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;functional&amp;gt;
#include &amp;lt;map&amp;gt;

std::map&amp;lt;int, std::function&amp;lt;void(void*)&amp;gt;&amp;gt; callbacks;
int last_idx = 0;

//用于注册回调函数，需要支持各种function
template&amp;lt;typename T&amp;gt;
int addCallback(T &amp;amp;&amp;amp; t) {
}

//用于调用回调函数
template&amp;lt;typename ... ARGS&amp;gt;
void call(int idx, ARGS &amp;amp;&amp;amp; ... args) {
}

void func(int i) {}

class Functor {
public:
	void operator()(const std::string &amp;amp;s, int i) {}
};

int main() {
	int c1 = addCallback(&amp;amp;func);
	int i;
	int c2 = addCallback([i](double j) {});
	int c3 = addCallback(Functor());

	call(c1, 1);
	call(c2, 1.0);
	call(c3, std::string(&amp;quot;string&amp;quot;), 1);

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;addCallback&lt;/code&gt;的作用用于注册回调函数，参数可以是&lt;code&gt;std::function&lt;/code&gt;、&lt;code&gt;lambda&lt;/code&gt;、&lt;code&gt;functor&lt;/code&gt;、普通的函数、成员函数等等。这里为了简化处理，我们只
处理&lt;code&gt;std::function&lt;/code&gt;、&lt;code&gt;lambda&lt;/code&gt;和普通函数，其余的不再赘述。下面是一些问题：&lt;/p&gt;

&lt;h1 id=&#34;参数的处理&#34;&gt;参数的处理？&lt;/h1&gt;

&lt;p&gt;由于我们使用的是&lt;code&gt;map&lt;/code&gt;，&lt;code&gt;value_type&lt;/code&gt;是一定的，你无法将多个不同类型的&lt;code&gt;std::function&lt;/code&gt;放进去，所以需要需要包一层，这里存储的是&lt;code&gt;std::function&amp;lt;void(void*)&amp;gt;&lt;/code&gt;，
由于是异步调用，返回值我们不关心。参数使用的是&lt;code&gt;void*&lt;/code&gt;，将类型给抹除掉了。那么参数的具体内容是什么呢？可以使用&lt;code&gt;std::tuple&lt;/code&gt;来存储，那&lt;code&gt;call&lt;/code&gt;的实现就很简单了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename ... ARGS&amp;gt;
void call(int idx, ARGS &amp;amp;&amp;amp; ... args) {
	auto it = callbacks.find(idx);
	if (it != callbacks.end() {
		auto tuple = std::tuple&amp;lt;ARGS...&amp;gt;(args...);
		it-&amp;gt;second(&amp;amp;tuple);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;callbacks-存储的内容是&#34;&gt;&lt;code&gt;callbacks&lt;/code&gt;存储的内容是？&lt;/h1&gt;

&lt;p&gt;上面的讨论中，&lt;code&gt;map&lt;/code&gt;的&lt;code&gt;value_type&lt;/code&gt;是&lt;code&gt;std::function&amp;lt;void(*)&amp;gt;&lt;/code&gt;，所以我们不能直接将外部传入的回调设置进去，需要再包一层&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
int addCallback(T &amp;amp;&amp;amp; t) {
    last_idx++;
    callbacks[last_idx] = [t](void *data){
        auto ptr = static_cast&amp;lt;std::tuple&amp;lt;...&amp;gt; *&amp;gt;(data); // 模板参数怎么处理？
        std::apply(t, *ptr);
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们使用了&lt;code&gt;C++17&lt;/code&gt;中的&lt;a href=&#34;http://en.cppreference.com/w/cpp/utility/apply&#34;&gt;std::apply&lt;/a&gt;，其作用就是调用函数，参数是一个&lt;code&gt;tuple&lt;/code&gt;，有兴趣的可以从源码中看看&lt;code&gt;apply&lt;/code&gt;的实现，
这里就不详细介绍了。
问题是，&lt;code&gt;tuple&lt;/code&gt;的参数如何处理？我们没法从&lt;code&gt;data&lt;/code&gt;中得到类型心系，唯一的方法就是从&lt;code&gt;T&lt;/code&gt;中获取，那如何获取呢？&lt;/p&gt;

&lt;h1 id=&#34;callable对象调用参数萃取&#34;&gt;callable对象调用参数萃取&lt;/h1&gt;

&lt;p&gt;现在的主要问题是，如何从&lt;code&gt;std::function&lt;/code&gt;、&lt;code&gt;lambda&lt;/code&gt;、普通函数等类型中提取参数信息。对于普通函数和&lt;code&gt;std::function&lt;/code&gt;我们可以通过特化来做&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
struct CallbackTypeHelper;

template&amp;lt;typename RET, typename ... ARGS&amp;gt;
struct CallbackTypeHelper&amp;lt;RET(*)(ARGS...)&amp;gt; {
    typedef std::tuple&amp;lt;ARGS...&amp;gt; typle_type;
}

template&amp;lt;typename RET, typename ... ARGS&amp;gt;
struct CallbackTypeHelper&amp;lt;std::function&amp;lt;RET(ARGS...)&amp;gt;&amp;gt; {
    typedef std::tuple&amp;lt;ARGS...&amp;gt; typle_type;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于&lt;code&gt;lambda&lt;/code&gt;该如何处理呢？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lambda&lt;/code&gt;作为&lt;code&gt;C++11&lt;/code&gt;中新引进的特性，其作用是实现一个匿名函数，由于捕获组的存在，其不能仅仅实现成一个&lt;code&gt;C Function&lt;/code&gt;。为了实现这个目的，编译器会生成一个匿名类，各个捕获参数即为成员
变量，为了实现可被调用，其重载了&lt;code&gt;operator()&lt;/code&gt;。根据这个思路，我们找到了获取参数的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
struct CallbackFunctorHelper;

template&amp;lt;typename RET, typename C, typename ... ARGS&amp;gt;
struct CallbackFunctorHelper&amp;lt;RET(C::*)(ARGS...) const&amp;gt; {
  typedef std::tuple&amp;lt;ARGS...&amp;gt; tuple_type;
};

template&amp;lt;typename RET, typename C, typename ... ARGS&amp;gt;
struct CallbackFunctorHelper&amp;lt;RET(C::*)(ARGS...)&amp;gt; {
  typedef std::tuple&amp;lt;ARGS...&amp;gt; tuple_type;
};

template &amp;lt;typename T, typename Enabled=void&amp;gt;
struct CallbackTypeHelper {
  typedef typename CallbackFunctorHelper&amp;lt;decltype(&amp;amp;std::decay&amp;lt;T&amp;gt;::type::operator())&amp;gt;::tuple_type tuple_type;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意由于参数有可能是引用，所有这里需要&lt;a href=&#34;http://en.cppreference.com/w/cpp/types/decay&#34;&gt;decay&lt;/a&gt;来处理这些引用。同时由于&lt;code&gt;lambda&lt;/code&gt;的&lt;code&gt;mutable&lt;/code&gt;属性的存在，所以&lt;code&gt;CallbackFunctorHelper&lt;/code&gt;
需要&lt;code&gt;const&lt;/code&gt;和&lt;code&gt;non-const&lt;/code&gt;的特化。&lt;/p&gt;

&lt;p&gt;最后，由于这只是演示性质的代码，有些逻辑如成员函数等并没有考虑进去，除此之外，可以使用&lt;code&gt;enable_if&lt;/code&gt;做个单独的特化，而不需要在默认函数上写&lt;code&gt;functor&lt;/code&gt;的实现等。在实际
应用中可以修改得更加全面和优雅。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lua与C交互中的死循环检测</title>
      <link>http://sysfork.com/post/2017/lua-c-detect-inifinite-loop/</link>
      <pubDate>Fri, 21 Apr 2017 17:37:30 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-c-detect-inifinite-loop/</guid>
      <description>

&lt;p&gt;现在很多游戏引擎都是&lt;code&gt;C++&lt;/code&gt; + &lt;code&gt;lua&lt;/code&gt;的结构，一旦某个服务器开发人员大意写出死循环代码，很容易导致服务无响应，影响服务器稳定。所以引擎中最好能提供一个死循环的检测机制，一旦出现死循环则执行一些行为打断当前流程。&lt;/p&gt;

&lt;p&gt;死循环的检测是一个&lt;a href=&#34;https://en.wikipedia.org/wiki/Halting_problem&#34;&gt;停机问题&lt;/a&gt;。我们无法判断到底是任务执行时间过长，还是进入了真正的死循环，好在这对我们的服务来说区别并不重要。所以一个简单的判断条件是，执行时间是否超过了预定的阈值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C++&lt;/code&gt;中集成&lt;code&gt;lua&lt;/code&gt;，调用到游戏逻辑时，一般通过&lt;a href=&#34;http://pgl.yoyo.org/luai/i/lua_pcall&#34;&gt;pcall&lt;/a&gt;，但是一旦调用了&lt;code&gt;pcall&lt;/code&gt;，代码的执行路径便进入了&lt;code&gt;lua&lt;/code&gt;的世界，除非通过信号机制才能在当前线程中中断，实现执行其他分支的目的。除此之外，&lt;code&gt;lua&lt;/code&gt;还提供了&lt;code&gt;debug.sethook&lt;/code&gt;函数，可以在执行正常逻辑中触发&lt;code&gt;hook&lt;/code&gt;，实现监测超时的功能。所以我们有以下两种方案：&lt;/p&gt;

&lt;h1 id=&#34;使用-debug-sethook-来实现&#34;&gt;使用&lt;code&gt;debug.sethook()&lt;/code&gt;来实现&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;debug.sethook ([thread,] hook, mask [, count])
Sets the given function as a hook. The string mask and the number count describe when the hook will be called. The string mask may have the following characters, with the given meaning:&lt;/p&gt;

&lt;p&gt;&amp;ldquo;c&amp;rdquo;: the hook is called every time Lua calls a function;
&amp;ldquo;r&amp;rdquo;: the hook is called every time Lua returns from a function;
&amp;ldquo;l&amp;rdquo;: the hook is called every time Lua enters a new line of code.
With a count different from zero, the hook is called after every count instructions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以我们只要在执行&lt;code&gt;pcall&lt;/code&gt;之前设定类似如下的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;debug.sethook(function()error(&amp;quot;timeout&amp;quot;)end, &amp;quot;c&amp;quot;, 10000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理论上只要代码指令数超过10000条就能触发&lt;code&gt;error&lt;/code&gt;。好像挺完美的。&lt;/p&gt;

&lt;p&gt;But，在&lt;code&gt;luajit&lt;/code&gt;下这条不一定成立，因为执行的逻辑被&lt;code&gt;jit&lt;/code&gt;编译了，而在这种情况下，&lt;code&gt;hook&lt;/code&gt;是不会触发的&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If your program is running in a tight loop and never falls back to the interpreter, the debug hook never runs and can&amp;rsquo;t throw the &amp;ldquo;interrupted!&amp;rdquo; error.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但是还有一个未公开的编译选项&lt;code&gt;LUAJIT_ENABLE_CHECKHOOK&lt;/code&gt;，在&lt;code&gt;lj_record.c&lt;/code&gt;文件的最后面，上面写道&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Regularly check for instruction/line hooks from compiled code and
exit to the interpreter if the hooks are set.&lt;/p&gt;

&lt;p&gt;This is a compile-time option and disabled by default, since the
hook checks may be quite expensive in tight loops.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看似可以，但是注意，如果&lt;code&gt;hook&lt;/code&gt;被设置了，则执行的代价是比较昂贵的。对于游戏而言，大部分的时间都在&lt;code&gt;lua&lt;/code&gt;层，而为了监测死循环，几乎
要在所有的lua执行过程中设置&lt;code&gt;hook&lt;/code&gt;，这是不太容易接受的。好在下面的注释提到了&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can set the instruction hook via lua_sethook() with a count of 1
from a signal handler or another native thread. Please have a look
at the first few functions in luajit.c for an example (Ctrl-C handler).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;嗯，看样子只能使用第二种方案了。&lt;/p&gt;

&lt;h1 id=&#34;使用信号来实现&#34;&gt;使用信号来实现&lt;/h1&gt;

&lt;p&gt;在lua的命令行程序中我们可以通过&lt;code&gt;Ctrl-C&lt;/code&gt;中断正在执行的程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;  for i=1,10000000 do sum = sum + i end
^Cinterrupted!
stack traceback:
        stdin:1: in main chunk
        [C]: in ?

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仔细看&lt;code&gt;lua.c&lt;/code&gt;文件，可以看到以下代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;static void lstop (lua_State *L, lua_Debug *ar) {
  (void)ar;  /* unused arg. */
  lua_sethook(L, NULL, 0, 0);
  luaL_error(L, &amp;quot;interrupted!&amp;quot;);
}


static void laction (int i) {
  signal(i, SIG_DFL); /* if another SIGINT happens before lstop,
                              terminate process (default action) */
  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
}

// ....
//in docall
signal(SIGINT, laction);
status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
signal(SIGINT, SIG_DFL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嗯，在执行&lt;code&gt;pcall&lt;/code&gt;之前设置了信号处理函数，捕捉&lt;code&gt;Ctrl-C&lt;/code&gt;的信号，一旦发生，则立马调用&lt;code&gt;lua_sethook&lt;/code&gt;函数，指定在执行下一行代码时调用&lt;code&gt;lstop&lt;/code&gt;，而在&lt;code&gt;lstop&lt;/code&gt;中就直接抛出&lt;code&gt;error&lt;/code&gt;了。所以问题是 &lt;strong&gt;&lt;code&gt;lua_sethook&lt;/code&gt;是可以在信号处理函数中调用的&lt;/strong&gt;？&lt;/p&gt;

&lt;p&gt;答案：是&lt;/p&gt;

&lt;p&gt;从源码中可以看到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* This function can be called asynchronously (e.g. during a signal). */
LUA_API int lua_sethook(lua_State *L, lua_Hook func, int mask, int count)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，从&lt;code&gt;luajit&lt;/code&gt;的源码注释来看，不仅仅在信号处理函数中，在其他线程中也能被调用
&amp;gt; from a signal handler or another native thread.&lt;/p&gt;

&lt;p&gt;所以，这种方案是可行的。因此，对于单线程程序而言，可以通过设置&lt;code&gt;alarm&lt;/code&gt;来实现超时设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alarm(10);// trigger after 10s
signal(SIGALRM, laction);
status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
alarm(0)
signal(SIGALRM, SIG_DFL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而对于多线程程序，可以直接启一个定时器来来&lt;code&gt;check&lt;/code&gt;，而不用使用很恶心的信号。&lt;/p&gt;

&lt;p&gt;值得一提的是，使用这种方式触发超时&lt;code&gt;error&lt;/code&gt;可以很轻易地在&lt;code&gt;pcall&lt;/code&gt;中捕获，从而而已实现堆栈的打印等功能，方便查找和定位问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>浅谈C&#43;&#43;中的地址对齐</title>
      <link>http://sysfork.com/post/2016/about-cpp-alignment/</link>
      <pubDate>Sun, 25 Sep 2016 09:13:27 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2016/about-cpp-alignment/</guid>
      <description>

&lt;h1 id=&#34;动机&#34;&gt;动机&lt;/h1&gt;

&lt;p&gt;最近在整理C++11中的新增特性，其中有一个&lt;a href=&#34;http://en.cppreference.com/w/cpp/language/alignas&#34;&gt;alignas&lt;/a&gt;关键字。在学习这个的时候顺便研究了
下C/C++中的字节对齐问题，发现有很多可以探索的地方。&lt;/p&gt;

&lt;h1 id=&#34;什么是地址对齐&#34;&gt;什么是地址对齐&lt;/h1&gt;

&lt;p&gt;参考维基百科的解释：&lt;a href=&#34;https://en.wikipedia.org/wiki/Data_structure_alignment&#34;&gt;Data_structure_alignment&lt;/a&gt;。所谓地址对齐，即某个地址A满足是n的倍数，其中n是2的幂次方(如1、2、4、8等等)。如果用二进制表示的话，那么
A的末尾至少有&lt;code&gt;log&lt;sub&gt;2&lt;/sub&gt;n&lt;/code&gt;个0(废话)。当我们说到某个变量是n字节对齐的时候，其意思是指这个变量的地址是对齐的。&lt;/p&gt;

&lt;h1 id=&#34;地址对齐的意义&#34;&gt;地址对齐的意义&lt;/h1&gt;

&lt;p&gt;从我们编写的程序来看，CPU好像可以访问内存中的任意位置；但是实际上CPU往往是按照块为基本单位访问内存的。如果某个变量的起始地址位于某个块的的起始处，则只需较少的次数便能完成读取。
比如在某个CPU中，其每次取内存的大小为8字节，对于一个8字节的long类型变量，如果该变量的地址是8的倍数，那么每次load这个long变量只需要一次操作。如果不是8的倍数则需要两次，影响了效率。
更多的数据测评参考&lt;a href=&#34;http://www.ibm.com/developerworks/library/pa-dalign/&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;自然对齐&#34;&gt;自然对齐&lt;/h1&gt;

&lt;p&gt;为了保证运行效率，编译器在生成可执行程序的时候会对我们使用的变量自动对齐。这个值往往就是变量类型的size或是能被size整除。如char的自然对齐地址为1，而int则是4或8。但是，这也是有上限的。在&lt;code&gt;C++11&lt;/code&gt;中，
上限为&lt;code&gt;std::max_align_t&lt;/code&gt;的对齐值，在大多数平台上，这个类型都被定义为&lt;code&gt;long double&lt;/code&gt;，因为这往往也是最大的标量。当我们定义数组时，如 &lt;code&gt;TYPE f[10]&lt;/code&gt;，其中第N个元素的地址为&lt;code&gt;f + sizeof(TYPE) * N&lt;/code&gt;。
如果&lt;code&gt;TYPE&lt;/code&gt;的对齐值能被&lt;code&gt;sizeof(TYPE)&lt;/code&gt;整除的话，则能保证只要数组开始地址时对齐的，那么所有元素都是对齐的。&lt;/p&gt;

&lt;h1 id=&#34;变量的内存对齐控制&#34;&gt;变量的内存对齐控制&lt;/h1&gt;

&lt;p&gt;GCC有一个自己的扩展来控制变量的对齐内存，&lt;code&gt;__attribute__((aligned()))&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int __attribute__((aligned(16))) i;                          //(1)
int j __attribute__((aligned(16)));                          //(2)
struct S { short f[3]; } __attribute__ ((aligned (8)));      //(3)
typedef int more_aligned_int __attribute__ ((aligned (8)));  //(4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1)和(2)声明了两个变量，指定这两个变量的对齐大小为16；(3)和(4)则作用与类型，使得S和&lt;code&gt;more_aligned_int&lt;/code&gt;类型的变量对齐都是8。
这个对齐的大小可以为任意2的幂次数，但是有最大上限，在我的x86_64的ubuntu上这个值是2&lt;sup&gt;28&lt;/sup&gt;。按照GCC&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc-3.3/gcc/Type-Attributes.html&#34;&gt;官方文档&lt;/a&gt;中的解释，
这个attribute并不能保证变量的对齐一定是指定的大小，而是提供了一个最小值。但是实测的时候，对于标量，其提供的值就是最后对齐的值。如int的自然对齐为4，当我们使用&lt;code&gt;__attribute__&lt;/code&gt;指定时，无论时&lt;code&gt;1&lt;/code&gt;或&lt;code&gt;8&lt;/code&gt;
都能正常工作。但是对于S，指定其对齐大小为1并没有生效，其依然是2，其挑选了一个指定值与自然对齐中较大的那个。&lt;/p&gt;

&lt;p&gt;C++引入了新的&lt;a href=&#34;http://en.cppreference.com/w/cpp/language/alignas&#34;&gt;alignas&lt;/a&gt;关键字，其并不是直接指定变量或类型的对齐值，而是定义了一个最严格的需求。由于对齐值是越大越严格的（8字节对其的一定是4字节对齐），
因此其定义的是一个上限。在GCC中，我在测试的时候没有发现与&lt;code&gt;__attribute__((aligned()))&lt;/code&gt;的区别，同样可以设置int的对齐值为1，和说好的不一样啊（摔）！但是在clang中就符合要求了，会提示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alignment.cpp:15:3: error: requested alignment is less than minimum alignment of 4 for type &#39;int&#39;
  alignas(1) int b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以大家在使用的时候，就不要随便将一个变量设置成小于自然对齐的值，否则容易导致跨平台问题。&lt;/p&gt;

&lt;h1 id=&#34;struct&#34;&gt;struct&lt;/h1&gt;

&lt;p&gt;struct不是一个标量，并且是一个自定义数据类型。这里有ESR的&lt;a href=&#34;http://www.catb.org/esr/structure-packing/&#34;&gt;一篇文章&lt;/a&gt;，本文简单的总结一起他的意思。
struct中的元素并不是紧致排列的，为了保证每个成员都是对齐的，编译器会在struct中的元素之间插入pad，例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct foo1 {
    char *p;
    char c;
    long x;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设在64bit的机器上，那么foo1的对齐值为8，这个值其实就是所有成员变量中对齐值最大的那个（一旦满足最大的那个需求，其他就都能满足了），就是&lt;code&gt;char *p&lt;/code&gt;。为了保证所有成员都是对齐的，编译器会
调整内存布局，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct foo1 {
    char *p;     /* 8 bytes */
    char c;      /* 1 byte  */
    char pad[7]; /* 7 bytes */
    long x;      /* 8 bytes */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于&lt;code&gt;long&lt;/code&gt;是8字节对齐的，而&lt;code&gt;char&lt;/code&gt;是1字节对齐，所以插入了7个char以保证都是对齐的。
在上面我们说到，数组中所有元素都是对齐的，对于struct也是如此。比如下面的例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct foo4 {
    short s;     /* 2 bytes */
    char c;      /* 1 byte */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;foo4的对齐值为2，但是其size为3，这样放到数组中不是对齐的。所以，为了达到需求，编译器会在struct的末尾插入空白：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct foo4 {
    short s;     /* 2 bytes */
    char c;      /* 1 byte */
    char pad[1];
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样其size为4，就能满足需求了。以上的要求对于嵌套的struct也是需要满足的。&lt;/p&gt;

&lt;p&gt;然而我们在编码时往往需要编译器保证struct成员时紧密相连的，这样可以精确控制内存的layout。现代编译器一般都提供&lt;code&gt;#pragma pack&lt;/code&gt;语句来完成这一目的。
一旦定义了pack，那么后面所有的struct都要满足这个其需求。其保证成员变量的对齐值取自然对齐大小和pack中的较小值。所以对于以下示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#pragma pack(1)
struct S1 {
    char a;
    long b;
};
#pragma pack()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有pack，编译器会在其中插入7个字节的pad，最后的size为16字节。有了pack之后，long b的对齐值成了1，那么就是紧凑排列了， size为9字节。如果们将1改成2呢？
此时long b的对齐值为2，那么插入一个pad，size为10字节。如果pack的值为16呢？由于其超过了long的align值8，那么保持long的自然对齐就好了，最终的值size为16。&lt;/p&gt;

&lt;p&gt;顺便说一句，pack仅仅对struct和class有效，一旦设置后，对于后面所有的struct/class都生效，除非使用空的&lt;code&gt;pack()&lt;/code&gt;取消，所以我们在使用的时候往往在struct的定义
前后都写上预处理语句。除此还有&lt;code&gt;push&lt;/code&gt;和&lt;code&gt;pop&lt;/code&gt;，其作用与&lt;code&gt;pack&lt;/code&gt;相同，只是保存了历史纪录：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#pragma pack(push, 1)
struct A {
  char c;
  double lf;
#pragma pack(push, 2)
  struct C {
    char e;
    double f;
    char s;
  } e;
#pragma pack(pop)
};
#pragma pack(pop)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其size为&lt;code&gt;21 = 1(char) + 8(double) + 1(pad) + 1(char) + 1(pad) + 8(double) + 1(char) + 1(pad)&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;

&lt;p&gt;align在实际开发中应用得并不多，但是当我们了解其原理，就能更好地优化struct或类的结构，减少无谓的pad，从达到减少内存占用的目的。除此只玩，当编写某些需要严格控制内存
layout的时候，pack能让我们更好地控制产出的代码。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>理解Linux下动态链接库延迟绑定</title>
      <link>http://sysfork.com/post/2016/linux-dynamic-lib-lazy-load/</link>
      <pubDate>Wed, 07 Sep 2016 22:08:20 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2016/linux-dynamic-lib-lazy-load/</guid>
      <description>&lt;script src=&#34;//cdn.bootcss.com/highlight.js/9.6.0/languages/x86asm.min.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;在编译动态链接库时，为了保证能被正常使用，一般我们会加上-fPIC参数。在使用的动态链接库中的函数时，Linux使用了一种
叫延迟绑定的技术实现运行时的symbol relocation。其中的关键就是GOT(Global Offset Table)和PLT(Procedure linkage Table)。下面就
这一技术的实现简单解释一下。&lt;/p&gt;

&lt;p&gt;首先写一个很简单的需要动态链接的程序，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//dl_test.c
#include &amp;lt;stdio.h&amp;gt;
int main(int argc, const char *argv[])
{
    puts(&amp;quot;1234&amp;quot;);
    puts(&amp;quot;1234&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用&lt;code&gt;gcc&lt;/code&gt;编译并链接: &lt;code&gt;gcc -g dl_test.c -o dl_test.c&lt;/code&gt;。先别急着运行这个程序，我们使用&lt;code&gt;objdump&lt;/code&gt;反编译一下看看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ objdump -S dl_test
......
0000000000400506 &amp;lt;main&amp;gt;:
#include &amp;lt;stdio.h&amp;gt;
int main(int argc, const char *argv[])
{
  400506:       55                      push   %rbp
  400507:       48 89 e5                mov    %rsp,%rbp
  40050a:       48 83 ec 10             sub    $0x10,%rsp
  40050e:       89 7d fc                mov    %edi,-0x4(%rbp)
  400511:       48 89 75 f0             mov    %rsi,-0x10(%rbp)
    puts(&amp;quot;1234&amp;quot;);
  400515:       bf b4 05 40 00          mov    $0x4005b4,%edi
  40051a:       e8 c1 fe ff ff          callq  4003e0 &amp;lt;puts@plt&amp;gt;
    puts(&amp;quot;1234&amp;quot;);
  40051f:       bf b4 05 40 00          mov    $0x4005b4,%edi
  400524:       e8 b7 fe ff ff          callq  4003e0 &amp;lt;puts@plt&amp;gt;
    return 0;
  400529:       b8 00 00 00 00          mov    $0x0,%eax
}
  40052e:       c9                      leaveq
  40052f:       c3                      retq
......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，在&lt;code&gt;40051a&lt;/code&gt;和&lt;code&gt;400524&lt;/code&gt;两处都调用了我们的&lt;code&gt;puts&lt;/code&gt;函数。但是看后面的注解，&lt;code&gt;&amp;lt;puts@plt&amp;gt;&lt;/code&gt;表示这并不是&lt;code&gt;puts&lt;/code&gt;的地址，而是另有目的。
我们使用&lt;code&gt;gdb&lt;/code&gt;来跟踪一下执行过程：&lt;code&gt;gdb dl_test&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) l
1	#include &amp;lt;stdio.h&amp;gt;
2	int main(int argc, const char *argv[])
3	{
4	    puts(&amp;quot;1234&amp;quot;);
5	    puts(&amp;quot;1234&amp;quot;);
6	    return 0;
7	}
(gdb) b 4
Breakpoint 1 at 0x400515: file dl_test.c, line 4.
(gdb) r
Starting program: /home/zqc/workspace/cpptest/dl_test

Breakpoint 1, main (argc=1, argv=0x7fffffffeb98) at dl_test.c:4
4	    puts(&amp;quot;1234&amp;quot;);
(gdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里设置了一下断点到第一个&lt;code&gt;puts&lt;/code&gt;的调用出，使用&lt;code&gt;layout asm&lt;/code&gt;切换成汇编模式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34;&gt;(gdb) layout asm
   ┌────────────────────────────────────────────────────────────────────────────────────────────┐
B+&amp;gt;│0x400515 &amp;lt;main+15&amp;gt;              mov    $0x4005b4,%edi                                       │
   │0x40051a &amp;lt;main+20&amp;gt;              callq  0x4003e0 &amp;lt;puts@plt&amp;gt;                                  │
   │0x40051f &amp;lt;main+25&amp;gt;              mov    $0x4005b4,%edi                                       │
   │0x400524 &amp;lt;main+30&amp;gt;              callq  0x4003e0 &amp;lt;puts@plt&amp;gt;                                  │
   │0x400529 &amp;lt;main+35&amp;gt;              mov    $0x0,%eax                                            │
   │0x40052e &amp;lt;main+40&amp;gt;              leaveq                                                      │
   │0x40052f &amp;lt;main+41&amp;gt;              retq                                                        │
   │0x400530 &amp;lt;__libc_csu_init&amp;gt;      push   %r15                                                 │
   │0x400532 &amp;lt;__libc_csu_init+2&amp;gt;    mov    %edi,%r15d                                           │
   │0x400535 &amp;lt;__libc_csu_init+5&amp;gt;    push   %r14                                                 │
   │0x400537 &amp;lt;__libc_csu_init+7&amp;gt;    mov    %rsi,%r14                                            │
   │0x40053a &amp;lt;__libc_csu_init+10&amp;gt;   push   %r13                                                 │
   │0x40053c &amp;lt;__libc_csu_init+12&amp;gt;   mov    %rdx,%r13                                            │
   │0x40053f &amp;lt;__libc_csu_init+15&amp;gt;   push   %r12                                                 │
   │0x400541 &amp;lt;__libc_csu_init+17&amp;gt;   lea    0x2001a0(%rip),%r12        # 0x6006e8                │
   │0x400548 &amp;lt;__libc_csu_init+24&amp;gt;   push   %rbp                                                 │
   │0x400549 &amp;lt;__libc_csu_init+25&amp;gt;   lea    0x2001a0(%rip),%rbp        # 0x6006f0                │
   │0x400550 &amp;lt;__libc_csu_init+32&amp;gt;   push   %rbx                                                 │
   │0x400551 &amp;lt;__libc_csu_init+33&amp;gt;   sub    %r12,%rbp                                            │
   └────────────────────────────────────────────────────────────────────────────────────────────┘
child process 8855 In: main                                              Line: 4    PC: 0x400515
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;stepi&lt;/code&gt;或者简写为&lt;code&gt;si&lt;/code&gt;执行下一条汇编指令。我们一直跟踪到&lt;code&gt;call&lt;/code&gt;指令中去：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34;&gt;   ┌────────────────────────────────────────────────────────────────────────────────────────────────────────┐
  &amp;gt;│0x4003e0 &amp;lt;puts@plt&amp;gt;                     jmpq   *0x20050a(%rip)   # 0x6008f0 &amp;lt;puts@got.plt&amp;gt;              │
   │0x4003e6 &amp;lt;puts@plt+6&amp;gt;                   pushq  $0x0                                                     │
   │0x4003eb &amp;lt;puts@plt+11&amp;gt;                  jmpq   0x4003d0                                                 │
   │0x4003f0 &amp;lt;__libc_start_main@plt&amp;gt;        jmpq   *0x200502(%rip)   # 0x6008f8 &amp;lt;__libc_start_main@got.plt&amp;gt; │
   │0x4003f6 &amp;lt;__libc_start_main@plt+6&amp;gt;      pushq  $0x1                                                     │
   │0x4003fb &amp;lt;__libc_start_main@plt+11&amp;gt;     jmpq   0x4003d0                                                 │
   │0x400400 &amp;lt;__gmon_start__@plt&amp;gt;           jmpq   *0x2004fa(%rip)   # 0x600900 &amp;lt;__gmon_start__@got.plt&amp;gt;    │
   │0x400406 &amp;lt;__gmon_start__@plt+6&amp;gt;         pushq  $0x2                                                     │
   │0x40040b &amp;lt;__gmon_start__@plt+11&amp;gt;        jmpq   0x4003d0                                                 │
   │0x400410 &amp;lt;_start&amp;gt;                       xor    %ebp,%ebp                                                │
   │0x400412 &amp;lt;_start+2&amp;gt;                     mov    %rdx,%r9                                                 │
   │0x400415 &amp;lt;_start+5&amp;gt;                     pop    %rsi                                                     │
   │0x400416 &amp;lt;_start+6&amp;gt;                     mov    %rsp,%rdx                                                │
   │0x400419 &amp;lt;_start+9&amp;gt;                     and    $0xfffffffffffffff0,%rsp                                 │
   │0x40041d &amp;lt;_start+13&amp;gt;                    push   %rax                                                     │
   │0x40041e &amp;lt;_start+14&amp;gt;                    push   %rsp                                                     │
   │0x40041f &amp;lt;_start+15&amp;gt;                    mov    $0x4005a0,%r8                                            │
   │0x400426 &amp;lt;_start+22&amp;gt;                    mov    $0x400530,%rcx                                           │
   │0x40042d &amp;lt;_start+29&amp;gt;                    mov    $0x400506,%rdi                                           │
   └────────────────────────────────────────────────────────────────────────────────────────────────────────┘
child process 9211 In: puts@plt                                                      Line: ??   PC: 0x4003e0
0x00000000004003e0 in puts@plt ()
(gdb)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;0x4003e0&lt;/code&gt;是刚刚跳转的地址，也就是&lt;code&gt;&amp;lt;puts@plt&amp;gt;&lt;/code&gt;，从这个名字中我们可以看出，这个地址是属于&lt;code&gt;plt&lt;/code&gt;的。先说一下&lt;code&gt;plt&lt;/code&gt;的作用，&lt;code&gt;plt&lt;/code&gt;的全称是
过程链接表，意思就是当调用一个动态链接库中的函数时，其访问的是其实是&lt;code&gt;plt&lt;/code&gt;中的一个过程，这个过程会完成真正的调用。我们分别看下属于&lt;code&gt;puts&lt;/code&gt;中
&lt;code&gt;plt&lt;/code&gt;的项目&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34;&gt;  &amp;gt;│0x4003e0 &amp;lt;puts@plt&amp;gt;                     jmpq   *0x20050a(%rip)        # 0x6008f0 &amp;lt;puts@got.plt&amp;gt;     │
   │0x4003e6 &amp;lt;puts@plt+6&amp;gt;                   pushq  $0x0                                                 │
   │0x4003eb &amp;lt;puts@plt+11&amp;gt;                  jmpq   0x4003d0                                             │
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;0x20050a(%rip)&lt;/code&gt; 即 &lt;code&gt;got&lt;/code&gt;中的地址，在初始情况下，该选项为&lt;code&gt;plt&lt;/code&gt;项中的下一条指令，所以执行&lt;code&gt;jmpq   *0x20050a(%rip)&lt;/code&gt; 直接会进入到
下一条指令&lt;code&gt;pushq&lt;/code&gt;， &lt;code&gt;pushq $0x0&lt;/code&gt;的目的是把当前在符号(&lt;code&gt;puts&lt;/code&gt;)在&lt;code&gt;.rela.plt&lt;/code&gt;中的index。我们可以使用&lt;code&gt;readelf&lt;/code&gt;指令看下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ readelf -r dl_test

Relocation section &#39;.rela.dyn&#39; at offset 0x348 contains 1 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
0000006008d0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0

Relocation section &#39;.rela.plt&#39; at offset 0x360 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
0000006008f0  000100000007 R_X86_64_JUMP_SLO 0000000000000000 puts + 0
0000006008f8  000200000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main + 0
000000600900  000300000007 R_X86_64_JUMP_SLO 0000000000000000 __gmon_start__ + 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，&lt;code&gt;puts&lt;/code&gt;的index为0，第一项，所以这里push的是&lt;code&gt;$0x0&lt;/code&gt;。同理，下面的&lt;code&gt;__libc_start_main&lt;/code&gt;就是&lt;code&gt;$0x1&lt;/code&gt;。 下一行语句是&lt;code&gt;jmpq   0x4003d0&lt;/code&gt;，这个地址是
固定的，所有的&lt;code&gt;plt&lt;/code&gt;入口最后一句语句都是这个，这是个通用的过程。
继续&lt;code&gt;stepi&lt;/code&gt;到jump的位置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34;&gt;  &amp;gt;│0x4003d0                                pushq  0x20050a(%rip)        # 0x6008e0                     │
   │0x4003d6                                jmpq   *0x20050c(%rip)        # 0x6008e8                    │
   │0x4003dc                                nopl   0x0(%rax)                                            │
   │0x4003e0 &amp;lt;puts@plt&amp;gt;                     jmpq   *0x20050a(%rip)        # 0x6008f0 &amp;lt;puts@got.plt&amp;gt;     │
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现这个地址就是在&lt;code&gt;puts@plt&lt;/code&gt;的上面，并且也是为了保证和普通&lt;code&gt;plt&lt;/code&gt;入口项目大小(&lt;code&gt;0x10&lt;/code&gt;)，其末尾还用0补齐了(&lt;code&gt;nopl   0x0(%rax)&lt;/code&gt;)。我们重点看一下前面两句。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pushq  0x20050a(%rip)        # 0x6008e0&lt;/code&gt;，这里push了一个地址，这个地址是干嘛的？我们使用&lt;code&gt;gdb&lt;/code&gt;看一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) x /16x 0x6008e0
0x6008e0:       0xf7ffe1a8      0x00007fff      0xf7df02b0      0x00007fff
0x6008f0 &amp;lt;puts@got.plt&amp;gt;:        0x004003e6      0x00000000      0xf7a52a50      0x00007fff
0x600900 &amp;lt;__gmon_start__@got.plt&amp;gt;:      0x00400406      0x00000000      0x00000000      0x00000000
0x600910:       0x00000000      0x00000000      0x00000000      0x00000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个地址其实就是&lt;code&gt;got&lt;/code&gt;中的一项，并且在所有普通符号&lt;code&gt;got&lt;/code&gt;的前面。那么目前栈上的元素是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;| 0x00007ffff7ffe1a8 |
| 0x0                |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来到是&lt;code&gt;jmpq   *0x20050c(%rip)&lt;/code&gt; 这个地址也是在plt上，紧挨着上面push的地址，值为&lt;code&gt;0x00007ffff7df02b0&lt;/code&gt;，我们可以继续&lt;code&gt;stepi&lt;/code&gt;进去，也可以
通过&lt;code&gt;disassemble 0x00007ffff7df02b0&lt;/code&gt;查看。或者，使用&lt;code&gt;info symbol 0x00007ffff7df02b0&lt;/code&gt;直接查看。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) info symbol 0x00007ffff7df02b0
_dl_runtime_resolve in section .text of /lib64/ld-linux-x86-64.so.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这里可以看出，这是属于&lt;code&gt;ld-linux-x86-64.so.2&lt;/code&gt;里面的一个方法。这个so属于&lt;code&gt;glibc&lt;/code&gt;的一部分，我们可以下载&lt;a href=&#34;ftp://ftp.gnu.org/gnu/glibc&#34;&gt;glibc&lt;/a&gt;来查看。最终我们找到了这个符号定义文件，
其位置在&lt;code&gt;sysdeps/x86_64/dl-trampoline.S&lt;/code&gt;，内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34;&gt; 28     .globl _dl_runtime_resolve
 29     .type _dl_runtime_resolve, @function
 30     .align 16
 31     cfi_startproc
 32 _dl_runtime_resolve:
 33     cfi_adjust_cfa_offset(16) # Incorporate PLT
 34     subq $56,%rsp
 35     cfi_adjust_cfa_offset(56)
 36     movq %rax,(%rsp)    # Preserve registers otherwise clobbered.
 37     movq %rcx, 8(%rsp)
 38     movq %rdx, 16(%rsp)
 39     movq %rsi, 24(%rsp)
 40     movq %rdi, 32(%rsp)
 41     movq %r8, 40(%rsp)
 42     movq %r9, 48(%rsp)
 43     movq 64(%rsp), %rsi # Copy args pushed by PLT in register.
 44     movq 56(%rsp), %rdi # %rdi: link_map, %rsi: reloc_index
 45     call _dl_fixup      # Call resolver.
 46     movq %rax, %r11     # Save return value
 47     movq 48(%rsp), %r9  # Get register content back.
 48     movq 40(%rsp), %r8
 49     movq 32(%rsp), %rdi
 50     movq 24(%rsp), %rsi
 51     movq 16(%rsp), %rdx
 52     movq 8(%rsp), %rcx
 53     movq (%rsp), %rax
 54     addq $72, %rsp      # Adjust stack(PLT did 2 pushes)
 55     cfi_adjust_cfa_offset(-72)
 56     jmp *%r11       # Jump to function address.
 57     cfi_endproc
 58     .size _dl_runtime_resolve, .-_dl_runtime_resolve
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从43行开始是我们的逻辑。43行取出了我们刚刚push的第一个参数，就是&lt;code&gt;$0x0&lt;/code&gt;，放到&lt;code&gt;%rsi&lt;/code&gt;中，然后是我们push的第二个参数，&lt;code&gt;0x00007ffff7ffe1a8&lt;/code&gt;到&lt;code&gt;%rsi&lt;/code&gt;中。
为什么是这两个寄存器呢？我们&lt;code&gt;man syscall&lt;/code&gt;一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       arch/ABI   arg1   arg2   arg3   arg4   arg5   arg6   arg7
       ──────────────────────────────────────────────────────────
       x86_64     rdi    rsi    rdx    r10    r8     r9     -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出linux下的函数传参方式， 那么&lt;code&gt;%rdi&lt;/code&gt;就是参数1，而&lt;code&gt;%rsi&lt;/code&gt;就是参数2了。接下来是&lt;code&gt;call _dl_fixup&lt;/code&gt;，这个函数返回值就是指向&lt;code&gt;puts&lt;/code&gt;存储地址位置的指针了，后面可以看到
代码中将这个指针保存到了&lt;code&gt;%r11&lt;/code&gt;，然后&lt;code&gt;jmp *%r11&lt;/code&gt;。完成了一次函数调用，下面我们来看看&lt;code&gt;_dl_fixup&lt;/code&gt;做了些什么。同样，这个函数也是&lt;code&gt;gblic&lt;/code&gt;中定义的，位置在&lt;code&gt;elf/dl-runtime.c&lt;/code&gt;中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;59 DL_FIXUP_VALUE_TYPE
60 __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE
61 _dl_fixup (
62 # ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS
63        ELF_MACHINE_RUNTIME_FIXUP_ARGS,
64 # endif
65        struct link_map *l, ElfW(Word) reloc_arg)
66 {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从函数原型我们可以看出，之前&lt;code&gt;push&lt;/code&gt;的两个参数分别是&lt;code&gt;link_map&lt;/code&gt;和&lt;code&gt;reloc_arg&lt;/code&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt; 67   const ElfW(Sym) *const symtab
 68     = (const void *) D_PTR (l, l_info[DT_SYMTAB]);
 69   const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);
 70 
 71   const PLTREL *const reloc
 72     = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);
 73   const ElfW(Sym) *sym = &amp;amp;symtab[ELFW(R_SYM) (reloc-&amp;gt;r_info)];
 74   void *const rel_addr = (void *)(l-&amp;gt;l_addr + reloc-&amp;gt;r_offset);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里做了一下转型，那么&lt;code&gt;symtab&lt;/code&gt;和&lt;code&gt;strtab&lt;/code&gt;分别是对于&lt;code&gt;section&lt;/code&gt;的地址，而&lt;code&gt;reloc_addr&lt;/code&gt;就是我们&lt;code&gt;got&lt;/code&gt;中的&lt;code&gt;puts@got.plt&lt;/code&gt;的地址。接下来就是符号解析过程了，
后面可能会有文章来解释这个过程。当找到目标地址后&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//elf/dl-runtime.c
148   return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);
//sysdeps/x86_64/dl-machine.h
205 static inline ElfW(Addr)
206 elf_machine_fixup_plt (struct link_map *map, lookup_t t,
207                const ElfW(Rela) *reloc,
208                ElfW(Addr) *reloc_addr, ElfW(Addr) value)
209 {
210   return *reloc_addr = value;
211 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的&lt;code&gt;value&lt;/code&gt;就是目标函数地址，也就是&lt;code&gt;puts&lt;/code&gt;的真正地址，代码中设置其到了&lt;code&gt;puts@got.plt&lt;/code&gt;的位置并返回。&lt;/p&gt;

&lt;p&gt;以上就是第一次调用&lt;code&gt;puts&lt;/code&gt;的过程了，当第二次调用&lt;code&gt;puts&lt;/code&gt;时，由于&lt;code&gt;puts@got.plt&lt;/code&gt;已经有了正确的地址，所以&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34;&gt;  &amp;gt;│0x4003e0 &amp;lt;puts@plt&amp;gt;                     jmpq   *0x20050a(%rip)        # 0x6008f0 &amp;lt;puts@got.plt&amp;gt;    │
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就直接跳转到正确的&lt;code&gt;puts&lt;/code&gt;位置，完成了函数调用。所以，&lt;code&gt;linux&lt;/code&gt;下的这种懒绑定方式实现了在不使用符号的时候不解析，而需要使用的时候
只在第一步开销比较大，后面的调用开销无非多了一次跳转和一次寻址操作而已。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo 集成 Mathjax和graphviz</title>
      <link>http://sysfork.com/post/2016/integrate-mathjax-viz-with-hugo/</link>
      <pubDate>Fri, 02 Sep 2016 09:41:17 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2016/integrate-mathjax-viz-with-hugo/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;hugo&lt;/a&gt;是一个比&lt;a href=&#34;https://hexo.io&#34;&gt;hexo&lt;/a&gt;更简单易用的静态页面生成工具，其只有一个可执行文件，部署环境简单，本博客就是基于hugo构建的。&lt;/p&gt;

&lt;p&gt;我们在写博客的时候经常应用到公式和图表，这分别可以使用&lt;a href=&#34;https://www.mathjax.org/&#34;&gt;mathjax&lt;/a&gt;和&lt;a href=&#34;https://github.com/mdaines/viz.js&#34;&gt;viz.js&lt;/a&gt;实现。hugo并没有提供
内置的支持，所以需要我们自己写相关的支持。&lt;/p&gt;

&lt;p&gt;由于并不是所有的文章都需要mathjax和viz.js，所以需要按需使用，这个可以在每个post的前言上定义&lt;code&gt;plugins&lt;/code&gt;变量，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;title = &amp;quot;Hugo 集成 Mathjax和graphviz&amp;quot;
plugins = [&amp;quot;mathjax&amp;quot;, &amp;quot;viz&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再&lt;code&gt;partials&lt;/code&gt;目录下添加一个&lt;code&gt;post_plugins.html&lt;/code&gt;，并在&lt;code&gt;post/single.html&lt;/code&gt;引入这个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  {{ partial &amp;quot;post_plugins.html&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;post_plugins.html&lt;/code&gt;文件内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ if isset .Params &amp;quot;plugins&amp;quot; }}
    {{ range .Params.plugins }}
        {{ $path := . | printf &amp;quot;post_plugins/%s.html&amp;quot;}}
        {{ partial $path }}
    {{ end }}
{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;逻辑即通过便利&lt;code&gt;plugins&lt;/code&gt;参数内容，然后引入对应的html文件。在目前的这个例子中，我们使用了mathjax和viz。其中&lt;code&gt;post_plugins/mathjax.html&lt;/code&gt;的内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;quot;&amp;gt; &amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]],
    displayMath: [[&#39;$$&#39;,&#39;$$&#39;], [&#39;\[&#39;,&#39;\]&#39;]],
    processEscapes: true,
    processEnvironments: true,
    skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;],
    TeX: { equationNumbers: { autoNumber: &amp;quot;AMS&amp;quot; },
         extensions: [&amp;quot;AMSmath.js&amp;quot;, &amp;quot;AMSsymbols.js&amp;quot;] }
  }
});
MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i = 0; i &amp;lt; all.length; i += 1) {
      all[i].SourceElement().parentNode.className += &#39; has-jax&#39;;
  }
});
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就能使用&lt;code&gt;\$&lt;/code&gt;或&lt;code&gt;\$\$&lt;/code&gt;来编写公式了，最终示例表现如下：
$$ [ \left [ &amp;#8211; \frac{\hbar^2}{2 m} \frac{\partial^2}{\partial x^2} + V \right ] \Psi = i \hbar \frac{\partial}{\partial t} \Psi ]$$&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;post_plugins/viz.html&lt;/code&gt;内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;//cdn.bootcss.com/viz.js/1.3.0/viz.js&amp;quot;&amp;gt; &amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
(function(){
    var vizPrefix = &amp;quot;language-viz-&amp;quot;;
    Array.prototype.forEach.call(document.querySelectorAll(&amp;quot;[class^=&amp;quot; + vizPrefix + &amp;quot;]&amp;quot;), function(x){
        var engine;
        x.getAttribute(&amp;quot;class&amp;quot;).split(&amp;quot; &amp;quot;).forEach(function(cls){
            if (cls.startsWith(vizPrefix)) {
                engine = cls.substr(vizPrefix.length);
            }
        });
        var image = new DOMParser().parseFromString(Viz(x.innerText, {format:&amp;quot;svg&amp;quot;, engine:engine}), &amp;quot;image/svg+xml&amp;quot;);
        x.parentNode.insertBefore(image.documentElement, x);
        x.style.display = &#39;none&#39;
    });
})();
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码的作用，就是将codeblock类型为language-viz-xxx的自动渲染为svg图像显示，以下是示例：&lt;/p&gt;

&lt;p&gt;原始内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ```viz-dot
    digraph g { a -&amp;gt; b; }
    ```

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-viz-dot&#34;&gt;    digraph g { a -&amp;gt; b; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同理，对于其他需要特殊支持的格式或表现，都可以通过添加post_plugins来实现。以上代码都在本网站的&lt;a href=&#34;https://github.com/usbuild/site.git&#34;&gt;github&lt;/a&gt;上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lua Table中HashMap介绍</title>
      <link>http://sysfork.com/post/2016/lua-hashtable-introduction/</link>
      <pubDate>Thu, 01 Sep 2016 17:40:08 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2016/lua-hashtable-introduction/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.lua.org/pil/2.5.html&#34;&gt;Table&lt;/a&gt; 在Lua中有着极其重要的应用，从核心语言实现，如&lt;a href=&#34;https://en.wikipedia.org/wiki/String_interning&#34;&gt;short string intern&lt;/a&gt;，
到利用&lt;a href=&#34;https://www.lua.org/pil/13.html&#34;&gt;metatable&lt;/a&gt;实现的&lt;a href=&#34;lua-users.org/wiki/LuaClassesWithMetatable&#34;&gt;class&lt;/a&gt;，table几乎无所不能。如此高频度地利用也就意味着lua必须要有一个高效的
table实现。&lt;/p&gt;

&lt;p&gt;很多语言提供了array和associative array两种数据结构。array是指以某个指定的最小整数下标(一般是0)开始的连续存储的数据结构，它有vector、list、array、ArrayList等多种名称；associative array，中文
也叫关联数组，即将一对key/pair之间关联起来，它一般也被称为map、dict等。Lua并不提供array，因为数组本身也是一种特殊的关联数组。但是从内部表示上，array和map有着极大的不同，array只需要一块连续的
内存即可实现，而map则有多种实现。Lua为了效率，将一部分整数下标的元素存储在array part中，而将其他元素存储在hashmap中，实现在外部接口不变的情况下实现了效率的最大化。array部分没有什么特别需要
优化的，其就是一整块连续的内存，存储和读取的时间复杂度都是O(1)，而hashmap的实现称为了lua table设计的重点。&lt;/p&gt;

&lt;p&gt;map有多种实现手段，在stl中，默认的map使用的是红黑树，存储和读取的时间复杂度都是O(logn)；虽然红黑树的表现十分稳定，但是实现比较复杂而且无法满足极端性能要求，
C++11中添加新的&lt;a href=&#34;http://en.cppreference.com/w/cpp/container/unordered_map&#34;&gt;unordered_map&lt;/a&gt;，其实现就是使用了一个hashmap。hashmap的基本流程是使用一个hash函数来将
一个key映射到一块连续内存中，实现在理想情况下访问和删除接近O(1)的时间复杂度。&lt;/p&gt;

&lt;p&gt;由于一般key的取值范围大于hashmap slot数目，所以不可避免地出现冲突的状况。在教科书中，解决这种冲突一般有两种方法：&lt;a href=&#34;https://en.wikipedia.org/wiki/Hash_table#Separate_chaining&#34;&gt;链表法&lt;/a&gt;
和&lt;a href=&#34;https://en.wikipedia.org/wiki/Open_addressing&#34;&gt;开放寻址法&lt;/a&gt;。链表法的实现比较简单，将冲突的元素使用链表链接起来即可；而开放寻址法则需要多次计算，直至找到一个没有冲突的slot为止。
这两者都有自己的优缺点，链表法由于使用了链表，无法充分利用CPU缓存，并且实现深拷贝难度较大；而开放寻址法无法实现删除元素的功能，并且当元素密度比较大时，效率非常低。&lt;/p&gt;

&lt;p&gt;Lua table使用了一个折中的方案，叫做&lt;a href=&#34;https://en.wikipedia.org/wiki/Coalesced_hashing&#34;&gt;Coalesced_hashing&lt;/a&gt;，结合使用了链表法和开放寻址法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/4/4c/CoalescedHash.jpg&#34; alt=&#34;Coalesced_hashing&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当插入一个元素时，定义其原本应该在的位置为mainposition，如果mainpoisition对应的slot是空的，则直接插入；如果非空，看看在那个位置上的元素的mainposition是不是当前的slot，如果不是的
话，则将其移动到任意一个空的slot(位置A)，然后将当前的元素插入到mainposition位置，并将当前的next字段设置成位置A，形成链表。如果占用元素mainposition就是当前位置，则将待插入的
元素插入到任意一个空的位置上，并链接到占用元素的后面。&lt;/p&gt;

&lt;p&gt;通过上面的过程，实现了所有的元素都尽量保存在mainposition上，当查找的时候也能使用更少的次数来找到元素位置。这对元素本来就在hashmap中，效率是比较高的。但是，当元素不在hashmap中，查找的代价
比较高。&lt;/p&gt;

&lt;p&gt;lua table的代码实现在&lt;a href=&#34;https://www.lua.org/source/5.3/ltable.c.html&#34;&gt;这里&lt;/a&gt;，实现非常简洁明了，也不是很难懂，但是对于平时经常使用lua的同学来说读一读还是很有必要的。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>