<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.42.1" />

  <title>一种在elf中集成脚本文件的方案 &middot; 乐Coding</title>


  <link rel="stylesheet" href="https://lecoding.com/css/lecoding.css">
  
  


  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.4.0/styles/gruvbox-light.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.4.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  
  

  <link rel="shortcut icon" href="https://lecoding.com/img/favicon.ico" type="image/x-icon" />

</head>


<body data-url="https://lecoding.com/">
<div id="layout">
  <div id="main">
  
<div class="nav">

  <div class="side-menu">
      
        <a class="side-menu-link" href="https://lecoding.com/">Home</a>
      
        <a class="side-menu-link" href="https://lecoding.com/archives/">Archives</a>
      
        <a class="side-menu-link" href="https://lecoding.com/tags/">Tags</a>
      
        <a class="side-menu-link" href="https://lecoding.com/about/">About</a>
      
  </div>

</div>



<div class="content">
<div class="header">
  <h1>一种在elf中集成脚本文件的方案</h1>
</div>


<div class="single-content">
  

<p>进行游戏服务器开发时，我们将<code>C++</code>的部分称之为引擎层，而<code>lua</code>称之为脚本层。但是往往有些核心逻辑是各个游戏公用的，
或者说有些引擎层的代码用<code>C++</code>写起来十分麻烦，我们还是会使用<code>lua</code>来编写。这就带来了一些问题，我们的游戏目录结构如下:</p>

<pre><code>├─bin               // 可执行文件
└─scripts           // 脚本目录，lua文件
    ├─framework     // 核心lua文件，各个项目公用的
    └─server        // 游戏逻辑lua文件
</code></pre>

<p>其中<code>scripts/framework</code>是各个项目公用的，并且和<code>bin</code>目录中的可执行文件同时发布和更新。所以有一个想法，就是将<code>framework</code>中
的lua文件集成到可执行文件中，减少维护的成本。</p>

<h1 id="文件存储">文件存储</h1>

<p>下面是elf文件的示意图</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Elf-layout--en.svg/260px-Elf-layout--en.svg.png" alt="elf" /></p>

<p>elf文件有多个section，除了一些预定义的section如<code>.rodata</code>、<code>.text</code>、<code>.init</code>等，我们也可以定义一些自己的section。所以我们可以将所需要的lua文件
放进这个section中，在执行的时候动态读出来，实现目的。我们可以使用<a href="https://linux.die.net/man/1/objcopy">objcopy</a>命令来实现创建自定义section的功能。</p>

<pre><code>objcopy infile.out --add-section .lua-data=section_file outfile.out
</code></pre>

<p>然而<code>framework</code>里面有多个文件，而且包含嵌套的文件夹，我们需要一个将文件夹变成单个文件的功能，类似于<a href="https://linux.die.net/man/1/tar">tar</a>。虽然创建
section时使用<code>tar</code>命令是简单的，但是在读取的时候需要一些第三方的库来支持，这是比较麻烦的。而由于我们的目录中只包含<code>lua</code>文件，所以可以简化设计。
首先空文件夹对于我们是无意义的，只需要<code>lua</code>文件就可以。所以最终我们得到如下的表:</p>

<pre><code>┌────────────────────┐
│ libs/json.lua      │
├────────────────────┤
│ core/entity.lua    │
├────────────────────┤
│ app/game.lua       │
├────────────────────┤
│ libs/bson.lua      │
└────────────────────┘
</code></pre>

<p>我们可以按照如下的格式转换成单个文件</p>

<pre><code>┌────────┬───────────┐
│name_len│content_len│
├────────┴───────────┤
│ core.entity        │
├────────────────────┤
│name_len│content_len│
├────────────────────┤
│ libs.bson          │
├────────────────────┤
│ .................  │
└────────────────────┘
</code></pre>

<p>其中<code>name_len</code>为文件名的长度，这里直接转换成了lua中<code>require</code>的格式，使用点符号。<code>content_len</code>是文件内容的长度，即文件的具体内容长度。最后我们可以使用<code>zip</code>指令
将这部分内容压缩存储在<code>elf</code>文件中。完整的代码如下:</p>

<pre><code class="language-python">#!/usr/bin/env python
#coding: utf-8

import os, struct, StringIO, zlib, subprocess, sys, tempfile, argparse

argParser = argparse.ArgumentParser()

argParser.add_argument(&quot;luafolder&quot;, type=str)
argParser.add_argument(&quot;exe&quot;, type=str)
argParser.add_argument(&quot;out&quot;, type=str)

args = argParser.parse_args()

files = []

path = args.luafolder

for (dirpath, dirname, filenames) in os.walk(path):
    dirp = dirpath[len(path):]
    if dirp:
        if dirp[-1] != &quot;/&quot;:
            dirp += &quot;/&quot;

        while dirp[0] == &quot;/&quot;:
            dirp = dirp[1:]

    files.extend([dirp + x for x in filenames])

output = StringIO.StringIO()

for fpath in files:
    realp = path + &quot;/&quot; + fpath
    filesize = os.path.getsize(realp)

    if fpath.endswith(&quot;.lua&quot;):
        fpath = fpath[:-4]
    elif fpath.endswith(&quot;.luac&quot;):
        fpath = fpath[:-5]
    else:
        continue

    package_pattern = fpath.replace(&quot;/&quot;, &quot;.&quot;)
    package_pattern = &quot;pg.&quot; + package_pattern
    with open(realp, &quot;rb&quot;) as rf:
        content = rf.read()
        output.write(struct.pack(&quot;=hL&quot;, len(package_pattern), len(content)))
        output.write(package_pattern)
        output.write(content)

f = tempfile.NamedTemporaryFile()

outdata = output.getvalue()
f.write(struct.pack(&quot;=L&quot;, len(outdata)))
f.write(zlib.compress(output.getvalue()))
f.flush()

subprocess.call(&quot;objcopy %s --remove-section .lua-data&quot;%(args.exe, ), shell=True)
subprocess.call(&quot;objcopy %s --add-section .lua-data=%s %s&quot;%(args.exe, f.name, args.out), shell=True)

</code></pre>

<h1 id="文件内容的读取">文件内容的读取</h1>

<p>我们需要使用<code>elf.h</code>文件来读取文件内容。根据上述的格式示意图，<code>elf</code>文件开头的是Header，其格式为<code>ElfXX_Ehdr</code>，
我们可以直接读取文件内容到内存。然后读取<code>e_shoff</code>字段获得section header的位置，定位到位置并依次读取内容到<code>ElfXX_Shdr</code>
结构体中，然后通过各个entry的<code>sh_name</code>得到最终section，然后读取文件达到目的。完整代码如下：</p>

<pre><code>static std::map&lt;std::string, std::string&gt; readElfLuaData(const std::string &amp;filepath) {
    std::map&lt;std::string, std::string&gt; files;
#if __x86_64__
    typedef Elf64_Ehdr ELF_EHDR;
    typedef Elf64_Shdr ELF_SHDR;
#else
    typedef Elf32_Ehdr ELF_EHDR;
    typedef Elf32_Shdr ELF_SHDR;
#endif

    std::ifstream ifs(filepath);

    ELF_EHDR hdr;
    ifs.read(reinterpret_cast&lt;char *&gt;(&amp;hdr), sizeof(hdr));

    std::vector&lt;ELF_SHDR&gt; sh_tables(hdr.e_shnum);
    ifs.seekg(static_cast&lt;long&gt;(hdr.e_shoff));

    for (size_t i = 0; i &lt; hdr.e_shnum; ++i) {
        ifs.read(reinterpret_cast&lt;char *&gt;(&amp;sh_tables[i]), sizeof(sh_tables[i]));
    }

    // read shstr

    std::vector&lt;char&gt; shstr(sh_tables[hdr.e_shstrndx].sh_size);
    ifs.seekg(static_cast&lt;long&gt;(sh_tables[hdr.e_shstrndx].sh_offset));
    ifs.read(shstr.data(), static_cast&lt;long&gt;(shstr.size()));

    ELF_SHDR *lua_sh = nullptr;

    for (size_t i = 0; i &lt; hdr.e_shnum; ++i) {
        char *name = shstr.data() + sh_tables[i].sh_name;
        if (strcmp(name, &quot;.lua-data&quot;) == 0) {
            lua_sh = &amp;sh_tables[i];
            break;
        }
    }

    if (lua_sh) {
        std::vector&lt;char&gt; buf(lua_sh-&gt;sh_size);
        ifs.seekg(static_cast&lt;long&gt;(lua_sh-&gt;sh_offset));
        ifs.read(buf.data(), static_cast&lt;std::streamsize&gt;(buf.size()));

        size_t idx = 0;
#define READ_TO(TARGET, SIZE)                                                                      \
    memcpy(TARGET, buf.data() + idx, SIZE);                                                        \
    idx += SIZE;

        uint32_t raw_len = 0;
        READ_TO(&amp;raw_len, sizeof(raw_len));

        std::vector&lt;char&gt; tmp(raw_len);
        uLongf dest_len = tmp.size();
        uncompress(reinterpret_cast&lt;Bytef *&gt;(tmp.data()), &amp;dest_len,
                   reinterpret_cast&lt;Bytef *&gt;(buf.data() + idx), buf.size() - idx);

        buf.swap(tmp);
        idx = 0;

        while (idx &lt; dest_len) {
            uint16_t name_len;
            uint32_t content_len;
            READ_TO(&amp;name_len, sizeof(name_len));
            READ_TO(&amp;content_len, sizeof(content_len));
            std::string filename(name_len, 0), content(content_len, 0);
            READ_TO(&amp;*filename.begin(), filename.size());
            READ_TO(&amp;*content.begin(), content.size());
            files.emplace(std::piecewise_construct, std::forward_as_tuple(std::move(filename)),
                          std::forward_as_tuple(std::move(content)));
        }
#undef READ_TO
    }
    return files;
}
</code></pre>

<p>接下来便可以通过添加到<code>package.preload</code>实现在lua中调用这些文件的目的。</p>

</div>

  <div class="eof">--EOF--</div>

  <div class="post-meta">
    发表于 <time>01 May 2017, 22:30</time>
  
  
  
  
  , 标签: 「
    
      <a class="post-taxonomy-tag" href="https://lecoding.com/tags/elf">elf</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="https://lecoding.com/tags/lua">lua</a>
    
」
  
  

</div>


  
<div class="prev-next-post">
  <div class="prev-link" style="text-align: left;">
    
    <nav class="prev">
      <a href="https://lecoding.com/post/2017/cpp-function-container/">« 使用C&#43;&#43; map实现注册回调的功能</a>
    </nav>
    
  </div>
  <div class="next-link">
    
    <nav class="next">
      <a href="https://lecoding.com/post/2017/compatible-embed-luajit-ffi-load/">嵌入 luajit 时同时使用 ffi 和 c api 的解决方案 »</a>
    </nav>
    
  </div>
</div>



  


  
</div>

</div>
</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-19710645-12', 'auto');
  ga('send', 'pageview');

</script>


</script>
</body>
</html>

