<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.42.1" />

  <title>理解Linux下动态链接库延迟绑定 &middot; 乐Coding</title>


  <link rel="stylesheet" href="http://lecoding.com/css/lecoding.css">
  
  


  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.4.0/styles/gruvbox-light.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.4.0/highlight.min.js"></script>
  <link href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css" rel="stylesheet">
  <script>hljs.initHighlightingOnLoad();</script>
  
  

  <link rel="shortcut icon" href="http://lecoding.com/img/favicon.ico" type="image/x-icon" />

</head>


<body data-url="http://lecoding.com/">
<div id="layout">
  <div id="main">
  
<div class="nav">

  <div class="side-menu">
      
        <a class="side-menu-link" href="http://lecoding.com/">Home</a>
      
        <a class="side-menu-link" href="http://lecoding.com/post/">Archives</a>
      
        <a class="side-menu-link" href="http://lecoding.com/tags/">Tags</a>
      
        <a class="side-menu-link" href="http://lecoding.com/about/">About</a>
      
  </div>

</div>



<div class="content">
<div class="header">
  <h1>理解Linux下动态链接库延迟绑定</h1>
</div>


<div class="single-content">
  <script src="//cdn.bootcss.com/highlight.js/9.6.0/languages/x86asm.min.js"></script>

<p>在编译动态链接库时，为了保证能被正常使用，一般我们会加上-fPIC参数。在使用的动态链接库中的函数时，Linux使用了一种
叫延迟绑定的技术实现运行时的symbol relocation。其中的关键就是GOT(Global Offset Table)和PLT(Procedure linkage Table)。下面就
这一技术的实现简单解释一下。</p>

<p>首先写一个很简单的需要动态链接的程序，如下</p>

<pre><code class="language-c">//dl_test.c
#include &lt;stdio.h&gt;
int main(int argc, const char *argv[])
{
    puts(&quot;1234&quot;);
    puts(&quot;1234&quot;);
    return 0;
}
</code></pre>

<p>然后使用<code>gcc</code>编译并链接: <code>gcc -g dl_test.c -o dl_test.c</code>。先别急着运行这个程序，我们使用<code>objdump</code>反编译一下看看：</p>

<pre><code class="language-bash">$ objdump -S dl_test
......
0000000000400506 &lt;main&gt;:
#include &lt;stdio.h&gt;
int main(int argc, const char *argv[])
{
  400506:       55                      push   %rbp
  400507:       48 89 e5                mov    %rsp,%rbp
  40050a:       48 83 ec 10             sub    $0x10,%rsp
  40050e:       89 7d fc                mov    %edi,-0x4(%rbp)
  400511:       48 89 75 f0             mov    %rsi,-0x10(%rbp)
    puts(&quot;1234&quot;);
  400515:       bf b4 05 40 00          mov    $0x4005b4,%edi
  40051a:       e8 c1 fe ff ff          callq  4003e0 &lt;puts@plt&gt;
    puts(&quot;1234&quot;);
  40051f:       bf b4 05 40 00          mov    $0x4005b4,%edi
  400524:       e8 b7 fe ff ff          callq  4003e0 &lt;puts@plt&gt;
    return 0;
  400529:       b8 00 00 00 00          mov    $0x0,%eax
}
  40052e:       c9                      leaveq
  40052f:       c3                      retq
......
</code></pre>

<p>可以看到，在<code>40051a</code>和<code>400524</code>两处都调用了我们的<code>puts</code>函数。但是看后面的注解，<code>&lt;puts@plt&gt;</code>表示这并不是<code>puts</code>的地址，而是另有目的。
我们使用<code>gdb</code>来跟踪一下执行过程：<code>gdb dl_test</code></p>

<pre><code>(gdb) l
1	#include &lt;stdio.h&gt;
2	int main(int argc, const char *argv[])
3	{
4	    puts(&quot;1234&quot;);
5	    puts(&quot;1234&quot;);
6	    return 0;
7	}
(gdb) b 4
Breakpoint 1 at 0x400515: file dl_test.c, line 4.
(gdb) r
Starting program: /home/zqc/workspace/cpptest/dl_test

Breakpoint 1, main (argc=1, argv=0x7fffffffeb98) at dl_test.c:4
4	    puts(&quot;1234&quot;);
(gdb)
</code></pre>

<p>这里设置了一下断点到第一个<code>puts</code>的调用出，使用<code>layout asm</code>切换成汇编模式:</p>

<pre><code class="language-x86asm">(gdb) layout asm
   ┌────────────────────────────────────────────────────────────────────────────────────────────┐
B+&gt;│0x400515 &lt;main+15&gt;              mov    $0x4005b4,%edi                                       │
   │0x40051a &lt;main+20&gt;              callq  0x4003e0 &lt;puts@plt&gt;                                  │
   │0x40051f &lt;main+25&gt;              mov    $0x4005b4,%edi                                       │
   │0x400524 &lt;main+30&gt;              callq  0x4003e0 &lt;puts@plt&gt;                                  │
   │0x400529 &lt;main+35&gt;              mov    $0x0,%eax                                            │
   │0x40052e &lt;main+40&gt;              leaveq                                                      │
   │0x40052f &lt;main+41&gt;              retq                                                        │
   │0x400530 &lt;__libc_csu_init&gt;      push   %r15                                                 │
   │0x400532 &lt;__libc_csu_init+2&gt;    mov    %edi,%r15d                                           │
   │0x400535 &lt;__libc_csu_init+5&gt;    push   %r14                                                 │
   │0x400537 &lt;__libc_csu_init+7&gt;    mov    %rsi,%r14                                            │
   │0x40053a &lt;__libc_csu_init+10&gt;   push   %r13                                                 │
   │0x40053c &lt;__libc_csu_init+12&gt;   mov    %rdx,%r13                                            │
   │0x40053f &lt;__libc_csu_init+15&gt;   push   %r12                                                 │
   │0x400541 &lt;__libc_csu_init+17&gt;   lea    0x2001a0(%rip),%r12        # 0x6006e8                │
   │0x400548 &lt;__libc_csu_init+24&gt;   push   %rbp                                                 │
   │0x400549 &lt;__libc_csu_init+25&gt;   lea    0x2001a0(%rip),%rbp        # 0x6006f0                │
   │0x400550 &lt;__libc_csu_init+32&gt;   push   %rbx                                                 │
   │0x400551 &lt;__libc_csu_init+33&gt;   sub    %r12,%rbp                                            │
   └────────────────────────────────────────────────────────────────────────────────────────────┘
child process 8855 In: main                                              Line: 4    PC: 0x400515
</code></pre>

<p>使用<code>stepi</code>或者简写为<code>si</code>执行下一条汇编指令。我们一直跟踪到<code>call</code>指令中去：</p>

<pre><code class="language-x86asm">   ┌────────────────────────────────────────────────────────────────────────────────────────────────────────┐
  &gt;│0x4003e0 &lt;puts@plt&gt;                     jmpq   *0x20050a(%rip)   # 0x6008f0 &lt;puts@got.plt&gt;              │
   │0x4003e6 &lt;puts@plt+6&gt;                   pushq  $0x0                                                     │
   │0x4003eb &lt;puts@plt+11&gt;                  jmpq   0x4003d0                                                 │
   │0x4003f0 &lt;__libc_start_main@plt&gt;        jmpq   *0x200502(%rip)   # 0x6008f8 &lt;__libc_start_main@got.plt&gt; │
   │0x4003f6 &lt;__libc_start_main@plt+6&gt;      pushq  $0x1                                                     │
   │0x4003fb &lt;__libc_start_main@plt+11&gt;     jmpq   0x4003d0                                                 │
   │0x400400 &lt;__gmon_start__@plt&gt;           jmpq   *0x2004fa(%rip)   # 0x600900 &lt;__gmon_start__@got.plt&gt;    │
   │0x400406 &lt;__gmon_start__@plt+6&gt;         pushq  $0x2                                                     │
   │0x40040b &lt;__gmon_start__@plt+11&gt;        jmpq   0x4003d0                                                 │
   │0x400410 &lt;_start&gt;                       xor    %ebp,%ebp                                                │
   │0x400412 &lt;_start+2&gt;                     mov    %rdx,%r9                                                 │
   │0x400415 &lt;_start+5&gt;                     pop    %rsi                                                     │
   │0x400416 &lt;_start+6&gt;                     mov    %rsp,%rdx                                                │
   │0x400419 &lt;_start+9&gt;                     and    $0xfffffffffffffff0,%rsp                                 │
   │0x40041d &lt;_start+13&gt;                    push   %rax                                                     │
   │0x40041e &lt;_start+14&gt;                    push   %rsp                                                     │
   │0x40041f &lt;_start+15&gt;                    mov    $0x4005a0,%r8                                            │
   │0x400426 &lt;_start+22&gt;                    mov    $0x400530,%rcx                                           │
   │0x40042d &lt;_start+29&gt;                    mov    $0x400506,%rdi                                           │
   └────────────────────────────────────────────────────────────────────────────────────────────────────────┘
child process 9211 In: puts@plt                                                      Line: ??   PC: 0x4003e0
0x00000000004003e0 in puts@plt ()
(gdb)
</code></pre>

<p><code>0x4003e0</code>是刚刚跳转的地址，也就是<code>&lt;puts@plt&gt;</code>，从这个名字中我们可以看出，这个地址是属于<code>plt</code>的。先说一下<code>plt</code>的作用，<code>plt</code>的全称是
过程链接表，意思就是当调用一个动态链接库中的函数时，其访问的是其实是<code>plt</code>中的一个过程，这个过程会完成真正的调用。我们分别看下属于<code>puts</code>中
<code>plt</code>的项目</p>

<pre><code class="language-x86asm">  &gt;│0x4003e0 &lt;puts@plt&gt;                     jmpq   *0x20050a(%rip)        # 0x6008f0 &lt;puts@got.plt&gt;     │
   │0x4003e6 &lt;puts@plt+6&gt;                   pushq  $0x0                                                 │
   │0x4003eb &lt;puts@plt+11&gt;                  jmpq   0x4003d0                                             │
</code></pre>

<p>其中 <code>0x20050a(%rip)</code> 即 <code>got</code>中的地址，在初始情况下，该选项为<code>plt</code>项中的下一条指令，所以执行<code>jmpq   *0x20050a(%rip)</code> 直接会进入到
下一条指令<code>pushq</code>， <code>pushq $0x0</code>的目的是把当前在符号(<code>puts</code>)在<code>.rela.plt</code>中的index。我们可以使用<code>readelf</code>指令看下：</p>

<pre><code class="language-bash">$ readelf -r dl_test

Relocation section '.rela.dyn' at offset 0x348 contains 1 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
0000006008d0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0

Relocation section '.rela.plt' at offset 0x360 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
0000006008f0  000100000007 R_X86_64_JUMP_SLO 0000000000000000 puts + 0
0000006008f8  000200000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main + 0
000000600900  000300000007 R_X86_64_JUMP_SLO 0000000000000000 __gmon_start__ + 0
</code></pre>

<p>可以看到，<code>puts</code>的index为0，第一项，所以这里push的是<code>$0x0</code>。同理，下面的<code>__libc_start_main</code>就是<code>$0x1</code>。 下一行语句是<code>jmpq   0x4003d0</code>，这个地址是
固定的，所有的<code>plt</code>入口最后一句语句都是这个，这是个通用的过程。
继续<code>stepi</code>到jump的位置</p>

<pre><code class="language-x86asm">  &gt;│0x4003d0                                pushq  0x20050a(%rip)        # 0x6008e0                     │
   │0x4003d6                                jmpq   *0x20050c(%rip)        # 0x6008e8                    │
   │0x4003dc                                nopl   0x0(%rax)                                            │
   │0x4003e0 &lt;puts@plt&gt;                     jmpq   *0x20050a(%rip)        # 0x6008f0 &lt;puts@got.plt&gt;     │
</code></pre>

<p>发现这个地址就是在<code>puts@plt</code>的上面，并且也是为了保证和普通<code>plt</code>入口项目大小(<code>0x10</code>)，其末尾还用0补齐了(<code>nopl   0x0(%rax)</code>)。我们重点看一下前面两句。</p>

<p><code>pushq  0x20050a(%rip)        # 0x6008e0</code>，这里push了一个地址，这个地址是干嘛的？我们使用<code>gdb</code>看一下：</p>

<pre><code>(gdb) x /16x 0x6008e0
0x6008e0:       0xf7ffe1a8      0x00007fff      0xf7df02b0      0x00007fff
0x6008f0 &lt;puts@got.plt&gt;:        0x004003e6      0x00000000      0xf7a52a50      0x00007fff
0x600900 &lt;__gmon_start__@got.plt&gt;:      0x00400406      0x00000000      0x00000000      0x00000000
0x600910:       0x00000000      0x00000000      0x00000000      0x00000000
</code></pre>

<p>这个地址其实就是<code>got</code>中的一项，并且在所有普通符号<code>got</code>的前面。那么目前栈上的元素是：</p>

<pre><code>| 0x00007ffff7ffe1a8 |
| 0x0                |
</code></pre>

<p>接下来到是<code>jmpq   *0x20050c(%rip)</code> 这个地址也是在plt上，紧挨着上面push的地址，值为<code>0x00007ffff7df02b0</code>，我们可以继续<code>stepi</code>进去，也可以
通过<code>disassemble 0x00007ffff7df02b0</code>查看。或者，使用<code>info symbol 0x00007ffff7df02b0</code>直接查看。</p>

<pre><code>(gdb) info symbol 0x00007ffff7df02b0
_dl_runtime_resolve in section .text of /lib64/ld-linux-x86-64.so.2
</code></pre>

<p>从这里可以看出，这是属于<code>ld-linux-x86-64.so.2</code>里面的一个方法。这个so属于<code>glibc</code>的一部分，我们可以下载<a href="ftp://ftp.gnu.org/gnu/glibc">glibc</a>来查看。最终我们找到了这个符号定义文件，
其位置在<code>sysdeps/x86_64/dl-trampoline.S</code>，内容如下</p>

<pre><code class="language-x86asm"> 28     .globl _dl_runtime_resolve
 29     .type _dl_runtime_resolve, @function
 30     .align 16
 31     cfi_startproc
 32 _dl_runtime_resolve:
 33     cfi_adjust_cfa_offset(16) # Incorporate PLT
 34     subq $56,%rsp
 35     cfi_adjust_cfa_offset(56)
 36     movq %rax,(%rsp)    # Preserve registers otherwise clobbered.
 37     movq %rcx, 8(%rsp)
 38     movq %rdx, 16(%rsp)
 39     movq %rsi, 24(%rsp)
 40     movq %rdi, 32(%rsp)
 41     movq %r8, 40(%rsp)
 42     movq %r9, 48(%rsp)
 43     movq 64(%rsp), %rsi # Copy args pushed by PLT in register.
 44     movq 56(%rsp), %rdi # %rdi: link_map, %rsi: reloc_index
 45     call _dl_fixup      # Call resolver.
 46     movq %rax, %r11     # Save return value
 47     movq 48(%rsp), %r9  # Get register content back.
 48     movq 40(%rsp), %r8
 49     movq 32(%rsp), %rdi
 50     movq 24(%rsp), %rsi
 51     movq 16(%rsp), %rdx
 52     movq 8(%rsp), %rcx
 53     movq (%rsp), %rax
 54     addq $72, %rsp      # Adjust stack(PLT did 2 pushes)
 55     cfi_adjust_cfa_offset(-72)
 56     jmp *%r11       # Jump to function address.
 57     cfi_endproc
 58     .size _dl_runtime_resolve, .-_dl_runtime_resolve
</code></pre>

<p>从43行开始是我们的逻辑。43行取出了我们刚刚push的第一个参数，就是<code>$0x0</code>，放到<code>%rsi</code>中，然后是我们push的第二个参数，<code>0x00007ffff7ffe1a8</code>到<code>%rsi</code>中。
为什么是这两个寄存器呢？我们<code>man syscall</code>一下：</p>

<pre><code>       arch/ABI   arg1   arg2   arg3   arg4   arg5   arg6   arg7
       ──────────────────────────────────────────────────────────
       x86_64     rdi    rsi    rdx    r10    r8     r9     -
</code></pre>

<p>可以看出linux下的函数传参方式， 那么<code>%rdi</code>就是参数1，而<code>%rsi</code>就是参数2了。接下来是<code>call _dl_fixup</code>，这个函数返回值就是指向<code>puts</code>存储地址位置的指针了，后面可以看到
代码中将这个指针保存到了<code>%r11</code>，然后<code>jmp *%r11</code>。完成了一次函数调用，下面我们来看看<code>_dl_fixup</code>做了些什么。同样，这个函数也是<code>gblic</code>中定义的，位置在<code>elf/dl-runtime.c</code>中：</p>

<pre><code class="language-c">59 DL_FIXUP_VALUE_TYPE
60 __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE
61 _dl_fixup (
62 # ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS
63        ELF_MACHINE_RUNTIME_FIXUP_ARGS,
64 # endif
65        struct link_map *l, ElfW(Word) reloc_arg)
66 {
</code></pre>

<p>从函数原型我们可以看出，之前<code>push</code>的两个参数分别是<code>link_map</code>和<code>reloc_arg</code>，</p>

<pre><code class="language-c"> 67   const ElfW(Sym) *const symtab
 68     = (const void *) D_PTR (l, l_info[DT_SYMTAB]);
 69   const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);
 70 
 71   const PLTREL *const reloc
 72     = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);
 73   const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];
 74   void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);
</code></pre>

<p>这里做了一下转型，那么<code>symtab</code>和<code>strtab</code>分别是对于<code>section</code>的地址，而<code>reloc_addr</code>就是我们<code>got</code>中的<code>puts@got.plt</code>的地址。接下来就是符号解析过程了，
后面可能会有文章来解释这个过程。当找到目标地址后</p>

<pre><code class="language-c">//elf/dl-runtime.c
148   return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);
//sysdeps/x86_64/dl-machine.h
205 static inline ElfW(Addr)
206 elf_machine_fixup_plt (struct link_map *map, lookup_t t,
207                const ElfW(Rela) *reloc,
208                ElfW(Addr) *reloc_addr, ElfW(Addr) value)
209 {
210   return *reloc_addr = value;
211 }
</code></pre>

<p>这里的<code>value</code>就是目标函数地址，也就是<code>puts</code>的真正地址，代码中设置其到了<code>puts@got.plt</code>的位置并返回。</p>

<p>以上就是第一次调用<code>puts</code>的过程了，当第二次调用<code>puts</code>时，由于<code>puts@got.plt</code>已经有了正确的地址，所以</p>

<pre><code class="language-x86asm">  &gt;│0x4003e0 &lt;puts@plt&gt;                     jmpq   *0x20050a(%rip)        # 0x6008f0 &lt;puts@got.plt&gt;    │
</code></pre>

<p>就直接跳转到正确的<code>puts</code>位置，完成了函数调用。所以，<code>linux</code>下的这种懒绑定方式实现了在不使用符号的时候不解析，而需要使用的时候
只在第一步开销比较大，后面的调用开销无非多了一次跳转和一次寻址操作而已。</p>

</div>

  <div class="eof">--EOF--</div>

  <div class="post-meta">
    发表于 <time>07 Sep 2016, 22:08</time>
  
  
  
  
  , 标签: 「
    
      <a class="post-taxonomy-tag" href="http://lecoding.com/tags/linux">Linux</a>&nbsp;&#47;
    
      <a class="post-taxonomy-tag" href="http://lecoding.com/tags/elf">ELF</a>
    
」
  
  

</div>


  
<div class="prev-next-post">
  <div class="prev-link" style="text-align: left;">
    
    <nav class="prev">
      <a href="http://lecoding.com/post/2016/integrate-mathjax-viz-with-hugo/">« Hugo 集成 Mathjax和graphviz</a>
    </nav>
    
  </div>
  <div class="next-link">
    
    <nav class="next">
      <a href="http://lecoding.com/post/2016/about-cpp-alignment/">浅谈C&#43;&#43;中的地址对齐 »</a>
    </nav>
    
  </div>
</div>



  


  
    
        
        <script type="text/javascript" src="//cdn.bootcss.com/viz.js/1.3.0/viz.js"> </script>
<script type="text/javascript">
(function(){
    var vizPrefix = "language-viz-";
    Array.prototype.forEach.call(document.querySelectorAll("[class^=" + vizPrefix + "]"), function(x){
        var engine;
        x.getAttribute("class").split(" ").forEach(function(cls){
            if (cls.startsWith(vizPrefix)) {
                engine = cls.substr(vizPrefix.length);
            }
        });
        var image = new DOMParser().parseFromString(Viz(x.innerText, {format:"svg", engine:engine}), "image/svg+xml");
        x.parentNode.insertBefore(image.documentElement, x);
        x.parentNode.className += " plain";
        x.style.display = 'none';
    });
})();
</script>

    

</div>

</div>
</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-19710645-12', 'auto');
  ga('send', 'pageview');

</script>


</script>
</body>
</html>

