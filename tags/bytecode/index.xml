<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bytecode on sysğŸ”±fork</title>
    <link>http://sysfork.com/tags/bytecode/</link>
    <description>Recent content in Bytecode on sysğŸ”±fork</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Sat, 20 May 2017 15:57:13 +0800</lastBuildDate>
    <atom:link href="http://sysfork.com/tags/bytecode/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>lua 5.1 åˆ†æ”¯è¯­å¥ bytecode çš„ç”Ÿæˆï¼ˆä¸€ï¼‰</title>
      <link>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-1/</link>
      <pubDate>Sat, 20 May 2017 15:57:13 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-1/</guid>
      <description>

&lt;p&gt;æœ¬æ–‡åªå¯¹ &lt;code&gt;IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END&lt;/code&gt; è¯­æ³•çš„å­—èŠ‚ç ç”Ÿæˆè¿‡ç¨‹è¿›è¡Œæè¿°ã€‚&lt;/p&gt;

&lt;h2 id=&#34;ç”Ÿæˆçš„ç»“æœ&#34;&gt;ç”Ÿæˆçš„ç»“æœ&lt;/h2&gt;

&lt;p&gt;é¦–å…ˆæˆ‘ä»¬çœ‹ä¸‹é¢çš„ç¤ºä¾‹ï¼Œä»…ä¸ºæ¼”ç¤ºï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local cond1 = true
local cond2 = true
if cond1 then
    cond1 = false
elseif cond2 then
    cond2 = false
else
    cond1 = false
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ä½¿ç”¨&lt;code&gt;luac -l -l&lt;/code&gt;é€‰é¡¹åˆ—å‡ºæ¥çš„ç»“æœä¸º&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main &amp;lt;test.lua:0,0&amp;gt; (12 instructions, 48 bytes at 0x184e530)
0+ params, 2 slots, 0 upvalues, 2 locals, 0 constants, 0 functions
        1       [1]     LOADBOOL        0 1 0
        2       [2]     LOADBOOL        1 1 0
        3       [3]     TEST            0 0 0
        4       [3]     JMP             2       ; to 7
        5       [4]     LOADBOOL        0 0 0
        6       [4]     JMP             5       ; to 12
        7       [5]     TEST            1 0 0
        8       [5]     JMP             2       ; to 11
        9       [6]     LOADBOOL        1 0 0
        10      [6]     JMP             1       ; to 12
        11      [8]     LOADBOOL        0 0 0
        12      [9]     RETURN          0 1
constants (0) for 0x184e530:
locals (2) for 0x184e530:
        0       cond1   2       12
        1       cond2   3       12
upvalues (0) for 0x184e530:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è¿™é‡Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æœ€ç»ˆçš„ç”Ÿæˆç»“æœã€‚æˆ‘ä»¬å…³æ³¨çš„æ˜¯å…¶ä¸­çš„&lt;code&gt;TEST&lt;/code&gt;å’Œ&lt;code&gt;JUMP&lt;/code&gt;ã€‚åœ¨ç¬¬3è¡Œçš„&lt;code&gt;TEST&lt;/code&gt;ï¼Œå…¶æ„æ€æ˜¯å¦‚æœ0å·å¯„å­˜å™¨ä¸­çš„å†…å®¹(cond1)
ä¸ºfalse(0)çš„è¯ï¼Œé‚£ä¹ˆå°±æ‰§è¡Œä¸‹é¢çš„&lt;code&gt;JMP&lt;/code&gt;è¯­å¥ï¼Œå¦åˆ™å°±è°ƒè¿‡&lt;code&gt;JMP&lt;/code&gt;ç›´æ¥åˆ°ç¬¬5è¡Œã€‚&lt;code&gt;LUA&lt;/code&gt;ä¸­çš„åˆ†æ”¯å®ç°éƒ½æ˜¯ä½¿ç”¨&lt;code&gt;TEST&lt;/code&gt;ç­‰åé¢ç´§è·Ÿ&lt;code&gt;JMP&lt;/code&gt;å®ç°çš„ï¼Œ
ä»ä¸» dispatch ä»£ç ä¸­å¯ä»¥çœ‹åˆ°&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // ...
      case OP_TEST: {
        if (l_isfalse(ra) != GETARG_C(i))
          dojump(L, pc, GETARG_sBx(*pc));
        pc++;
        continue;
      }
      case OP_TESTSET: {
        TValue *rb = RB(i);
        if (l_isfalse(rb) != GETARG_C(i)) {
          setobjs2s(L, ra, rb);
          dojump(L, pc, GETARG_sBx(*pc));
        }
        pc++;
        continue;
      }
      // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;JMP&lt;/code&gt;è·³è½¬ï¼Œæ°¸è¿œéƒ½æ˜¯åˆ†æ”¯ä¸æˆç«‹çš„æƒ…å†µï¼Œè€Œ&lt;code&gt;TEST&lt;/code&gt;æˆåŠŸåçš„è·³è½¬æ°¸è¿œæ˜¯è·³è¿‡ä¸‹ä¸€è¡Œï¼Œå¤±è´¥çš„è¯ç»§ç»­æ‰§è¡Œæ¥ä¸‹æ¥çš„JMPã€‚&lt;code&gt;if&lt;/code&gt;è¯­å¥çš„å­—èŠ‚ç è§£æå°±åˆ°è¿™é‡Œï¼Œåé¢çš„&lt;code&gt;elseif&lt;/code&gt;ç­‰éƒ½æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œå†äº†è§£è¿™ä¸ªäº‹å®ä¹‹åã€‚
é‚£ä¹ˆè¿™ç§å­—èŠ‚ç æ˜¯æ€ä¹ˆç”Ÿæˆçš„å‘¢ï¼Ÿä¸‹é¢æ¥åˆ†æä¸‹ã€‚&lt;/p&gt;

&lt;h2 id=&#34;ç”Ÿæˆçš„è¿‡ç¨‹&#34;&gt;ç”Ÿæˆçš„è¿‡ç¨‹&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt;è¯­å¥çš„ä»£ç åœ¨&lt;code&gt;lparser.c&lt;/code&gt;é‡Œé¢ï¼Œæœ€ä¸Šå±‚å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void ifstat (LexState *ls, int line) {
  /* ifstat -&amp;gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
  FuncState *fs = ls-&amp;gt;fs;
  int flist;
  int escapelist = NO_JUMP;
  flist = test_then_block(ls);  /* IF cond THEN block */
  while (ls-&amp;gt;t.token == TK_ELSEIF) {
    luaK_concat(fs, &amp;amp;escapelist, luaK_jump(fs)); // å°† escapelist ä¸²èµ·æ¥ï¼Œè¿™é‡Œçš„ luaK_jump ä¼šè·³è½¬åˆ° end
    luaK_patchtohere(fs, flist); // æŠŠä¸Šé¢é‚£ä¸ª`JMP(1/3)` åœ°å€ä¿®æ”¹å¯¹
    flist = test_then_block(ls);  /* ELSEIF cond THEN block */
  }
  if (ls-&amp;gt;t.token == TK_ELSE) {
    luaK_concat(fs, &amp;amp;escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    luaX_next(ls);  /* skip ELSE (after patch, for correct line info) */
    block(ls);  /* `else&#39; part */
  }
  else
    luaK_concat(fs, &amp;amp;escapelist, flist); // è¿™é‡ŒæŠŠ flist ä¸²èµ·æ¥äº†ï¼Œæ„æ€æ˜¯æ²¡æœ‰ else è¯­å¥ï¼Œæ­¤æ—¶ flist æŒ‡å‘å°±æ˜¯ end
  luaK_patchtohere(fs, escapelist); // ä¿®æ”¹ escapelist åˆ° end è¯­å¥çš„ç»“å°¾
  check_match(ls, TK_END, TK_IF, line);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;åœ¨è¯»å– token çš„æ—¶å€™ï¼Œé‡åˆ° &lt;code&gt;if ... then&lt;/code&gt; ä¼šç”Ÿæˆ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TEST reg 0 predict
JMP ??? (1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ç”±äºæˆ‘ä»¬ä¸çŸ¥é“åé¢ä»£ç çš„å†…å®¹ï¼Œæ‰€ä»¥æ— æ³•ç¡®å®š&lt;code&gt;???&lt;/code&gt;è¯¥å¡«å†™å¤šå°‘ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯è¦è®°ä½è¿™ä¸ªä½ç½®ï¼Œå°†æ¥æˆ‘ä»¬è¦æŠŠå€¼å¡«å†™è¿›å»ï¼Œè¿™ä¸ªå€¼å…¶å®å°±å­˜
åœ¨&lt;code&gt;flist&lt;/code&gt;ã€‚ç„¶åæˆ‘ä»¬è¯»åˆ°&lt;code&gt;elseif cond then&lt;/code&gt;è¯­å¥ï¼Œè¿™å°±æ„å‘³ç€ç¬¬ä¸€æ®µä»£ç çš„ç»“æŸæ­¤æ—¶åº”è¯¥è¦è·³è½¬å‡ºè¿™ä¸ª&lt;code&gt;if&lt;/code&gt;
è¯­å¥ï¼Œæ‰€ä»¥æ­¤æ—¶åº”è¯¥æ’å…¥ä¸€ä¸ª&lt;code&gt;JMP(2)&lt;/code&gt;åˆ°æ•´ä¸ªè¯­å¥çš„ç»“æŸï¼Œå› ä¸ºæœ‰å¤šä¸ª block çš„å­˜åœ¨ï¼Œåé¢å¯èƒ½ä¼šæœ‰å¾ˆå¤šè¿™ç§ç±»ä¼¼çš„
&lt;code&gt;JMP&lt;/code&gt;ï¼Œå¦‚ä¸Šé¢ç¤ºä¾‹ä¸­çš„å„ç§&lt;code&gt;to 12&lt;/code&gt;ï¼Œè¿™äº›ä½ç½®éƒ½æ— æ³•ç¡®å®šï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªescapelistæ¥æŒ‡å‘è¿™ä¸ªåœ°å€ï¼Œæ–¹ä¾¿åé¢å¤„ç†ã€‚
ç°åœ¨å›å¤´çœ‹&lt;code&gt;JMP(1)&lt;/code&gt;ä½ç½®å°±ç¡®å®šäº†ï¼Œæ‰€ä»¥å½“å‰çš„PCå°±æ˜¯&lt;code&gt;flist&lt;/code&gt;çš„æŒ‡å‘ç”±äº&lt;code&gt;elseif&lt;/code&gt;åˆæ˜¯ä¸€ä¸ªåˆ†æ”¯è¯­å¥ï¼Œæ‰€ä»¥åˆå¯ä»¥ç”Ÿæˆä¸€æ®µ &lt;code&gt;TEST &amp;amp; JMP(3)&lt;/code&gt;ä»£ç äº†ã€‚åŒæ ·&lt;code&gt;JMP(2)&lt;/code&gt;çš„ä½ç½®æ˜¯æ— æ³•ç¡®å®šçš„ã€‚
ç°åœ¨æ¥è°ˆè°ˆ&lt;code&gt;escapelist&lt;/code&gt;ï¼Œå®šä¹‰&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int escapelist = NO_JUMP;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è¿™æ˜¯ä¸ª int å•Šï¼Œå¯¹äºå¤šä¸ªä½ç½®çš„&lt;code&gt;JMP(2)&lt;/code&gt;è¦æ€ä¹ˆå¤„ç†ï¼Ÿlua é‡‡ç”¨äº†ä¸€ç§å·§å¦™çš„æœºåˆ¶ï¼Œç”±äºæ­¤æ—¶çš„&lt;code&gt;JMP&lt;/code&gt;æ˜¯æ— æ•ˆçš„ï¼Œè¿˜æ²¡æœ‰è§£æåˆ°æ­£å¼åœ°å€çš„ï¼Œ
æ‰€ä»¥å…¶ä¸­çš„ç›®æ ‡åœ°å€åŸŸæ˜¯æ²¡æœ‰ä½¿ç”¨çš„ã€‚å› æ­¤ï¼Œå¯ä»¥é‡‡ç”¨ä¸²èµ·æ¥çš„æ–¹å¼ï¼ŒescapcelistæŒ‡å‘ç¬¬ä¸€ä¸ªæ²¡æœ‰è§£æçš„&lt;code&gt;JMP&lt;/code&gt;ï¼Œç„¶åè¿™ä¸ª&lt;code&gt;JMP&lt;/code&gt;çš„æŒ‡å‘åœ°å€
æ˜¯ä¸‹ä¸€ä¸ªæ²¡æœ‰è§£æçš„&lt;code&gt;JMP&lt;/code&gt;ï¼Œè¿™æ ·ä¸€æ¥å°±å½¢æˆäº†é“¾è¡¨çš„ç»“æ„ã€‚åé¢å¯ä»¥ä¸€èµ·ä¿®æ”¹ç›®æ ‡åœ°å€é€šè¿‡&lt;code&gt;luaK_patchtohere&lt;/code&gt;æ¥å®ç°ã€‚&lt;/p&gt;

&lt;h2 id=&#34;äº‹æƒ…æ²¡é‚£ä¹ˆç®€å•&#34;&gt;äº‹æƒ…æ²¡é‚£ä¹ˆç®€å•&lt;/h2&gt;

&lt;p&gt;æˆ‘ä»¬æˆ‘ä»¬è¯¦ç»†æŸ¥çœ‹çš„è¯ï¼Œ&lt;code&gt;test_then_block&lt;/code&gt; -&amp;gt; &lt;code&gt;cond&lt;/code&gt; -&amp;gt; &lt;code&gt;luaK_goiftrue&lt;/code&gt;ï¼Œçœ‹çœ‹&lt;code&gt;luaK_goiftrue&lt;/code&gt;å‡½æ•°çš„å®ç°ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void luaK_goiftrue (FuncState *fs, expdesc *e) {
  int pc;  /* pc of last jump */
  luaK_dischargevars(fs, e);
  switch (e-&amp;gt;k) {
    case VK: case VKNUM: case VTRUE: {
      pc = NO_JUMP;  /* always true; do nothing */
      break;
    }
    case VFALSE: {
      pc = luaK_jump(fs);  /* always jump */
      break;
    }
    case VJMP: {
      invertjump(fs, e);
      pc = e-&amp;gt;u.s.info;
      break;
    }
    default: {
      pc = jumponcond(fs, e, 0);
      break;
    }
  }
  luaK_concat(fs, &amp;amp;e-&amp;gt;f, pc);  /* insert last jump in `f&#39; list */
  luaK_patchtohere(fs, e-&amp;gt;t);
  e-&amp;gt;t = NO_JUMP;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å‰é¢çš„å‡ ç§ï¼Œå¦‚VKã€VKNUMã€VTRUEéƒ½æ˜¯å§‹ç»ˆæˆç«‹çš„ï¼Œæ‰€ä»¥å…¶&lt;code&gt;e-&amp;gt;f&lt;/code&gt;æ˜¯ä¸å­˜åœ¨çš„ï¼Œå› æ­¤ä¸º&lt;code&gt;NO_JUMP&lt;/code&gt;ï¼Œè€Œå¯¹äº VFALSEï¼Œå…¶å§‹ç»ˆåº”è¯¥èµ°é”™è¯¯åˆ†æ”¯ï¼Œå› æ­¤å…¶&lt;code&gt;e-&amp;gt;f&lt;/code&gt;ä¸ºä¸€æ¡JMPã€‚&lt;code&gt;VJUMP&lt;/code&gt;æ˜¯æ¯”è¾ƒè¯­å¥ç”Ÿæˆçš„, æ‰€ä»¥å…¶å€¼å°±æ˜¯ä»£è¡¨äº†&lt;code&gt;e-&amp;gt;t&lt;/code&gt;å’Œ&lt;code&gt;e-&amp;gt;f&lt;/code&gt;ï¼Œå› æ­¤å…¶&lt;code&gt;e-&amp;gt;f&lt;/code&gt;
å°±æ˜¯&lt;code&gt;invertjump&lt;/code&gt;äº†ã€‚åœ¨å„ç§é”™è¯¯JMPéƒ½ç”Ÿæˆå®Œä¹‹åï¼Œæ¥ä¸‹æ¥å°±æ˜¯æ­£ç¡®åˆ†æ”¯äº†ï¼Œæ‰€ä»¥ç›´æ¥å°±&lt;code&gt;luaK_patchtohere&lt;/code&gt;äº†ï¼Œå½“å‰çš„å°±æ˜¯æ­£ç¡®çš„é€»è¾‘ã€‚&lt;/p&gt;

&lt;p&gt;æˆ‘ä»¬å…³æ³¨çš„é‡ç‚¹å…¶å®æ˜¯ &lt;code&gt;jumponcond&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static int jumponcond (FuncState *fs, expdesc *e, int cond) {
  if (e-&amp;gt;k == VRELOCABLE) {
    Instruction ie = getcode(fs, e);
    if (GET_OPCODE(ie) == OP_NOT) {
      fs-&amp;gt;pc--;  /* remove previous OP_NOT */
      return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
    }
    /* else go through */
  }
  discharge2anyreg(fs, e);
  freeexp(fs, e);
  return condjump(fs, OP_TESTSET, NO_REG, e-&amp;gt;u.s.info, cond);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å¯¹äº &lt;code&gt;if not xxxx then&lt;/code&gt;ä¹‹ç±»çš„è¯­å¥ï¼Œæ˜¾ç„¶å…¶åˆ¤æ–­ç»“æœå€¼ä¸ä¼šè¢«å¼•ç”¨ï¼ˆåªæ˜¯è¢«åˆ¤æ–­è¯­å¥ä½¿ç”¨è€Œå·²ï¼‰æ‰€ä»¥è¿™é‡Œä½¿ç”¨&lt;code&gt;OP_TEST&lt;/code&gt;ï¼Œå…¶ä»–æ‰€æœ‰æƒ…å†µ
éƒ½æ˜¯ä½¿ç”¨çš„&lt;code&gt;OP_TESTSET&lt;/code&gt;ã€‚æˆ‘ä»¬å¯ä»¥çœ‹çœ‹&lt;code&gt;TESTSET&lt;/code&gt;çš„å®šä¹‰ï¼š&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TESTSET A B C if (R(B) &amp;lt;=&amp;gt; C) then R(A) := R(B) else PC++&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Used to implement and and or logical operators, or for testing a single
register in a conditional statement.&lt;/p&gt;

&lt;p&gt;For TESTSET, register R(B) is coerced into a boolean and compared to
the boolean field C. If R(B) matches C, the next instruction is skipped,
otherwise R(B) is assigned to R(A) and the VM continues with the next
instruction. The and operator uses a C of 0 (false) while or uses a C value
of 1 (true).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;å¦‚æœ Bè½¬æ¢ä¸º booleanå å’Œ Cç›¸ç­‰ï¼Œåˆ™è·³è¿‡ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼›å¦åˆ™å°†Bèµ‹ç»™Aç„¶åç»§ç»­æ‰§è¡Œã€‚è¿™æ¡æŒ‡ä»¤çš„ç›®çš„æ˜¯ä¸ºçŸ­è·¯æ±‚å€¼æœåŠ¡çš„ã€‚é‚£ä¹ˆ&lt;code&gt;TESTSET&lt;/code&gt;æ€
ä¹ˆåˆ°åé¢å˜æˆäº†&lt;code&gt;TEST&lt;/code&gt;å‘¢ï¼Ÿå…¶è¿‡ç¨‹å°±åœ¨&lt;code&gt;dischargejpc&lt;/code&gt;-&amp;gt;&lt;code&gt;patchlistaux&lt;/code&gt;-&amp;gt;&lt;code&gt;patchtestreg&lt;/code&gt;ã€‚&lt;/p&gt;

&lt;p&gt;ä¸Šé¢æˆ‘ä»¬è¯´åˆ°&lt;code&gt;luaK_patchtohere&lt;/code&gt;å°†å¾…å®š&lt;code&gt;JMP&lt;/code&gt;æ”¹æˆå½“å‰pcçš„åŠŸèƒ½ï¼Œå…¶å®å¹¶ä¸æ˜¯ç›´æ¥ä¿®æ”¹çš„ï¼Œè€Œæ˜¯é€šè¿‡æ¯æ¬¡ç”Ÿæˆæ–°çš„å­—èŠ‚ç çš„æ—¶å€™ï¼Œè°ƒç”¨&lt;code&gt;dischargejpc&lt;/code&gt;å®ç°çš„ï¼Œpatch çš„æ—¶å€™åªæ˜¯å°†è¿™ä¸ªä½ç½®ä¸²èµ·æ¥ï¼Œç„¶å &lt;code&gt;dischargejpc&lt;/code&gt;ä¼šä¾¿åˆ©è¿™ä¸ªé“¾è¡¨è¿›è¡Œä¿®æ”¹&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;patchlistaux(fs, fs-&amp;gt;jpc, fs-&amp;gt;pc, NO_REG, fs-&amp;gt;pc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;é™¤æ­¤ä¹‹å¤–ï¼Œ&lt;code&gt;patchlistaux&lt;/code&gt;è¿˜è¿›è¡Œçš„ä¸€é¡¹æ“ä½œå°±æ˜¯&lt;code&gt;patchtestreg&lt;/code&gt;ï¼Œå®ƒçš„ä½œç”¨å°±æ˜¯å¤„ç†&lt;code&gt;TESTSET&lt;/code&gt;ï¼Œ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;131	static int patchtestreg (FuncState *fs, int node, int reg) {
132	  Instruction *i = getjumpcontrol(fs, node);
133	  if (GET_OPCODE(*i) != OP_TESTSET)
134	    return 0;  /* cannot patch other instructions */
135	  if (reg != NO_REG &amp;amp;&amp;amp; reg != GETARG_B(*i)) // å‰è€…è¡¨ç¤ºä¸éœ€è¦å¯„å­˜ï¼Œåè€…ä¸¤è€…ç›¸åŒçš„è¯ä¹Ÿæ˜¯ä¸éœ€è¦ä¿®æ”¹çš„
136	    SETARG_A(*i, reg);
137	  else  /* no register to put value or register already has the value */
138	    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i)); // å¯¹äºä¸éœ€è¦è¿”å›å€¼çš„æƒ…å†µï¼Œç›´æ¥ä¿®æ”¹ä¸º TEST
139	
140	  return 1;
141	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ä¸Šé¢çš„ä»‹ç»åªæ˜¯ æ¡ä»¶è¯­å¥çš„ä¸€éƒ¨åˆ†ï¼Œåé¢çš„æ–‡ç« ä¼šå¯¹çŸ­è·¯æ±‚å€¼ï¼Œcompare è¿ç®—ç¬¦ç­‰åšè§£é‡Šã€‚&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>