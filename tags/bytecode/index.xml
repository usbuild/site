<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bytecode on sysğŸ”±fork</title>
    <link>http://sysfork.com/tags/bytecode/</link>
    <description>Recent content in Bytecode on sysğŸ”±fork</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Thu, 25 May 2017 14:26:47 +0800</lastBuildDate>
    <atom:link href="http://sysfork.com/tags/bytecode/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>lua 5.1 åˆ†æ”¯è¯­å¥ bytecode çš„ç”Ÿæˆï¼ˆäºŒï¼‰</title>
      <link>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-2/</link>
      <pubDate>Thu, 25 May 2017 14:26:47 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-2/</guid>
      <description>&lt;p&gt;ä¸Šç¯‡æˆ‘ä»¬è°ˆåˆ°äº† IF è¯­å¥çš„ bytecode ç”Ÿæˆï¼Œä»Šå¤©æ¥è°ˆè°ˆå¸ƒå°”è¡¨è¾¾å¼ä¸çŸ­è·¯æ±‚å€¼ã€‚&lt;/p&gt;

&lt;p&gt;è€ƒè™‘åˆ°ä¸‹é¢çš„è¡¨è¾¾å¼&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;a = a or 1024
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶ç”Ÿæˆçš„å­—èŠ‚ç ä¸º&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1       [1]     GETGLOBAL       0 -1    ; a
2       [1]     TEST            0 0 1
3       [1]     JMP             1       ; to 5
4       [1]     LOADK           0 -2    ; 1024
5       [1]     SETGLOBAL       0 -1    ; a
6       [1]     RETURN          0 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶å®ä¸&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;if not a then
    a = 1024
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ç”Ÿæˆçš„ä»£ç å‡ ä¹ä¸€è‡´ï¼Œåªæ˜¯å°‘äº†åƒè‡ªå·±èµ‹å€¼çš„é‚£éƒ¨åˆ†ã€‚ç°åœ¨æˆ‘ä»¬çœ‹çœ‹è¿™æ¡çŸ­è·¯æ±‚å€¼è¯­å¥çš„å­—èŠ‚ç æ˜¯æ€ä¹ˆç”Ÿæˆçš„ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a = a or 1024&lt;/code&gt; è¿™æ˜¯ä¸€ä¸ªèµ‹å€¼è¯­å¥ï¼Œæ‰€ä»¥è°ƒç”¨ä½¿ç”¨çš„æ˜¯&lt;code&gt;assignment&lt;/code&gt;å‡½æ•°ï¼Œå…¶ä¸­æˆ‘ä»¬å…³æ³¨çš„è°ƒç”¨é“¾æ˜¯
&lt;code&gt;assignment -&amp;gt; luaK_storeevar -&amp;gt; luaK_exp2anyreg -&amp;gt; luaK_exp2nextreg -&amp;gt; exp2reg&lt;/code&gt; ç”±äº &lt;code&gt;a or 1024&lt;/code&gt;æ˜¯ä¸ªäºŒå…ƒè¿ç®—ç¬¦ï¼Œ
åœ¨ä»£ç ä¸­å¯ä»¥çœ‹åˆ°ï¼Œåœ¨è¯»åˆ°&lt;code&gt;or&lt;/code&gt;ä¹‹å‰æ˜¯&lt;code&gt;luaK_infix&lt;/code&gt;ï¼Œè¯»åˆ°&lt;code&gt;or&lt;/code&gt;ä¹‹åæ˜¯&lt;code&gt;luaK_postfix&lt;/code&gt;ï¼Œæˆ‘ä»¬çœ‹çœ‹ä¸¤è€…çš„åšæ³•ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- luaK_infix
716	    case OPR_OR: {
717	      luaK_goiffalse(fs, v);
718	      break;
719	    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;-- luaK_postfix
746	    case OPR_OR: {
747	      lua_assert(e1-&amp;gt;f == NO_JUMP);  /* list must be closed */
748	      luaK_dischargevars(fs, e2);
749	      luaK_concat(fs, &amp;amp;e2-&amp;gt;t, e1-&amp;gt;t);
750	      *e1 = *e2;
751	      break;
752	    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…³é”®è¿˜æ˜¯ä¸Šæ–‡è¯´åˆ°çš„&lt;code&gt;luaK_goiffalse&lt;/code&gt;ï¼Œ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;580	  luaK_concat(fs, &amp;amp;e-&amp;gt;t, pc);  /* insert last jump in `t&#39; list */
581	  luaK_patchtohere(fs, e-&amp;gt;f);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å¦‚æœè¿”å› true çš„è¯ï¼Œé‚£ä¹ˆè·³è½¬åˆ°æŸä¸ªâ€œæœªçŸ¥â€çš„åœ°æ–¹ï¼Œfalse çš„è¯ç›´æ¥æ‰§è¡Œä¸‹ä¸€å¥ã€‚é‚£ä¹ˆè¿™ä¸ªâ€œæœªçŸ¥â€çš„åœ°æ–¹æ˜¯æ€ä¹ˆç¡®å®šçš„å‘¢ï¼Ÿ
ç­”æ¡ˆåœ¨&lt;code&gt;exp2reg&lt;/code&gt;é‡Œé¢ã€‚&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;394	  if (hasjumps(e)) {
395	    int final;  /* position after whole expression */
396	    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
397	    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
398	    if (need_value(fs, e-&amp;gt;t) || need_value(fs, e-&amp;gt;f)) {
399	      int fj = (e-&amp;gt;k == VJMP) ? NO_JUMP : luaK_jump(fs);
400	      p_f = code_label(fs, reg, 0, 1);
401	      p_t = code_label(fs, reg, 1, 0);
402	      luaK_patchtohere(fs, fj);
403	    }
404	    final = luaK_getlabel(fs);
405	    patchlistaux(fs, e-&amp;gt;f, final, reg, p_f);
406	    patchlistaux(fs, e-&amp;gt;t, final, reg, p_t);
407	  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ç”±äºæˆ‘ä»¬è®¾ç½®äº†&lt;code&gt;e-&amp;gt;t&lt;/code&gt;æˆ–&lt;code&gt;e-&amp;gt;f&lt;/code&gt;ï¼Œæ‰€ä»¥&lt;code&gt;hasjumps&lt;/code&gt;åˆ¤æ–­æˆç«‹ã€‚ç”±äº&lt;code&gt;TESTSET&lt;/code&gt;å·²ç»æä¾›äº†èµ‹å€¼çš„å¯„å­˜å™¨ï¼Œå› æ­¤æ˜¯ä¸éœ€è¦é¢å¤–è®°å½•åˆ¤æ–­ç»“æœçš„ã€‚è€Œå¯¹äºå…¶ä»–çš„å…¥&lt;code&gt;LT&lt;/code&gt;ã€&lt;code&gt;JMP&lt;/code&gt;ç­‰ï¼Œå…¶æœ¬èº«æ˜¯ä¸è®°å½•ä»»ä½•åˆ¤æ–­ç»“æœçš„ï¼Œä¸ºäº†è®°å½•åªèƒ½åœ¨ JMP å®Œæˆä¹‹åï¼Œè®¾ç½®åˆ°å¯„å­˜å™¨ä¸­ï¼Œ
è¿™ä¹Ÿå°±æ˜¯æ­¤å¤„&lt;code&gt;code_label&lt;/code&gt;å­˜åœ¨çš„åŸå› ã€‚æ¥ä¸‹æ¥æ˜¯&lt;code&gt;patchlistaux&lt;/code&gt;ï¼Œå…¶å®šä¹‰å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;150	static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
151	                          int dtarget) {
152	  while (list != NO_JUMP) {
153	    int next = getjump(fs, list);
154	    if (patchtestreg(fs, list, reg))
155	      fixjump(fs, list, vtarget);
156	    else
157	      fixjump(fs, list, dtarget);  /* jump to default target */
158	    list = next;
159	  }
160	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶ä¸­ &lt;code&gt;patchtestreg&lt;/code&gt;å®šä¹‰å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;131	static int patchtestreg (FuncState *fs, int node, int reg) {
132	  Instruction *i = getjumpcontrol(fs, node);
133	  if (GET_OPCODE(*i) != OP_TESTSET)
134	    return 0;  /* cannot patch other instructions */
135	  if (reg != NO_REG &amp;amp;&amp;amp; reg != GETARG_B(*i))
136	    SETARG_A(*i, reg);
137	  else  /* no register to put value or register already has the value */
138	    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));
139	
140	  return 1;
141	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶ä¸­&lt;code&gt;vtarget&lt;/code&gt;æ˜¯æˆ‘ä»¬å½“å‰çš„ä½ç½®&lt;code&gt;final&lt;/code&gt;ï¼Œè€Œ&lt;code&gt;dtarget&lt;/code&gt;æ˜¯&lt;code&gt;p_f&lt;/code&gt;æˆ–&lt;code&gt;p_t&lt;/code&gt;ã€‚è¿™ä¸¤æ¡è¯­å¥çš„ä½œç”¨å…¶å®æ˜¯å°†æœ€ç»ˆ&lt;code&gt;TESTSET&lt;/code&gt;æŒ‡ä»¤çš„ç»“æœä¼ é€åˆ°&lt;code&gt;reg&lt;/code&gt;ï¼Œ
å¦‚æœä¸æ˜¯&lt;code&gt;TESTSET&lt;/code&gt;çš„è¯é‚£ä¹ˆè¯´æ˜ä¸äº§ç”Ÿå€¼ï¼Œé‚£&lt;code&gt;reg&lt;/code&gt;å°±éœ€è¦ä¸Šé¢çš„&lt;code&gt;codelabel&lt;/code&gt;æ¥äº§ç”Ÿäº†ã€‚è‡³æ­¤è¿™éƒ¨åˆ†ä»£ç åˆ†æå®Œæˆã€‚&lt;/p&gt;

&lt;p&gt;ä¸‹é¢æ˜¯ä¸€äº›å‡½æ•°çš„ç®€å•è§£é‡Šï¼Œå¯ä»¥ç¨å¾®çœ‹çœ‹ï¼š&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaK_nil&lt;/code&gt;å‡½æ•°ï¼Œç”Ÿæˆçš„æ˜¯&lt;code&gt;LOADNIL&lt;/code&gt;å­—èŠ‚ç ï¼Œå…¶ä½œç”¨æ˜¯å°†from ~ from + nä¹‹é—´çš„å¯„å­˜å™¨è®¾ç½®æˆnilï¼Œè¿™é‡Œåšäº†ä¸€äº›ä¼˜åŒ–å¦‚ï¼šå¦‚æœåˆå¹¶ç›¸é‚»çš„&lt;code&gt;LOADNIL&lt;/code&gt;ï¼Œå‡½æ•°åˆå§‹åŒ–æ—¶å¯ä»¥ä¸éœ€è¦é‡å¤åˆå§‹åŒ–ç­‰ã€‚
æ³¨æ„ä¼˜åŒ–çš„å‰ææ˜¯&lt;code&gt;fs-&amp;gt;pc &amp;gt; fs-&amp;gt;lasttarget&lt;/code&gt;ï¼Œå³è¿™æ¡æŒ‡ä»¤å¿…é¡»å¯ä»¥çœç•¥ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaK_jump&lt;/code&gt;å‡½æ•°ï¼Œå…¶ç›®çš„æ˜¯ç”Ÿæˆä¸€ä¸ª&lt;code&gt;JMP&lt;/code&gt;æŒ‡ä»¤ã€‚è¿™æ˜¯ä¸ªæ— æ¡ä»¶è·³è½¬æŒ‡ä»¤ã€‚é‚£ä¹ˆå…¶ç›®æ ‡å‘¢ï¼Ÿå…¶å®å°±æ˜¯ &lt;code&gt;fs-&amp;gt;jps&lt;/code&gt;ã€‚æ³¨æ„åé¢çš„&lt;code&gt;luaK_contat&lt;/code&gt;ï¼Œå…¶ç›®çš„æ˜¯å°†l2é“¾æ¥åˆ°l1çš„åé¢ï¼Œè¿™æ˜¯ä¸ºäº†è¿ç»­è·³è½¬
è€ƒè™‘çš„ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;condjump&lt;/code&gt; ç”Ÿæˆæ¡ä»¶è·³è½¬è¯­å¥ï¼Œluaä¸ºäº†ç”Ÿæˆå­—èŠ‚ç çš„ä¾¿åˆ©æ€§ï¼Œæ¯ä¸ªæ¡ä»¶è°ƒè½¬è¯­å¥å¦‚&lt;code&gt;LT&lt;/code&gt;, &lt;code&gt;TEST&lt;/code&gt;ç­‰åé¢éƒ½è·Ÿç€ä¸€ä¸ª&lt;code&gt;JMP&lt;/code&gt;ï¼Œå½“æ¡ä»¶ä¸æ»¡è¶³æ—¶ç›´æ¥æŒ‡å‘&lt;code&gt;JMP&lt;/code&gt;è¯­å¥ï¼Œå¦åˆ™å°±è·³åˆ°&lt;code&gt;JMP&lt;/code&gt;çš„ä¸‹ä¸€æ¡ï¼Œ
å‡å°‘äº†ç¼–ç çš„å¤æ‚åº¦å•Š&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fixjump&lt;/code&gt;æŠŠ&lt;code&gt;PC&lt;/code&gt;å¤„çš„æŒ‡ä»¤ï¼ˆå½“ç„¶æ˜¯JMPæŒ‡ä»¤ï¼‰æ”¹æˆç›®æ ‡ä¸º&lt;code&gt;dest&lt;/code&gt;ï¼Œå½“ç„¶æ˜¯ç›¸å¯¹åœ°å€äº†&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaK_getlabel&lt;/code&gt;ï¼Œæ ‡è®°ä¸€ä¸‹ï¼ŒæŠŠå½“å‰çš„lasttargetæ”¹æˆpcï¼Œè¿™ä¸ªlasttargetå°±æ˜¯å’Œä¸Šé¢çš„&lt;code&gt;luaK_nil&lt;/code&gt;ç»“åˆèµ·æ¥çš„ï¼Œé˜²æ­¢ä¸Šé¢çš„è¯¯ä¼˜åŒ–ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getjump&lt;/code&gt;å’Œä¸Šé¢çš„fixjumpç›¸å¯¹åº”ï¼Œè¿”å›PCæ‰€åœ¨é‚£æ¡æŒ‡ä»¤çš„è·³è½¬ç›®æ ‡ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getjumpcontrol&lt;/code&gt; ç”±äº&lt;code&gt;JMP&lt;/code&gt;ä¸Šä¸€æ¡å¾ˆå¤šæƒ…å†µä¸‹éƒ½æ˜¯è·Ÿç€æ¡ä»¶è·³è½¬æŒ‡ä»¤çš„ï¼Œé‚£ä¹ˆè¿™æ¡æŒ‡ä»¤å°±æ˜¯è·å–è¿™æ¡æ¡ä»¶è·³è½¬æŒ‡ä»¤çš„ã€‚å¦‚æœæ˜¯é‚£ä¹ˆè¿”å›ä¸Šä¸€æ¡ï¼Œå¦åˆ™è¿”å›å½“å‰pcã€‚é™¤äº†&lt;code&gt;jmp&lt;/code&gt;ä¹‹å¤–ï¼Œå…¶ä»–å¦‚&lt;code&gt;FORLOOP&lt;/code&gt;, &lt;code&gt;FORPREP&lt;/code&gt;ç­‰æŒ‡ä»¤ä¹Ÿä¼šäº§ç”Ÿè·³è½¬&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchtestreg&lt;/code&gt; ä¿®æ”¹&lt;code&gt;TESTSET&lt;/code&gt;æŒ‡ä»¤ï¼Œè¿™ä¸ªæŒ‡ä»¤ä¸€èˆ¬ç”¨äºçŸ­è·¯æ±‚å€¼ï¼Œ&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchlistaux&lt;/code&gt; å¯¹äºä¸€ä¸ªjump listï¼Œå¦‚æœæ˜¯&lt;code&gt;TESTSET&lt;/code&gt;ï¼Œé‚£ä¹ˆå°†èµ‹å€¼å¯„å­˜å™¨ä¿®æ”¹ä¸ºregå¹¶å°†jumpç›®çš„åœ°ä¿®æ”¹ä¸ºvtarget, å¦åˆ™ä¿®æ”¹ä¸ºdtargetã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dischargejpc&lt;/code&gt; å¯¹jpcè¿›è¡Œ&lt;code&gt;patchlistaux&lt;/code&gt;ï¼Œå…¶ä¸­vtargetå’Œdtargetéƒ½æ˜¯pc&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchlist&lt;/code&gt; å¦‚æœtargetä¸ºpcï¼Œé‚£ä¹ˆè°ƒç”¨patchtohereï¼›å¦åˆ™è°ƒç”¨patchlistaux&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchtohere&lt;/code&gt;å…ˆgetlabelæ ‡è®°ä¸€ä¸‹ï¼Œç„¶åå°†å½“å‰çš„listæ”¾åˆ°jpcåé¢&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jpc&lt;/code&gt;é‚£äº›å°†è¦è·³åˆ°å½“å‰ä½ç½®çš„é“¾è¡¨ï¼Œç”±äºæ‰€æœ‰codeçš„å¢åŠ çš„æ¬§å¼&lt;code&gt;luaK_code&lt;/code&gt;ï¼Œæ‰€ä»¥ä¼šåœ¨è¿™ä¸ªå‡½æ•°ä¸­è°ƒç”¨&lt;code&gt;dischargejpc&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lua 5.1 åˆ†æ”¯è¯­å¥ bytecode çš„ç”Ÿæˆï¼ˆä¸€ï¼‰</title>
      <link>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-1/</link>
      <pubDate>Sat, 20 May 2017 15:57:13 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-1/</guid>
      <description>

&lt;p&gt;æœ¬æ–‡åªå¯¹ &lt;code&gt;IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END&lt;/code&gt; è¯­æ³•çš„å­—èŠ‚ç ç”Ÿæˆè¿‡ç¨‹è¿›è¡Œæè¿°ã€‚&lt;/p&gt;

&lt;h2 id=&#34;ç”Ÿæˆçš„ç»“æœ&#34;&gt;ç”Ÿæˆçš„ç»“æœ&lt;/h2&gt;

&lt;p&gt;é¦–å…ˆæˆ‘ä»¬çœ‹ä¸‹é¢çš„ç¤ºä¾‹ï¼Œä»…ä¸ºæ¼”ç¤ºï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local cond1 = true
local cond2 = true
if cond1 then
    cond1 = false
elseif cond2 then
    cond2 = false
else
    cond1 = false
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ä½¿ç”¨&lt;code&gt;luac -l -l&lt;/code&gt;é€‰é¡¹åˆ—å‡ºæ¥çš„ç»“æœä¸º&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main &amp;lt;test.lua:0,0&amp;gt; (12 instructions, 48 bytes at 0x184e530)
0+ params, 2 slots, 0 upvalues, 2 locals, 0 constants, 0 functions
        1       [1]     LOADBOOL        0 1 0
        2       [2]     LOADBOOL        1 1 0
        3       [3]     TEST            0 0 0
        4       [3]     JMP             2       ; to 7
        5       [4]     LOADBOOL        0 0 0
        6       [4]     JMP             5       ; to 12
        7       [5]     TEST            1 0 0
        8       [5]     JMP             2       ; to 11
        9       [6]     LOADBOOL        1 0 0
        10      [6]     JMP             1       ; to 12
        11      [8]     LOADBOOL        0 0 0
        12      [9]     RETURN          0 1
constants (0) for 0x184e530:
locals (2) for 0x184e530:
        0       cond1   2       12
        1       cond2   3       12
upvalues (0) for 0x184e530:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è¿™é‡Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æœ€ç»ˆçš„ç”Ÿæˆç»“æœã€‚æˆ‘ä»¬å…³æ³¨çš„æ˜¯å…¶ä¸­çš„&lt;code&gt;TEST&lt;/code&gt;å’Œ&lt;code&gt;JUMP&lt;/code&gt;ã€‚åœ¨ç¬¬3è¡Œçš„&lt;code&gt;TEST&lt;/code&gt;ï¼Œå…¶æ„æ€æ˜¯å¦‚æœ0å·å¯„å­˜å™¨ä¸­çš„å†…å®¹(cond1)
ä¸ºfalse(0)çš„è¯ï¼Œé‚£ä¹ˆå°±æ‰§è¡Œä¸‹é¢çš„&lt;code&gt;JMP&lt;/code&gt;è¯­å¥ï¼Œå¦åˆ™å°±è°ƒè¿‡&lt;code&gt;JMP&lt;/code&gt;ç›´æ¥åˆ°ç¬¬5è¡Œã€‚&lt;code&gt;LUA&lt;/code&gt;ä¸­çš„åˆ†æ”¯å®ç°éƒ½æ˜¯ä½¿ç”¨&lt;code&gt;TEST&lt;/code&gt;ç­‰åé¢ç´§è·Ÿ&lt;code&gt;JMP&lt;/code&gt;å®ç°çš„ï¼Œ
ä»ä¸» dispatch ä»£ç ä¸­å¯ä»¥çœ‹åˆ°&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // ...
      case OP_TEST: {
        if (l_isfalse(ra) != GETARG_C(i))
          dojump(L, pc, GETARG_sBx(*pc));
        pc++;
        continue;
      }
      case OP_TESTSET: {
        TValue *rb = RB(i);
        if (l_isfalse(rb) != GETARG_C(i)) {
          setobjs2s(L, ra, rb);
          dojump(L, pc, GETARG_sBx(*pc));
        }
        pc++;
        continue;
      }
      // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;JMP&lt;/code&gt;è·³è½¬ï¼Œæ°¸è¿œéƒ½æ˜¯åˆ†æ”¯ä¸æˆç«‹çš„æƒ…å†µï¼Œè€Œ&lt;code&gt;TEST&lt;/code&gt;æˆåŠŸåçš„è·³è½¬æ°¸è¿œæ˜¯è·³è¿‡ä¸‹ä¸€è¡Œï¼Œå¤±è´¥çš„è¯ç»§ç»­æ‰§è¡Œæ¥ä¸‹æ¥çš„JMPã€‚&lt;code&gt;if&lt;/code&gt;è¯­å¥çš„å­—èŠ‚ç è§£æå°±åˆ°è¿™é‡Œï¼Œåé¢çš„&lt;code&gt;elseif&lt;/code&gt;ç­‰éƒ½æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œå†äº†è§£è¿™ä¸ªäº‹å®ä¹‹åã€‚
é‚£ä¹ˆè¿™ç§å­—èŠ‚ç æ˜¯æ€ä¹ˆç”Ÿæˆçš„å‘¢ï¼Ÿä¸‹é¢æ¥åˆ†æä¸‹ã€‚&lt;/p&gt;

&lt;h2 id=&#34;ç”Ÿæˆçš„è¿‡ç¨‹&#34;&gt;ç”Ÿæˆçš„è¿‡ç¨‹&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt;è¯­å¥çš„ä»£ç åœ¨&lt;code&gt;lparser.c&lt;/code&gt;é‡Œé¢ï¼Œæœ€ä¸Šå±‚å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void ifstat (LexState *ls, int line) {
  /* ifstat -&amp;gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
  FuncState *fs = ls-&amp;gt;fs;
  int flist;
  int escapelist = NO_JUMP;
  flist = test_then_block(ls);  /* IF cond THEN block */
  while (ls-&amp;gt;t.token == TK_ELSEIF) {
    luaK_concat(fs, &amp;amp;escapelist, luaK_jump(fs)); // å°† escapelist ä¸²èµ·æ¥ï¼Œè¿™é‡Œçš„ luaK_jump ä¼šè·³è½¬åˆ° end
    luaK_patchtohere(fs, flist); // æŠŠä¸Šé¢é‚£ä¸ª`JMP(1/3)` åœ°å€ä¿®æ”¹å¯¹
    flist = test_then_block(ls);  /* ELSEIF cond THEN block */
  }
  if (ls-&amp;gt;t.token == TK_ELSE) {
    luaK_concat(fs, &amp;amp;escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    luaX_next(ls);  /* skip ELSE (after patch, for correct line info) */
    block(ls);  /* `else&#39; part */
  }
  else
    luaK_concat(fs, &amp;amp;escapelist, flist); // è¿™é‡ŒæŠŠ flist ä¸²èµ·æ¥äº†ï¼Œæ„æ€æ˜¯æ²¡æœ‰ else è¯­å¥ï¼Œæ­¤æ—¶ flist æŒ‡å‘å°±æ˜¯ end
  luaK_patchtohere(fs, escapelist); // ä¿®æ”¹ escapelist åˆ° end è¯­å¥çš„ç»“å°¾
  check_match(ls, TK_END, TK_IF, line);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;åœ¨è¯»å– token çš„æ—¶å€™ï¼Œé‡åˆ° &lt;code&gt;if ... then&lt;/code&gt; ä¼šç”Ÿæˆ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TEST reg 0 predict
JMP ??? (1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ç”±äºæˆ‘ä»¬ä¸çŸ¥é“åé¢ä»£ç çš„å†…å®¹ï¼Œæ‰€ä»¥æ— æ³•ç¡®å®š&lt;code&gt;???&lt;/code&gt;è¯¥å¡«å†™å¤šå°‘ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯è¦è®°ä½è¿™ä¸ªä½ç½®ï¼Œå°†æ¥æˆ‘ä»¬è¦æŠŠå€¼å¡«å†™è¿›å»ï¼Œè¿™ä¸ªå€¼å…¶å®å°±å­˜
åœ¨&lt;code&gt;flist&lt;/code&gt;ã€‚ç„¶åæˆ‘ä»¬è¯»åˆ°&lt;code&gt;elseif cond then&lt;/code&gt;è¯­å¥ï¼Œè¿™å°±æ„å‘³ç€ç¬¬ä¸€æ®µä»£ç çš„ç»“æŸæ­¤æ—¶åº”è¯¥è¦è·³è½¬å‡ºè¿™ä¸ª&lt;code&gt;if&lt;/code&gt;
è¯­å¥ï¼Œæ‰€ä»¥æ­¤æ—¶åº”è¯¥æ’å…¥ä¸€ä¸ª&lt;code&gt;JMP(2)&lt;/code&gt;åˆ°æ•´ä¸ªè¯­å¥çš„ç»“æŸï¼Œå› ä¸ºæœ‰å¤šä¸ª block çš„å­˜åœ¨ï¼Œåé¢å¯èƒ½ä¼šæœ‰å¾ˆå¤šè¿™ç§ç±»ä¼¼çš„
&lt;code&gt;JMP&lt;/code&gt;ï¼Œå¦‚ä¸Šé¢ç¤ºä¾‹ä¸­çš„å„ç§&lt;code&gt;to 12&lt;/code&gt;ï¼Œè¿™äº›ä½ç½®éƒ½æ— æ³•ç¡®å®šï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªescapelistæ¥æŒ‡å‘è¿™ä¸ªåœ°å€ï¼Œæ–¹ä¾¿åé¢å¤„ç†ã€‚
ç°åœ¨å›å¤´çœ‹&lt;code&gt;JMP(1)&lt;/code&gt;ä½ç½®å°±ç¡®å®šäº†ï¼Œæ‰€ä»¥å½“å‰çš„PCå°±æ˜¯&lt;code&gt;flist&lt;/code&gt;çš„æŒ‡å‘ç”±äº&lt;code&gt;elseif&lt;/code&gt;åˆæ˜¯ä¸€ä¸ªåˆ†æ”¯è¯­å¥ï¼Œæ‰€ä»¥åˆå¯ä»¥ç”Ÿæˆä¸€æ®µ &lt;code&gt;TEST &amp;amp; JMP(3)&lt;/code&gt;ä»£ç äº†ã€‚åŒæ ·&lt;code&gt;JMP(2)&lt;/code&gt;çš„ä½ç½®æ˜¯æ— æ³•ç¡®å®šçš„ã€‚
ç°åœ¨æ¥è°ˆè°ˆ&lt;code&gt;escapelist&lt;/code&gt;ï¼Œå®šä¹‰&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int escapelist = NO_JUMP;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è¿™æ˜¯ä¸ª int å•Šï¼Œå¯¹äºå¤šä¸ªä½ç½®çš„&lt;code&gt;JMP(2)&lt;/code&gt;è¦æ€ä¹ˆå¤„ç†ï¼Ÿlua é‡‡ç”¨äº†ä¸€ç§å·§å¦™çš„æœºåˆ¶ï¼Œç”±äºæ­¤æ—¶çš„&lt;code&gt;JMP&lt;/code&gt;æ˜¯æ— æ•ˆçš„ï¼Œè¿˜æ²¡æœ‰è§£æåˆ°æ­£å¼åœ°å€çš„ï¼Œ
æ‰€ä»¥å…¶ä¸­çš„ç›®æ ‡åœ°å€åŸŸæ˜¯æ²¡æœ‰ä½¿ç”¨çš„ã€‚å› æ­¤ï¼Œå¯ä»¥é‡‡ç”¨ä¸²èµ·æ¥çš„æ–¹å¼ï¼ŒescapcelistæŒ‡å‘ç¬¬ä¸€ä¸ªæ²¡æœ‰è§£æçš„&lt;code&gt;JMP&lt;/code&gt;ï¼Œç„¶åè¿™ä¸ª&lt;code&gt;JMP&lt;/code&gt;çš„æŒ‡å‘åœ°å€
æ˜¯ä¸‹ä¸€ä¸ªæ²¡æœ‰è§£æçš„&lt;code&gt;JMP&lt;/code&gt;ï¼Œè¿™æ ·ä¸€æ¥å°±å½¢æˆäº†é“¾è¡¨çš„ç»“æ„ã€‚åé¢å¯ä»¥ä¸€èµ·ä¿®æ”¹ç›®æ ‡åœ°å€é€šè¿‡&lt;code&gt;luaK_patchtohere&lt;/code&gt;æ¥å®ç°ã€‚&lt;/p&gt;

&lt;h2 id=&#34;äº‹æƒ…æ²¡é‚£ä¹ˆç®€å•&#34;&gt;äº‹æƒ…æ²¡é‚£ä¹ˆç®€å•&lt;/h2&gt;

&lt;p&gt;æˆ‘ä»¬æˆ‘ä»¬è¯¦ç»†æŸ¥çœ‹çš„è¯ï¼Œ&lt;code&gt;test_then_block&lt;/code&gt; -&amp;gt; &lt;code&gt;cond&lt;/code&gt; -&amp;gt; &lt;code&gt;luaK_goiftrue&lt;/code&gt;ï¼Œçœ‹çœ‹&lt;code&gt;luaK_goiftrue&lt;/code&gt;å‡½æ•°çš„å®ç°ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void luaK_goiftrue (FuncState *fs, expdesc *e) {
  int pc;  /* pc of last jump */
  luaK_dischargevars(fs, e);
  switch (e-&amp;gt;k) {
    case VK: case VKNUM: case VTRUE: {
      pc = NO_JUMP;  /* always true; do nothing */
      break;
    }
    case VFALSE: {
      pc = luaK_jump(fs);  /* always jump */
      break;
    }
    case VJMP: {
      invertjump(fs, e);
      pc = e-&amp;gt;u.s.info;
      break;
    }
    default: {
      pc = jumponcond(fs, e, 0);
      break;
    }
  }
  luaK_concat(fs, &amp;amp;e-&amp;gt;f, pc);  /* insert last jump in `f&#39; list */
  luaK_patchtohere(fs, e-&amp;gt;t);
  e-&amp;gt;t = NO_JUMP;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å‰é¢çš„å‡ ç§ï¼Œå¦‚VKã€VKNUMã€VTRUEéƒ½æ˜¯å§‹ç»ˆæˆç«‹çš„ï¼Œæ‰€ä»¥å…¶&lt;code&gt;e-&amp;gt;f&lt;/code&gt;æ˜¯ä¸å­˜åœ¨çš„ï¼Œå› æ­¤ä¸º&lt;code&gt;NO_JUMP&lt;/code&gt;ï¼Œè€Œå¯¹äº VFALSEï¼Œå…¶å§‹ç»ˆåº”è¯¥èµ°é”™è¯¯åˆ†æ”¯ï¼Œå› æ­¤å…¶&lt;code&gt;e-&amp;gt;f&lt;/code&gt;ä¸ºä¸€æ¡JMPã€‚&lt;code&gt;VJUMP&lt;/code&gt;æ˜¯æ¯”è¾ƒè¯­å¥ç”Ÿæˆçš„, æ‰€ä»¥å…¶å€¼å°±æ˜¯ä»£è¡¨äº†&lt;code&gt;e-&amp;gt;t&lt;/code&gt;å’Œ&lt;code&gt;e-&amp;gt;f&lt;/code&gt;ï¼Œå› æ­¤å…¶&lt;code&gt;e-&amp;gt;f&lt;/code&gt;
å°±æ˜¯&lt;code&gt;invertjump&lt;/code&gt;äº†ã€‚åœ¨å„ç§é”™è¯¯JMPéƒ½ç”Ÿæˆå®Œä¹‹åï¼Œæ¥ä¸‹æ¥å°±æ˜¯æ­£ç¡®åˆ†æ”¯äº†ï¼Œæ‰€ä»¥ç›´æ¥å°±&lt;code&gt;luaK_patchtohere&lt;/code&gt;äº†ï¼Œå½“å‰çš„å°±æ˜¯æ­£ç¡®çš„é€»è¾‘ã€‚&lt;/p&gt;

&lt;p&gt;æˆ‘ä»¬å…³æ³¨çš„é‡ç‚¹å…¶å®æ˜¯ &lt;code&gt;jumponcond&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static int jumponcond (FuncState *fs, expdesc *e, int cond) {
  if (e-&amp;gt;k == VRELOCABLE) {
    Instruction ie = getcode(fs, e);
    if (GET_OPCODE(ie) == OP_NOT) {
      fs-&amp;gt;pc--;  /* remove previous OP_NOT */
      return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
    }
    /* else go through */
  }
  discharge2anyreg(fs, e);
  freeexp(fs, e);
  return condjump(fs, OP_TESTSET, NO_REG, e-&amp;gt;u.s.info, cond);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å¯¹äº &lt;code&gt;if not xxxx then&lt;/code&gt;ä¹‹ç±»çš„è¯­å¥ï¼Œæ˜¾ç„¶å…¶åˆ¤æ–­ç»“æœå€¼ä¸ä¼šè¢«å¼•ç”¨ï¼ˆåªæ˜¯è¢«åˆ¤æ–­è¯­å¥ä½¿ç”¨è€Œå·²ï¼‰æ‰€ä»¥è¿™é‡Œä½¿ç”¨&lt;code&gt;OP_TEST&lt;/code&gt;ï¼Œå…¶ä»–æ‰€æœ‰æƒ…å†µ
éƒ½æ˜¯ä½¿ç”¨çš„&lt;code&gt;OP_TESTSET&lt;/code&gt;ã€‚æˆ‘ä»¬å¯ä»¥çœ‹çœ‹&lt;code&gt;TESTSET&lt;/code&gt;çš„å®šä¹‰ï¼š&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TESTSET A B C if (R(B) &amp;lt;=&amp;gt; C) then R(A) := R(B) else PC++&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Used to implement and and or logical operators, or for testing a single
register in a conditional statement.&lt;/p&gt;

&lt;p&gt;For TESTSET, register R(B) is coerced into a boolean and compared to
the boolean field C. If R(B) matches C, the next instruction is skipped,
otherwise R(B) is assigned to R(A) and the VM continues with the next
instruction. The and operator uses a C of 0 (false) while or uses a C value
of 1 (true).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;å¦‚æœ Bè½¬æ¢ä¸º booleanå å’Œ Cç›¸ç­‰ï¼Œåˆ™è·³è¿‡ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼›å¦åˆ™å°†Bèµ‹ç»™Aç„¶åç»§ç»­æ‰§è¡Œã€‚è¿™æ¡æŒ‡ä»¤çš„ç›®çš„æ˜¯ä¸ºçŸ­è·¯æ±‚å€¼æœåŠ¡çš„ã€‚é‚£ä¹ˆ&lt;code&gt;TESTSET&lt;/code&gt;æ€
ä¹ˆåˆ°åé¢å˜æˆäº†&lt;code&gt;TEST&lt;/code&gt;å‘¢ï¼Ÿå…¶è¿‡ç¨‹å°±åœ¨&lt;code&gt;dischargejpc&lt;/code&gt;-&amp;gt;&lt;code&gt;patchlistaux&lt;/code&gt;-&amp;gt;&lt;code&gt;patchtestreg&lt;/code&gt;ã€‚&lt;/p&gt;

&lt;p&gt;ä¸Šé¢æˆ‘ä»¬è¯´åˆ°&lt;code&gt;luaK_patchtohere&lt;/code&gt;å°†å¾…å®š&lt;code&gt;JMP&lt;/code&gt;æ”¹æˆå½“å‰pcçš„åŠŸèƒ½ï¼Œå…¶å®å¹¶ä¸æ˜¯ç›´æ¥ä¿®æ”¹çš„ï¼Œè€Œæ˜¯é€šè¿‡æ¯æ¬¡ç”Ÿæˆæ–°çš„å­—èŠ‚ç çš„æ—¶å€™ï¼Œè°ƒç”¨&lt;code&gt;dischargejpc&lt;/code&gt;å®ç°çš„ï¼Œpatch çš„æ—¶å€™åªæ˜¯å°†è¿™ä¸ªä½ç½®ä¸²èµ·æ¥ï¼Œç„¶å &lt;code&gt;dischargejpc&lt;/code&gt;ä¼šä¾¿åˆ©è¿™ä¸ªé“¾è¡¨è¿›è¡Œä¿®æ”¹&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;patchlistaux(fs, fs-&amp;gt;jpc, fs-&amp;gt;pc, NO_REG, fs-&amp;gt;pc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;é™¤æ­¤ä¹‹å¤–ï¼Œ&lt;code&gt;patchlistaux&lt;/code&gt;è¿˜è¿›è¡Œçš„ä¸€é¡¹æ“ä½œå°±æ˜¯&lt;code&gt;patchtestreg&lt;/code&gt;ï¼Œå®ƒçš„ä½œç”¨å°±æ˜¯å¤„ç†&lt;code&gt;TESTSET&lt;/code&gt;ï¼Œ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;131	static int patchtestreg (FuncState *fs, int node, int reg) {
132	  Instruction *i = getjumpcontrol(fs, node);
133	  if (GET_OPCODE(*i) != OP_TESTSET)
134	    return 0;  /* cannot patch other instructions */
135	  if (reg != NO_REG &amp;amp;&amp;amp; reg != GETARG_B(*i)) // å‰è€…è¡¨ç¤ºä¸éœ€è¦å¯„å­˜ï¼Œåè€…ä¸¤è€…ç›¸åŒçš„è¯ä¹Ÿæ˜¯ä¸éœ€è¦ä¿®æ”¹çš„
136	    SETARG_A(*i, reg);
137	  else  /* no register to put value or register already has the value */
138	    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i)); // å¯¹äºä¸éœ€è¦è¿”å›å€¼çš„æƒ…å†µï¼Œç›´æ¥ä¿®æ”¹ä¸º TEST
139	
140	  return 1;
141	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ä¸Šé¢çš„ä»‹ç»åªæ˜¯ æ¡ä»¶è¯­å¥çš„ä¸€éƒ¨åˆ†ï¼Œåé¢çš„æ–‡ç« ä¼šå¯¹çŸ­è·¯æ±‚å€¼ï¼Œcompare è¿ç®—ç¬¦ç­‰åšè§£é‡Šã€‚&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>