<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bytecode on sys🔱fork</title>
    <link>http://sysfork.com/tags/bytecode/</link>
    <description>Recent content in Bytecode on sys🔱fork</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Thu, 25 May 2017 14:26:47 +0800</lastBuildDate>
    <atom:link href="http://sysfork.com/tags/bytecode/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>lua 5.1 分支语句 bytecode 的生成（二）</title>
      <link>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-2/</link>
      <pubDate>Thu, 25 May 2017 14:26:47 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-2/</guid>
      <description>&lt;p&gt;上篇我们谈到了 IF 语句的 bytecode 生成，今天来谈谈布尔表达式与短路求值。&lt;/p&gt;

&lt;p&gt;考虑到下面的表达式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;a = a or 1024
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其生成的字节码为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1       [1]     GETGLOBAL       0 -1    ; a
2       [1]     TEST            0 0 1
3       [1]     JMP             1       ; to 5
4       [1]     LOADK           0 -2    ; 1024
5       [1]     SETGLOBAL       0 -1    ; a
6       [1]     RETURN          0 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实与&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;if not a then
    a = 1024
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成的代码几乎一致，只是少了像自己赋值的那部分。现在我们看看这条短路求值语句的字节码是怎么生成的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a = a or 1024&lt;/code&gt; 这是一个赋值语句，所以调用使用的是&lt;code&gt;assignment&lt;/code&gt;函数，其中我们关注的调用链是
&lt;code&gt;assignment -&amp;gt; luaK_storeevar -&amp;gt; luaK_exp2anyreg -&amp;gt; luaK_exp2nextreg -&amp;gt; exp2reg&lt;/code&gt; 由于 &lt;code&gt;a or 1024&lt;/code&gt;是个二元运算符，
在代码中可以看到，在读到&lt;code&gt;or&lt;/code&gt;之前是&lt;code&gt;luaK_infix&lt;/code&gt;，读到&lt;code&gt;or&lt;/code&gt;之后是&lt;code&gt;luaK_postfix&lt;/code&gt;，我们看看两者的做法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- luaK_infix
716	    case OPR_OR: {
717	      luaK_goiffalse(fs, v);
718	      break;
719	    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;-- luaK_postfix
746	    case OPR_OR: {
747	      lua_assert(e1-&amp;gt;f == NO_JUMP);  /* list must be closed */
748	      luaK_dischargevars(fs, e2);
749	      luaK_concat(fs, &amp;amp;e2-&amp;gt;t, e1-&amp;gt;t);
750	      *e1 = *e2;
751	      break;
752	    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键还是上文说到的&lt;code&gt;luaK_goiffalse&lt;/code&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;580	  luaK_concat(fs, &amp;amp;e-&amp;gt;t, pc);  /* insert last jump in `t&#39; list */
581	  luaK_patchtohere(fs, e-&amp;gt;f);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果返回 true 的话，那么跳转到某个“未知”的地方，false 的话直接执行下一句。那么这个“未知”的地方是怎么确定的呢？
答案在&lt;code&gt;exp2reg&lt;/code&gt;里面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;394	  if (hasjumps(e)) {
395	    int final;  /* position after whole expression */
396	    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
397	    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
398	    if (need_value(fs, e-&amp;gt;t) || need_value(fs, e-&amp;gt;f)) {
399	      int fj = (e-&amp;gt;k == VJMP) ? NO_JUMP : luaK_jump(fs);
400	      p_f = code_label(fs, reg, 0, 1);
401	      p_t = code_label(fs, reg, 1, 0);
402	      luaK_patchtohere(fs, fj);
403	    }
404	    final = luaK_getlabel(fs);
405	    patchlistaux(fs, e-&amp;gt;f, final, reg, p_f);
406	    patchlistaux(fs, e-&amp;gt;t, final, reg, p_t);
407	  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们设置了&lt;code&gt;e-&amp;gt;t&lt;/code&gt;或&lt;code&gt;e-&amp;gt;f&lt;/code&gt;，所以&lt;code&gt;hasjumps&lt;/code&gt;判断成立。由于&lt;code&gt;TESTSET&lt;/code&gt;已经提供了赋值的寄存器，因此是不需要额外记录判断结果的。而对于其他的入&lt;code&gt;LT&lt;/code&gt;、&lt;code&gt;JMP&lt;/code&gt;等，其本身是不记录任何判断结果的，为了记录只能在 JMP 完成之后，设置到寄存器中，
这也就是此处&lt;code&gt;code_label&lt;/code&gt;存在的原因。接下来是&lt;code&gt;patchlistaux&lt;/code&gt;，其定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;150	static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
151	                          int dtarget) {
152	  while (list != NO_JUMP) {
153	    int next = getjump(fs, list);
154	    if (patchtestreg(fs, list, reg))
155	      fixjump(fs, list, vtarget);
156	    else
157	      fixjump(fs, list, dtarget);  /* jump to default target */
158	    list = next;
159	  }
160	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;patchtestreg&lt;/code&gt;定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;131	static int patchtestreg (FuncState *fs, int node, int reg) {
132	  Instruction *i = getjumpcontrol(fs, node);
133	  if (GET_OPCODE(*i) != OP_TESTSET)
134	    return 0;  /* cannot patch other instructions */
135	  if (reg != NO_REG &amp;amp;&amp;amp; reg != GETARG_B(*i))
136	    SETARG_A(*i, reg);
137	  else  /* no register to put value or register already has the value */
138	    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));
139	
140	  return 1;
141	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;vtarget&lt;/code&gt;是我们当前的位置&lt;code&gt;final&lt;/code&gt;，而&lt;code&gt;dtarget&lt;/code&gt;是&lt;code&gt;p_f&lt;/code&gt;或&lt;code&gt;p_t&lt;/code&gt;。这两条语句的作用其实是将最终&lt;code&gt;TESTSET&lt;/code&gt;指令的结果传送到&lt;code&gt;reg&lt;/code&gt;，
如果不是&lt;code&gt;TESTSET&lt;/code&gt;的话那么说明不产生值，那&lt;code&gt;reg&lt;/code&gt;就需要上面的&lt;code&gt;codelabel&lt;/code&gt;来产生了。至此这部分代码分析完成。&lt;/p&gt;

&lt;p&gt;下面是一些函数的简单解释，可以稍微看看：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaK_nil&lt;/code&gt;函数，生成的是&lt;code&gt;LOADNIL&lt;/code&gt;字节码，其作用是将from ~ from + n之间的寄存器设置成nil，这里做了一些优化如：如果合并相邻的&lt;code&gt;LOADNIL&lt;/code&gt;，函数初始化时可以不需要重复初始化等。
注意优化的前提是&lt;code&gt;fs-&amp;gt;pc &amp;gt; fs-&amp;gt;lasttarget&lt;/code&gt;，即这条指令必须可以省略。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaK_jump&lt;/code&gt;函数，其目的是生成一个&lt;code&gt;JMP&lt;/code&gt;指令。这是个无条件跳转指令。那么其目标呢？其实就是 &lt;code&gt;fs-&amp;gt;jps&lt;/code&gt;。注意后面的&lt;code&gt;luaK_contat&lt;/code&gt;，其目的是将l2链接到l1的后面，这是为了连续跳转
考虑的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;condjump&lt;/code&gt; 生成条件跳转语句，lua为了生成字节码的便利性，每个条件调转语句如&lt;code&gt;LT&lt;/code&gt;, &lt;code&gt;TEST&lt;/code&gt;等后面都跟着一个&lt;code&gt;JMP&lt;/code&gt;，当条件不满足时直接指向&lt;code&gt;JMP&lt;/code&gt;语句，否则就跳到&lt;code&gt;JMP&lt;/code&gt;的下一条，
减少了编码的复杂度啊&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fixjump&lt;/code&gt;把&lt;code&gt;PC&lt;/code&gt;处的指令（当然是JMP指令）改成目标为&lt;code&gt;dest&lt;/code&gt;，当然是相对地址了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaK_getlabel&lt;/code&gt;，标记一下，把当前的lasttarget改成pc，这个lasttarget就是和上面的&lt;code&gt;luaK_nil&lt;/code&gt;结合起来的，防止上面的误优化。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getjump&lt;/code&gt;和上面的fixjump相对应，返回PC所在那条指令的跳转目标。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getjumpcontrol&lt;/code&gt; 由于&lt;code&gt;JMP&lt;/code&gt;上一条很多情况下都是跟着条件跳转指令的，那么这条指令就是获取这条条件跳转指令的。如果是那么返回上一条，否则返回当前pc。除了&lt;code&gt;jmp&lt;/code&gt;之外，其他如&lt;code&gt;FORLOOP&lt;/code&gt;, &lt;code&gt;FORPREP&lt;/code&gt;等指令也会产生跳转&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchtestreg&lt;/code&gt; 修改&lt;code&gt;TESTSET&lt;/code&gt;指令，这个指令一般用于短路求值，&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchlistaux&lt;/code&gt; 对于一个jump list，如果是&lt;code&gt;TESTSET&lt;/code&gt;，那么将赋值寄存器修改为reg并将jump目的地修改为vtarget, 否则修改为dtarget。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dischargejpc&lt;/code&gt; 对jpc进行&lt;code&gt;patchlistaux&lt;/code&gt;，其中vtarget和dtarget都是pc&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchlist&lt;/code&gt; 如果target为pc，那么调用patchtohere；否则调用patchlistaux&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchtohere&lt;/code&gt;先getlabel标记一下，然后将当前的list放到jpc后面&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jpc&lt;/code&gt;那些将要跳到当前位置的链表，由于所有code的增加的欧式&lt;code&gt;luaK_code&lt;/code&gt;，所以会在这个函数中调用&lt;code&gt;dischargejpc&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lua 5.1 分支语句 bytecode 的生成（一）</title>
      <link>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-1/</link>
      <pubDate>Sat, 20 May 2017 15:57:13 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-1/</guid>
      <description>

&lt;p&gt;本文只对 &lt;code&gt;IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END&lt;/code&gt; 语法的字节码生成过程进行描述。&lt;/p&gt;

&lt;h2 id=&#34;生成的结果&#34;&gt;生成的结果&lt;/h2&gt;

&lt;p&gt;首先我们看下面的示例，仅为演示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local cond1 = true
local cond2 = true
if cond1 then
    cond1 = false
elseif cond2 then
    cond2 = false
else
    cond1 = false
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;luac -l -l&lt;/code&gt;选项列出来的结果为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main &amp;lt;test.lua:0,0&amp;gt; (12 instructions, 48 bytes at 0x184e530)
0+ params, 2 slots, 0 upvalues, 2 locals, 0 constants, 0 functions
        1       [1]     LOADBOOL        0 1 0
        2       [2]     LOADBOOL        1 1 0
        3       [3]     TEST            0 0 0
        4       [3]     JMP             2       ; to 7
        5       [4]     LOADBOOL        0 0 0
        6       [4]     JMP             5       ; to 12
        7       [5]     TEST            1 0 0
        8       [5]     JMP             2       ; to 11
        9       [6]     LOADBOOL        1 0 0
        10      [6]     JMP             1       ; to 12
        11      [8]     LOADBOOL        0 0 0
        12      [9]     RETURN          0 1
constants (0) for 0x184e530:
locals (2) for 0x184e530:
        0       cond1   2       12
        1       cond2   3       12
upvalues (0) for 0x184e530:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们可以看到最终的生成结果。我们关注的是其中的&lt;code&gt;TEST&lt;/code&gt;和&lt;code&gt;JUMP&lt;/code&gt;。在第3行的&lt;code&gt;TEST&lt;/code&gt;，其意思是如果0号寄存器中的内容(cond1)
为false(0)的话，那么就执行下面的&lt;code&gt;JMP&lt;/code&gt;语句，否则就调过&lt;code&gt;JMP&lt;/code&gt;直接到第5行。&lt;code&gt;LUA&lt;/code&gt;中的分支实现都是使用&lt;code&gt;TEST&lt;/code&gt;等后面紧跟&lt;code&gt;JMP&lt;/code&gt;实现的，
从主 dispatch 代码中可以看到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // ...
      case OP_TEST: {
        if (l_isfalse(ra) != GETARG_C(i))
          dojump(L, pc, GETARG_sBx(*pc));
        pc++;
        continue;
      }
      case OP_TESTSET: {
        TValue *rb = RB(i);
        if (l_isfalse(rb) != GETARG_C(i)) {
          setobjs2s(L, ra, rb);
          dojump(L, pc, GETARG_sBx(*pc));
        }
        pc++;
        continue;
      }
      // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;JMP&lt;/code&gt;跳转，永远都是分支不成立的情况，而&lt;code&gt;TEST&lt;/code&gt;成功后的跳转永远是跳过下一行，失败的话继续执行接下来的JMP。&lt;code&gt;if&lt;/code&gt;语句的字节码解析就到这里，后面的&lt;code&gt;elseif&lt;/code&gt;等都是比较简单的，再了解这个事实之后。
那么这种字节码是怎么生成的呢？下面来分析下。&lt;/p&gt;

&lt;h2 id=&#34;生成的过程&#34;&gt;生成的过程&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt;语句的代码在&lt;code&gt;lparser.c&lt;/code&gt;里面，最上层如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void ifstat (LexState *ls, int line) {
  /* ifstat -&amp;gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
  FuncState *fs = ls-&amp;gt;fs;
  int flist;
  int escapelist = NO_JUMP;
  flist = test_then_block(ls);  /* IF cond THEN block */
  while (ls-&amp;gt;t.token == TK_ELSEIF) {
    luaK_concat(fs, &amp;amp;escapelist, luaK_jump(fs)); // 将 escapelist 串起来，这里的 luaK_jump 会跳转到 end
    luaK_patchtohere(fs, flist); // 把上面那个`JMP(1/3)` 地址修改对
    flist = test_then_block(ls);  /* ELSEIF cond THEN block */
  }
  if (ls-&amp;gt;t.token == TK_ELSE) {
    luaK_concat(fs, &amp;amp;escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    luaX_next(ls);  /* skip ELSE (after patch, for correct line info) */
    block(ls);  /* `else&#39; part */
  }
  else
    luaK_concat(fs, &amp;amp;escapelist, flist); // 这里把 flist 串起来了，意思是没有 else 语句，此时 flist 指向就是 end
  luaK_patchtohere(fs, escapelist); // 修改 escapelist 到 end 语句的结尾
  check_match(ls, TK_END, TK_IF, line);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在读取 token 的时候，遇到 &lt;code&gt;if ... then&lt;/code&gt; 会生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TEST reg 0 predict
JMP ??? (1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们不知道后面代码的内容，所以无法确定&lt;code&gt;???&lt;/code&gt;该填写多少，但是我们还是要记住这个位置，将来我们要把值填写进去，这个值其实就存
在&lt;code&gt;flist&lt;/code&gt;。然后我们读到&lt;code&gt;elseif cond then&lt;/code&gt;语句，这就意味着第一段代码的结束此时应该要跳转出这个&lt;code&gt;if&lt;/code&gt;
语句，所以此时应该插入一个&lt;code&gt;JMP(2)&lt;/code&gt;到整个语句的结束，因为有多个 block 的存在，后面可能会有很多这种类似的
&lt;code&gt;JMP&lt;/code&gt;，如上面示例中的各种&lt;code&gt;to 12&lt;/code&gt;，这些位置都无法确定，所以我们使用一个escapelist来指向这个地址，方便后面处理。
现在回头看&lt;code&gt;JMP(1)&lt;/code&gt;位置就确定了，所以当前的PC就是&lt;code&gt;flist&lt;/code&gt;的指向由于&lt;code&gt;elseif&lt;/code&gt;又是一个分支语句，所以又可以生成一段 &lt;code&gt;TEST &amp;amp; JMP(3)&lt;/code&gt;代码了。同样&lt;code&gt;JMP(2)&lt;/code&gt;的位置是无法确定的。
现在来谈谈&lt;code&gt;escapelist&lt;/code&gt;，定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int escapelist = NO_JUMP;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是个 int 啊，对于多个位置的&lt;code&gt;JMP(2)&lt;/code&gt;要怎么处理？lua 采用了一种巧妙的机制，由于此时的&lt;code&gt;JMP&lt;/code&gt;是无效的，还没有解析到正式地址的，
所以其中的目标地址域是没有使用的。因此，可以采用串起来的方式，escapcelist指向第一个没有解析的&lt;code&gt;JMP&lt;/code&gt;，然后这个&lt;code&gt;JMP&lt;/code&gt;的指向地址
是下一个没有解析的&lt;code&gt;JMP&lt;/code&gt;，这样一来就形成了链表的结构。后面可以一起修改目标地址通过&lt;code&gt;luaK_patchtohere&lt;/code&gt;来实现。&lt;/p&gt;

&lt;h2 id=&#34;事情没那么简单&#34;&gt;事情没那么简单&lt;/h2&gt;

&lt;p&gt;我们我们详细查看的话，&lt;code&gt;test_then_block&lt;/code&gt; -&amp;gt; &lt;code&gt;cond&lt;/code&gt; -&amp;gt; &lt;code&gt;luaK_goiftrue&lt;/code&gt;，看看&lt;code&gt;luaK_goiftrue&lt;/code&gt;函数的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void luaK_goiftrue (FuncState *fs, expdesc *e) {
  int pc;  /* pc of last jump */
  luaK_dischargevars(fs, e);
  switch (e-&amp;gt;k) {
    case VK: case VKNUM: case VTRUE: {
      pc = NO_JUMP;  /* always true; do nothing */
      break;
    }
    case VFALSE: {
      pc = luaK_jump(fs);  /* always jump */
      break;
    }
    case VJMP: {
      invertjump(fs, e);
      pc = e-&amp;gt;u.s.info;
      break;
    }
    default: {
      pc = jumponcond(fs, e, 0);
      break;
    }
  }
  luaK_concat(fs, &amp;amp;e-&amp;gt;f, pc);  /* insert last jump in `f&#39; list */
  luaK_patchtohere(fs, e-&amp;gt;t);
  e-&amp;gt;t = NO_JUMP;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面的几种，如VK、VKNUM、VTRUE都是始终成立的，所以其&lt;code&gt;e-&amp;gt;f&lt;/code&gt;是不存在的，因此为&lt;code&gt;NO_JUMP&lt;/code&gt;，而对于 VFALSE，其始终应该走错误分支，因此其&lt;code&gt;e-&amp;gt;f&lt;/code&gt;为一条JMP。&lt;code&gt;VJUMP&lt;/code&gt;是比较语句生成的, 所以其值就是代表了&lt;code&gt;e-&amp;gt;t&lt;/code&gt;和&lt;code&gt;e-&amp;gt;f&lt;/code&gt;，因此其&lt;code&gt;e-&amp;gt;f&lt;/code&gt;
就是&lt;code&gt;invertjump&lt;/code&gt;了。在各种错误JMP都生成完之后，接下来就是正确分支了，所以直接就&lt;code&gt;luaK_patchtohere&lt;/code&gt;了，当前的就是正确的逻辑。&lt;/p&gt;

&lt;p&gt;我们关注的重点其实是 &lt;code&gt;jumponcond&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static int jumponcond (FuncState *fs, expdesc *e, int cond) {
  if (e-&amp;gt;k == VRELOCABLE) {
    Instruction ie = getcode(fs, e);
    if (GET_OPCODE(ie) == OP_NOT) {
      fs-&amp;gt;pc--;  /* remove previous OP_NOT */
      return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
    }
    /* else go through */
  }
  discharge2anyreg(fs, e);
  freeexp(fs, e);
  return condjump(fs, OP_TESTSET, NO_REG, e-&amp;gt;u.s.info, cond);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于 &lt;code&gt;if not xxxx then&lt;/code&gt;之类的语句，显然其判断结果值不会被引用（只是被判断语句使用而已）所以这里使用&lt;code&gt;OP_TEST&lt;/code&gt;，其他所有情况
都是使用的&lt;code&gt;OP_TESTSET&lt;/code&gt;。我们可以看看&lt;code&gt;TESTSET&lt;/code&gt;的定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TESTSET A B C if (R(B) &amp;lt;=&amp;gt; C) then R(A) := R(B) else PC++&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Used to implement and and or logical operators, or for testing a single
register in a conditional statement.&lt;/p&gt;

&lt;p&gt;For TESTSET, register R(B) is coerced into a boolean and compared to
the boolean field C. If R(B) matches C, the next instruction is skipped,
otherwise R(B) is assigned to R(A) and the VM continues with the next
instruction. The and operator uses a C of 0 (false) while or uses a C value
of 1 (true).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果 B转换为 boolean后 和 C相等，则跳过下一条指令；否则将B赋给A然后继续执行。这条指令的目的是为短路求值服务的。那么&lt;code&gt;TESTSET&lt;/code&gt;怎
么到后面变成了&lt;code&gt;TEST&lt;/code&gt;呢？其过程就在&lt;code&gt;dischargejpc&lt;/code&gt;-&amp;gt;&lt;code&gt;patchlistaux&lt;/code&gt;-&amp;gt;&lt;code&gt;patchtestreg&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;上面我们说到&lt;code&gt;luaK_patchtohere&lt;/code&gt;将待定&lt;code&gt;JMP&lt;/code&gt;改成当前pc的功能，其实并不是直接修改的，而是通过每次生成新的字节码的时候，调用&lt;code&gt;dischargejpc&lt;/code&gt;实现的，patch 的时候只是将这个位置串起来，然后 &lt;code&gt;dischargejpc&lt;/code&gt;会便利这个链表进行修改&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;patchlistaux(fs, fs-&amp;gt;jpc, fs-&amp;gt;pc, NO_REG, fs-&amp;gt;pc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，&lt;code&gt;patchlistaux&lt;/code&gt;还进行的一项操作就是&lt;code&gt;patchtestreg&lt;/code&gt;，它的作用就是处理&lt;code&gt;TESTSET&lt;/code&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;131	static int patchtestreg (FuncState *fs, int node, int reg) {
132	  Instruction *i = getjumpcontrol(fs, node);
133	  if (GET_OPCODE(*i) != OP_TESTSET)
134	    return 0;  /* cannot patch other instructions */
135	  if (reg != NO_REG &amp;amp;&amp;amp; reg != GETARG_B(*i)) // 前者表示不需要寄存，后者两者相同的话也是不需要修改的
136	    SETARG_A(*i, reg);
137	  else  /* no register to put value or register already has the value */
138	    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i)); // 对于不需要返回值的情况，直接修改为 TEST
139	
140	  return 1;
141	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的介绍只是 条件语句的一部分，后面的文章会对短路求值，compare 运算符等做解释。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>