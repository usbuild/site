<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lua on sys🔱fork</title>
    <link>http://sysfork.com/tags/lua/</link>
    <description>Recent content in Lua on sys🔱fork</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Thu, 25 May 2017 14:26:47 +0800</lastBuildDate>
    <atom:link href="http://sysfork.com/tags/lua/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>lua 5.1 分支语句 bytecode 的生成（二）</title>
      <link>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-2/</link>
      <pubDate>Thu, 25 May 2017 14:26:47 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-2/</guid>
      <description>&lt;p&gt;上篇我们谈到了 IF 语句的 bytecode 生成，今天来谈谈布尔表达式与短路求值。&lt;/p&gt;

&lt;p&gt;考虑到下面的表达式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;a = a or 1024
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其生成的字节码为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1       [1]     GETGLOBAL       0 -1    ; a
2       [1]     TEST            0 0 1
3       [1]     JMP             1       ; to 5
4       [1]     LOADK           0 -2    ; 1024
5       [1]     SETGLOBAL       0 -1    ; a
6       [1]     RETURN          0 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实与&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;if not a then
    a = 1024
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成的代码几乎一致，只是少了像自己赋值的那部分。现在我们看看这条短路求值语句的字节码是怎么生成的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a = a or 1024&lt;/code&gt; 这是一个赋值语句，所以调用使用的是&lt;code&gt;assignment&lt;/code&gt;函数，其中我们关注的调用链是
&lt;code&gt;assignment -&amp;gt; luaK_storeevar -&amp;gt; luaK_exp2anyreg -&amp;gt; luaK_exp2nextreg -&amp;gt; exp2reg&lt;/code&gt; 由于 &lt;code&gt;a or 1024&lt;/code&gt;是个二元运算符，
在代码中可以看到，在读到&lt;code&gt;or&lt;/code&gt;之前是&lt;code&gt;luaK_infix&lt;/code&gt;，读到&lt;code&gt;or&lt;/code&gt;之后是&lt;code&gt;luaK_postfix&lt;/code&gt;，我们看看两者的做法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- luaK_infix
716	    case OPR_OR: {
717	      luaK_goiffalse(fs, v);
718	      break;
719	    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;-- luaK_postfix
746	    case OPR_OR: {
747	      lua_assert(e1-&amp;gt;f == NO_JUMP);  /* list must be closed */
748	      luaK_dischargevars(fs, e2);
749	      luaK_concat(fs, &amp;amp;e2-&amp;gt;t, e1-&amp;gt;t);
750	      *e1 = *e2;
751	      break;
752	    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键还是上文说到的&lt;code&gt;luaK_goiffalse&lt;/code&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;580	  luaK_concat(fs, &amp;amp;e-&amp;gt;t, pc);  /* insert last jump in `t&#39; list */
581	  luaK_patchtohere(fs, e-&amp;gt;f);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果返回 true 的话，那么跳转到某个“未知”的地方，false 的话直接执行下一句。那么这个“未知”的地方是怎么确定的呢？
答案在&lt;code&gt;exp2reg&lt;/code&gt;里面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;394	  if (hasjumps(e)) {
395	    int final;  /* position after whole expression */
396	    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
397	    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
398	    if (need_value(fs, e-&amp;gt;t) || need_value(fs, e-&amp;gt;f)) {
399	      int fj = (e-&amp;gt;k == VJMP) ? NO_JUMP : luaK_jump(fs);
400	      p_f = code_label(fs, reg, 0, 1);
401	      p_t = code_label(fs, reg, 1, 0);
402	      luaK_patchtohere(fs, fj);
403	    }
404	    final = luaK_getlabel(fs);
405	    patchlistaux(fs, e-&amp;gt;f, final, reg, p_f);
406	    patchlistaux(fs, e-&amp;gt;t, final, reg, p_t);
407	  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们设置了&lt;code&gt;e-&amp;gt;t&lt;/code&gt;或&lt;code&gt;e-&amp;gt;f&lt;/code&gt;，所以&lt;code&gt;hasjumps&lt;/code&gt;判断成立。由于&lt;code&gt;TESTSET&lt;/code&gt;已经提供了赋值的寄存器，因此是不需要额外记录判断结果的。而对于其他的入&lt;code&gt;LT&lt;/code&gt;、&lt;code&gt;JMP&lt;/code&gt;等，其本身是不记录任何判断结果的，为了记录只能在 JMP 完成之后，设置到寄存器中，
这也就是此处&lt;code&gt;code_label&lt;/code&gt;存在的原因。接下来是&lt;code&gt;patchlistaux&lt;/code&gt;，其定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;150	static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
151	                          int dtarget) {
152	  while (list != NO_JUMP) {
153	    int next = getjump(fs, list);
154	    if (patchtestreg(fs, list, reg))
155	      fixjump(fs, list, vtarget);
156	    else
157	      fixjump(fs, list, dtarget);  /* jump to default target */
158	    list = next;
159	  }
160	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;patchtestreg&lt;/code&gt;定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;131	static int patchtestreg (FuncState *fs, int node, int reg) {
132	  Instruction *i = getjumpcontrol(fs, node);
133	  if (GET_OPCODE(*i) != OP_TESTSET)
134	    return 0;  /* cannot patch other instructions */
135	  if (reg != NO_REG &amp;amp;&amp;amp; reg != GETARG_B(*i))
136	    SETARG_A(*i, reg);
137	  else  /* no register to put value or register already has the value */
138	    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));
139	
140	  return 1;
141	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;vtarget&lt;/code&gt;是我们当前的位置&lt;code&gt;final&lt;/code&gt;，而&lt;code&gt;dtarget&lt;/code&gt;是&lt;code&gt;p_f&lt;/code&gt;或&lt;code&gt;p_t&lt;/code&gt;。这两条语句的作用其实是将最终&lt;code&gt;TESTSET&lt;/code&gt;指令的结果传送到&lt;code&gt;reg&lt;/code&gt;，
如果不是&lt;code&gt;TESTSET&lt;/code&gt;的话那么说明不产生值，那&lt;code&gt;reg&lt;/code&gt;就需要上面的&lt;code&gt;codelabel&lt;/code&gt;来产生了。至此这部分代码分析完成。&lt;/p&gt;

&lt;p&gt;下面是一些函数的简单解释，可以稍微看看：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaK_nil&lt;/code&gt;函数，生成的是&lt;code&gt;LOADNIL&lt;/code&gt;字节码，其作用是将from ~ from + n之间的寄存器设置成nil，这里做了一些优化如：如果合并相邻的&lt;code&gt;LOADNIL&lt;/code&gt;，函数初始化时可以不需要重复初始化等。
注意优化的前提是&lt;code&gt;fs-&amp;gt;pc &amp;gt; fs-&amp;gt;lasttarget&lt;/code&gt;，即这条指令必须可以省略。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaK_jump&lt;/code&gt;函数，其目的是生成一个&lt;code&gt;JMP&lt;/code&gt;指令。这是个无条件跳转指令。那么其目标呢？其实就是 &lt;code&gt;fs-&amp;gt;jps&lt;/code&gt;。注意后面的&lt;code&gt;luaK_contat&lt;/code&gt;，其目的是将l2链接到l1的后面，这是为了连续跳转
考虑的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;condjump&lt;/code&gt; 生成条件跳转语句，lua为了生成字节码的便利性，每个条件调转语句如&lt;code&gt;LT&lt;/code&gt;, &lt;code&gt;TEST&lt;/code&gt;等后面都跟着一个&lt;code&gt;JMP&lt;/code&gt;，当条件不满足时直接指向&lt;code&gt;JMP&lt;/code&gt;语句，否则就跳到&lt;code&gt;JMP&lt;/code&gt;的下一条，
减少了编码的复杂度啊&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fixjump&lt;/code&gt;把&lt;code&gt;PC&lt;/code&gt;处的指令（当然是JMP指令）改成目标为&lt;code&gt;dest&lt;/code&gt;，当然是相对地址了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaK_getlabel&lt;/code&gt;，标记一下，把当前的lasttarget改成pc，这个lasttarget就是和上面的&lt;code&gt;luaK_nil&lt;/code&gt;结合起来的，防止上面的误优化。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getjump&lt;/code&gt;和上面的fixjump相对应，返回PC所在那条指令的跳转目标。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getjumpcontrol&lt;/code&gt; 由于&lt;code&gt;JMP&lt;/code&gt;上一条很多情况下都是跟着条件跳转指令的，那么这条指令就是获取这条条件跳转指令的。如果是那么返回上一条，否则返回当前pc。除了&lt;code&gt;jmp&lt;/code&gt;之外，其他如&lt;code&gt;FORLOOP&lt;/code&gt;, &lt;code&gt;FORPREP&lt;/code&gt;等指令也会产生跳转&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchtestreg&lt;/code&gt; 修改&lt;code&gt;TESTSET&lt;/code&gt;指令，这个指令一般用于短路求值，&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchlistaux&lt;/code&gt; 对于一个jump list，如果是&lt;code&gt;TESTSET&lt;/code&gt;，那么将赋值寄存器修改为reg并将jump目的地修改为vtarget, 否则修改为dtarget。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dischargejpc&lt;/code&gt; 对jpc进行&lt;code&gt;patchlistaux&lt;/code&gt;，其中vtarget和dtarget都是pc&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchlist&lt;/code&gt; 如果target为pc，那么调用patchtohere；否则调用patchlistaux&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchtohere&lt;/code&gt;先getlabel标记一下，然后将当前的list放到jpc后面&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jpc&lt;/code&gt;那些将要跳到当前位置的链表，由于所有code的增加的欧式&lt;code&gt;luaK_code&lt;/code&gt;，所以会在这个函数中调用&lt;code&gt;dischargejpc&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lua 5.1 分支语句 bytecode 的生成（一）</title>
      <link>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-1/</link>
      <pubDate>Sat, 20 May 2017 15:57:13 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-1/</guid>
      <description>

&lt;p&gt;本文只对 &lt;code&gt;IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END&lt;/code&gt; 语法的字节码生成过程进行描述。&lt;/p&gt;

&lt;h2 id=&#34;生成的结果&#34;&gt;生成的结果&lt;/h2&gt;

&lt;p&gt;首先我们看下面的示例，仅为演示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local cond1 = true
local cond2 = true
if cond1 then
    cond1 = false
elseif cond2 then
    cond2 = false
else
    cond1 = false
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;luac -l -l&lt;/code&gt;选项列出来的结果为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main &amp;lt;test.lua:0,0&amp;gt; (12 instructions, 48 bytes at 0x184e530)
0+ params, 2 slots, 0 upvalues, 2 locals, 0 constants, 0 functions
        1       [1]     LOADBOOL        0 1 0
        2       [2]     LOADBOOL        1 1 0
        3       [3]     TEST            0 0 0
        4       [3]     JMP             2       ; to 7
        5       [4]     LOADBOOL        0 0 0
        6       [4]     JMP             5       ; to 12
        7       [5]     TEST            1 0 0
        8       [5]     JMP             2       ; to 11
        9       [6]     LOADBOOL        1 0 0
        10      [6]     JMP             1       ; to 12
        11      [8]     LOADBOOL        0 0 0
        12      [9]     RETURN          0 1
constants (0) for 0x184e530:
locals (2) for 0x184e530:
        0       cond1   2       12
        1       cond2   3       12
upvalues (0) for 0x184e530:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们可以看到最终的生成结果。我们关注的是其中的&lt;code&gt;TEST&lt;/code&gt;和&lt;code&gt;JUMP&lt;/code&gt;。在第3行的&lt;code&gt;TEST&lt;/code&gt;，其意思是如果0号寄存器中的内容(cond1)
为false(0)的话，那么就执行下面的&lt;code&gt;JMP&lt;/code&gt;语句，否则就调过&lt;code&gt;JMP&lt;/code&gt;直接到第5行。&lt;code&gt;LUA&lt;/code&gt;中的分支实现都是使用&lt;code&gt;TEST&lt;/code&gt;等后面紧跟&lt;code&gt;JMP&lt;/code&gt;实现的，
从主 dispatch 代码中可以看到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // ...
      case OP_TEST: {
        if (l_isfalse(ra) != GETARG_C(i))
          dojump(L, pc, GETARG_sBx(*pc));
        pc++;
        continue;
      }
      case OP_TESTSET: {
        TValue *rb = RB(i);
        if (l_isfalse(rb) != GETARG_C(i)) {
          setobjs2s(L, ra, rb);
          dojump(L, pc, GETARG_sBx(*pc));
        }
        pc++;
        continue;
      }
      // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;JMP&lt;/code&gt;跳转，永远都是分支不成立的情况，而&lt;code&gt;TEST&lt;/code&gt;成功后的跳转永远是跳过下一行，失败的话继续执行接下来的JMP。&lt;code&gt;if&lt;/code&gt;语句的字节码解析就到这里，后面的&lt;code&gt;elseif&lt;/code&gt;等都是比较简单的，再了解这个事实之后。
那么这种字节码是怎么生成的呢？下面来分析下。&lt;/p&gt;

&lt;h2 id=&#34;生成的过程&#34;&gt;生成的过程&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt;语句的代码在&lt;code&gt;lparser.c&lt;/code&gt;里面，最上层如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void ifstat (LexState *ls, int line) {
  /* ifstat -&amp;gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
  FuncState *fs = ls-&amp;gt;fs;
  int flist;
  int escapelist = NO_JUMP;
  flist = test_then_block(ls);  /* IF cond THEN block */
  while (ls-&amp;gt;t.token == TK_ELSEIF) {
    luaK_concat(fs, &amp;amp;escapelist, luaK_jump(fs)); // 将 escapelist 串起来，这里的 luaK_jump 会跳转到 end
    luaK_patchtohere(fs, flist); // 把上面那个`JMP(1/3)` 地址修改对
    flist = test_then_block(ls);  /* ELSEIF cond THEN block */
  }
  if (ls-&amp;gt;t.token == TK_ELSE) {
    luaK_concat(fs, &amp;amp;escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    luaX_next(ls);  /* skip ELSE (after patch, for correct line info) */
    block(ls);  /* `else&#39; part */
  }
  else
    luaK_concat(fs, &amp;amp;escapelist, flist); // 这里把 flist 串起来了，意思是没有 else 语句，此时 flist 指向就是 end
  luaK_patchtohere(fs, escapelist); // 修改 escapelist 到 end 语句的结尾
  check_match(ls, TK_END, TK_IF, line);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在读取 token 的时候，遇到 &lt;code&gt;if ... then&lt;/code&gt; 会生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TEST reg 0 predict
JMP ??? (1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们不知道后面代码的内容，所以无法确定&lt;code&gt;???&lt;/code&gt;该填写多少，但是我们还是要记住这个位置，将来我们要把值填写进去，这个值其实就存
在&lt;code&gt;flist&lt;/code&gt;。然后我们读到&lt;code&gt;elseif cond then&lt;/code&gt;语句，这就意味着第一段代码的结束此时应该要跳转出这个&lt;code&gt;if&lt;/code&gt;
语句，所以此时应该插入一个&lt;code&gt;JMP(2)&lt;/code&gt;到整个语句的结束，因为有多个 block 的存在，后面可能会有很多这种类似的
&lt;code&gt;JMP&lt;/code&gt;，如上面示例中的各种&lt;code&gt;to 12&lt;/code&gt;，这些位置都无法确定，所以我们使用一个escapelist来指向这个地址，方便后面处理。
现在回头看&lt;code&gt;JMP(1)&lt;/code&gt;位置就确定了，所以当前的PC就是&lt;code&gt;flist&lt;/code&gt;的指向由于&lt;code&gt;elseif&lt;/code&gt;又是一个分支语句，所以又可以生成一段 &lt;code&gt;TEST &amp;amp; JMP(3)&lt;/code&gt;代码了。同样&lt;code&gt;JMP(2)&lt;/code&gt;的位置是无法确定的。
现在来谈谈&lt;code&gt;escapelist&lt;/code&gt;，定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int escapelist = NO_JUMP;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是个 int 啊，对于多个位置的&lt;code&gt;JMP(2)&lt;/code&gt;要怎么处理？lua 采用了一种巧妙的机制，由于此时的&lt;code&gt;JMP&lt;/code&gt;是无效的，还没有解析到正式地址的，
所以其中的目标地址域是没有使用的。因此，可以采用串起来的方式，escapcelist指向第一个没有解析的&lt;code&gt;JMP&lt;/code&gt;，然后这个&lt;code&gt;JMP&lt;/code&gt;的指向地址
是下一个没有解析的&lt;code&gt;JMP&lt;/code&gt;，这样一来就形成了链表的结构。后面可以一起修改目标地址通过&lt;code&gt;luaK_patchtohere&lt;/code&gt;来实现。&lt;/p&gt;

&lt;h2 id=&#34;事情没那么简单&#34;&gt;事情没那么简单&lt;/h2&gt;

&lt;p&gt;我们我们详细查看的话，&lt;code&gt;test_then_block&lt;/code&gt; -&amp;gt; &lt;code&gt;cond&lt;/code&gt; -&amp;gt; &lt;code&gt;luaK_goiftrue&lt;/code&gt;，看看&lt;code&gt;luaK_goiftrue&lt;/code&gt;函数的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void luaK_goiftrue (FuncState *fs, expdesc *e) {
  int pc;  /* pc of last jump */
  luaK_dischargevars(fs, e);
  switch (e-&amp;gt;k) {
    case VK: case VKNUM: case VTRUE: {
      pc = NO_JUMP;  /* always true; do nothing */
      break;
    }
    case VFALSE: {
      pc = luaK_jump(fs);  /* always jump */
      break;
    }
    case VJMP: {
      invertjump(fs, e);
      pc = e-&amp;gt;u.s.info;
      break;
    }
    default: {
      pc = jumponcond(fs, e, 0);
      break;
    }
  }
  luaK_concat(fs, &amp;amp;e-&amp;gt;f, pc);  /* insert last jump in `f&#39; list */
  luaK_patchtohere(fs, e-&amp;gt;t);
  e-&amp;gt;t = NO_JUMP;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面的几种，如VK、VKNUM、VTRUE都是始终成立的，所以其&lt;code&gt;e-&amp;gt;f&lt;/code&gt;是不存在的，因此为&lt;code&gt;NO_JUMP&lt;/code&gt;，而对于 VFALSE，其始终应该走错误分支，因此其&lt;code&gt;e-&amp;gt;f&lt;/code&gt;为一条JMP。&lt;code&gt;VJUMP&lt;/code&gt;是比较语句生成的, 所以其值就是代表了&lt;code&gt;e-&amp;gt;t&lt;/code&gt;和&lt;code&gt;e-&amp;gt;f&lt;/code&gt;，因此其&lt;code&gt;e-&amp;gt;f&lt;/code&gt;
就是&lt;code&gt;invertjump&lt;/code&gt;了。在各种错误JMP都生成完之后，接下来就是正确分支了，所以直接就&lt;code&gt;luaK_patchtohere&lt;/code&gt;了，当前的就是正确的逻辑。&lt;/p&gt;

&lt;p&gt;我们关注的重点其实是 &lt;code&gt;jumponcond&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static int jumponcond (FuncState *fs, expdesc *e, int cond) {
  if (e-&amp;gt;k == VRELOCABLE) {
    Instruction ie = getcode(fs, e);
    if (GET_OPCODE(ie) == OP_NOT) {
      fs-&amp;gt;pc--;  /* remove previous OP_NOT */
      return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
    }
    /* else go through */
  }
  discharge2anyreg(fs, e);
  freeexp(fs, e);
  return condjump(fs, OP_TESTSET, NO_REG, e-&amp;gt;u.s.info, cond);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于 &lt;code&gt;if not xxxx then&lt;/code&gt;之类的语句，显然其判断结果值不会被引用（只是被判断语句使用而已）所以这里使用&lt;code&gt;OP_TEST&lt;/code&gt;，其他所有情况
都是使用的&lt;code&gt;OP_TESTSET&lt;/code&gt;。我们可以看看&lt;code&gt;TESTSET&lt;/code&gt;的定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TESTSET A B C if (R(B) &amp;lt;=&amp;gt; C) then R(A) := R(B) else PC++&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Used to implement and and or logical operators, or for testing a single
register in a conditional statement.&lt;/p&gt;

&lt;p&gt;For TESTSET, register R(B) is coerced into a boolean and compared to
the boolean field C. If R(B) matches C, the next instruction is skipped,
otherwise R(B) is assigned to R(A) and the VM continues with the next
instruction. The and operator uses a C of 0 (false) while or uses a C value
of 1 (true).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果 B转换为 boolean后 和 C相等，则跳过下一条指令；否则将B赋给A然后继续执行。这条指令的目的是为短路求值服务的。那么&lt;code&gt;TESTSET&lt;/code&gt;怎
么到后面变成了&lt;code&gt;TEST&lt;/code&gt;呢？其过程就在&lt;code&gt;dischargejpc&lt;/code&gt;-&amp;gt;&lt;code&gt;patchlistaux&lt;/code&gt;-&amp;gt;&lt;code&gt;patchtestreg&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;上面我们说到&lt;code&gt;luaK_patchtohere&lt;/code&gt;将待定&lt;code&gt;JMP&lt;/code&gt;改成当前pc的功能，其实并不是直接修改的，而是通过每次生成新的字节码的时候，调用&lt;code&gt;dischargejpc&lt;/code&gt;实现的，patch 的时候只是将这个位置串起来，然后 &lt;code&gt;dischargejpc&lt;/code&gt;会便利这个链表进行修改&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;patchlistaux(fs, fs-&amp;gt;jpc, fs-&amp;gt;pc, NO_REG, fs-&amp;gt;pc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，&lt;code&gt;patchlistaux&lt;/code&gt;还进行的一项操作就是&lt;code&gt;patchtestreg&lt;/code&gt;，它的作用就是处理&lt;code&gt;TESTSET&lt;/code&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;131	static int patchtestreg (FuncState *fs, int node, int reg) {
132	  Instruction *i = getjumpcontrol(fs, node);
133	  if (GET_OPCODE(*i) != OP_TESTSET)
134	    return 0;  /* cannot patch other instructions */
135	  if (reg != NO_REG &amp;amp;&amp;amp; reg != GETARG_B(*i)) // 前者表示不需要寄存，后者两者相同的话也是不需要修改的
136	    SETARG_A(*i, reg);
137	  else  /* no register to put value or register already has the value */
138	    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i)); // 对于不需要返回值的情况，直接修改为 TEST
139	
140	  return 1;
141	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的介绍只是 条件语句的一部分，后面的文章会对短路求值，compare 运算符等做解释。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>解析lua gc 中的参数控制</title>
      <link>http://sysfork.com/post/2017/lua-gc-paramter-internal/</link>
      <pubDate>Wed, 10 May 2017 20:05:41 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-gc-paramter-internal/</guid>
      <description>&lt;p&gt;lua gc 调优主要涉及到两个两个参数&lt;code&gt;setpause&lt;/code&gt;和&lt;code&gt;setstepmul&lt;/code&gt;，使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;collectgarbage(&amp;quot;setpause&amp;quot;, 200)
collectgarbage(&amp;quot;setstepmul&amp;quot;, 200)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个值的默认值都是&lt;code&gt;200&lt;/code&gt;，那么这代表着什么意思呢？通过查看代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static const char *const opts[] = {&amp;quot;stop&amp;quot;, &amp;quot;restart&amp;quot;, &amp;quot;collect&amp;quot;,
  &amp;quot;count&amp;quot;, &amp;quot;step&amp;quot;, &amp;quot;setpause&amp;quot;, &amp;quot;setstepmul&amp;quot;, NULL};
static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
  LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实&lt;code&gt;collectgarbage&lt;/code&gt;对应的就是&lt;code&gt;lua_gc&lt;/code&gt;方法，下面是其中的部分逻辑的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;LUA_API int lua_gc (lua_State *L, int what, int data) {
  switch (what) {
    case LUA_GCSTOP: g-&amp;gt;GCthreshold = MAX_LUMEM;
    case LUA_GCRESTART: g-&amp;gt;GCthreshold = g-&amp;gt;totalbytes;
    case LUA_GCCOLLECT: luaC_fullgc(L);
    case LUA_GCCOUNT: res = cast_int(g-&amp;gt;totalbytes &amp;gt;&amp;gt; 10);
    case LUA_GCCOUNTB:  res = cast_int(g-&amp;gt;totalbytes &amp;amp; 0x3ff);
    case LUA_GCSTEP: {
      lu_mem a = (cast(lu_mem, data) &amp;lt;&amp;lt; 10);
      if (a &amp;lt;= g-&amp;gt;totalbytes)
        g-&amp;gt;GCthreshold = g-&amp;gt;totalbytes - a;
      else
        g-&amp;gt;GCthreshold = 0;
      while (g-&amp;gt;GCthreshold &amp;lt;= g-&amp;gt;totalbytes) {
        luaC_step(L);
        if (g-&amp;gt;gcstate == GCSpause) {  /* end of cycle? */
          res = 1;  /* signal it */
          break;
        }
      }
      break;
    }
    case LUA_GCSETPAUSE: res = g-&amp;gt;gcpause; g-&amp;gt;gcpause = data;
    case LUA_GCSETSTEPMUL: res = g-&amp;gt;gcstepmul; g-&amp;gt;gcstepmul = data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中我们看到一些有意思的参数，在&lt;code&gt;g(global_State)&lt;/code&gt;中有如下定义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
** `global state&#39;, shared by all threads of this state
*/
typedef struct global_State {
//.....
  lu_mem GCthreshold;
  lu_mem totalbytes;  /* number of bytes currently allocated */
  lu_mem estimate;  /* an estimate of number of bytes actually in use */
  lu_mem gcdept;  /* how much GC is `behind schedule&#39; */
  int gcpause;  /* size of pause between successive GCs */
  int gcstepmul;  /* GC `granularity&#39; */
//......
} global_State;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，对于&lt;code&gt;LUA_GCSTOP&lt;/code&gt;是将&lt;code&gt;GCthreshold&lt;/code&gt;设置成一个很大的值&lt;code&gt;MAX_LUMEM&lt;/code&gt;(&lt;code&gt;~(size_t)0)-2&lt;/code&gt;)，而&lt;code&gt;LUA_GCRESTART&lt;/code&gt;则将&lt;code&gt;GCthreshold&lt;/code&gt;设置成&lt;code&gt;totalbytes&lt;/code&gt;。对于&lt;code&gt;LUA_GCSETPAUSE&lt;/code&gt;和&lt;code&gt;LUA_GCSETSTEPMUL&lt;/code&gt;则是分别设置了&lt;code&gt;gcpause&lt;/code&gt;和&lt;code&gt;gcstepmul&lt;/code&gt;的值。从注释中我们可以看到各自值的解释。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GCthreshold&lt;/td&gt;
&lt;td&gt;GC的门槛，当totalbytes大于这个值时触发gc step&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;totalbytes&lt;/td&gt;
&lt;td&gt;由内存分配器分配的&lt;strong&gt;实际&lt;/strong&gt;内存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;estimate&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;估计&lt;/strong&gt;的，正在使用的内存大小，小于 &lt;code&gt;totalbytes&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;下面这段代码是代码中随处可见，如&lt;code&gt;lua_createtable&lt;/code&gt;等，在执行操作之前都会检查是否需要触发&lt;code&gt;gc&lt;/code&gt;，以保证内存利用率。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;80	#define luaC_checkGC(L) { \
81	  condhardstacktests(luaD_reallocstack(L, L-&amp;gt;stacksize - EXTRA_STACK - 1)); \
82	  if (G(L)-&amp;gt;totalbytes &amp;gt;= G(L)-&amp;gt;GCthreshold) \
83		luaC_step(L); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 &lt;code&gt;totalbytes &amp;gt;= GCthreshold&lt;/code&gt;时触发step。因此&lt;code&gt;LUA_GCRESTART&lt;/code&gt;之后，下一次&lt;code&gt;checkGC&lt;/code&gt;的时候会立即出发&lt;code&gt;luaC_step&lt;/code&gt;。可以看到
&lt;code&gt;totalbytes&lt;/code&gt;和&lt;code&gt;GCthreshold&lt;/code&gt;是控制&lt;code&gt;GC&lt;/code&gt;的关键参数。&lt;/p&gt;

&lt;p&gt;每个回收周期结束重置&lt;code&gt;GCthreshold&lt;/code&gt; ，这里用到了的estimate。因为带有 __gc 元方法的 &lt;code&gt;userdata&lt;/code&gt; 需要两个gc周期
才能回收，在第一个gc周期中其 &lt;code&gt;__gc&lt;/code&gt;元方法会被调用，而在第二个回收周期内内存会被真正回收。因此，&lt;code&gt;estimate&lt;/code&gt;是不包含那些&lt;code&gt;__gc&lt;/code&gt;元方法被调用的&lt;code&gt;userdata&lt;/code&gt;的，而&lt;code&gt;totalbytes&lt;/code&gt;会包含（因为其反映的是真实内存占用情况）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define setthreshold(g)  (g-&amp;gt;GCthreshold = (g-&amp;gt;estimate/100) * g-&amp;gt;gcpause)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由这段代码可以看出，我们设置的&lt;code&gt;gcpause&lt;/code&gt;值影响的是下一周期开始的事件，默认&lt;code&gt;200&lt;/code&gt;的意思时，当当前&lt;strong&gt;真实&lt;/strong&gt;内存占用超过当前&lt;strong&gt;估计&lt;/strong&gt;内存占用的两倍时，才开启下一回收周期。所以如果你含&lt;code&gt;__gc&lt;/code&gt;方法的&lt;code&gt;userdata&lt;/code&gt;过大的话，很可能在第一次周期结束后立马开启了第二周期。如果设置的&lt;code&gt;gcpause&lt;/code&gt;值小于&lt;code&gt;100&lt;/code&gt;的话，那么同样两次&lt;code&gt;gc&lt;/code&gt;周期中间是没有间隔的。&lt;/p&gt;

&lt;p&gt;接下来看&lt;code&gt;luaC_step&lt;/code&gt;的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;610	void luaC_step (lua_State *L) {
611	  global_State *g = G(L);
612	  l_mem lim = (GCSTEPSIZE/100) * g-&amp;gt;gcstepmul;
613	  if (lim == 0)
614	    lim = (MAX_LUMEM-1)/2;  /* no limit */
615	  g-&amp;gt;gcdept += g-&amp;gt;totalbytes - g-&amp;gt;GCthreshold;
616	  do {
617	    lim -= singlestep(L);
618	    if (g-&amp;gt;gcstate == GCSpause)
619	      break;
620	  } while (lim &amp;gt; 0);
621	  if (g-&amp;gt;gcstate != GCSpause) {
622	    if (g-&amp;gt;gcdept &amp;lt; GCSTEPSIZE)
623	      g-&amp;gt;GCthreshold = g-&amp;gt;totalbytes + GCSTEPSIZE;  /* - lim/g-&amp;gt;gcstepmul;*/
624	    else {
625	      g-&amp;gt;gcdept -= GCSTEPSIZE;
626	      g-&amp;gt;GCthreshold = g-&amp;gt;totalbytes;
627	    }
628	  }
629	  else {
630	    setthreshold(g);
631	  }
632	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里&lt;code&gt;stepmul&lt;/code&gt;控制的就是&lt;code&gt;step&lt;/code&gt;的长度，越大则每步所进行的操作也就越多，拥有更多的「费」。其中&lt;code&gt;GCSTEPSIZE&lt;/code&gt;的值为&lt;code&gt;1024&lt;/code&gt;。也就是说默认&lt;code&gt;stepmul&lt;/code&gt;为200的情况下，大约可已进行&lt;code&gt;2048&lt;/code&gt;「费」，那么「费」是怎么定义的呢？从代码可以看到清除一条&lt;code&gt;string&lt;/code&gt;表和任意一个&lt;code&gt;gc&lt;/code&gt;对象为&lt;code&gt;10&lt;/code&gt;「费」，调用&lt;code&gt;__gc&lt;/code&gt;元方法为&lt;code&gt;100&lt;/code&gt;「费」，除非是&lt;code&gt;sweep&lt;/code&gt;阶段否则内存不会减少，因此不能使用内存差值来表示工作进度，所以引入了「费」。如果你把&lt;code&gt;stepmul&lt;/code&gt;设置为&lt;code&gt;0&lt;/code&gt;的话，那么&lt;code&gt;lim&lt;/code&gt;就是&lt;code&gt;(MAX_LUMEM-1)/2&lt;/code&gt;
为什么是这么奇怪的数值？因为&lt;code&gt;MAX_LUAEME&lt;/code&gt;是&lt;code&gt;~(size_t)0)-2&lt;/code&gt;，无符号整型，而&lt;code&gt;l_mem&lt;/code&gt;是有符号的，直接赋值会溢出的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaC_step&lt;/code&gt;的设计思路是： 每当新增分配的内存数超过&lt;code&gt;GCSTEPSIZE&lt;/code&gt;就触发一次。由于lua只会在gc过程中释放对象，所以
&lt;code&gt;totalbytes&lt;/code&gt;在gc过程外时只增不减的，因此&lt;code&gt;luaC_step&lt;/code&gt;总是会得以触发。为了准确记录新增内存使用量，lua 使用了&lt;code&gt;gcdept&lt;/code&gt;变量。
这种设计是为了防止&lt;code&gt;luaC_step&lt;/code&gt;被频繁触发，控制一个较合理的粒度。&lt;/p&gt;

&lt;p&gt;另外，&lt;code&gt;gcdept&lt;/code&gt;在每个周期末尾会清零。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;592	    case GCSfinalize: {
593	      if (g-&amp;gt;tmudata) {
594	        GCTM(L);
595	        if (g-&amp;gt;estimate &amp;gt; GCFINALIZECOST)
596	          g-&amp;gt;estimate -= GCFINALIZECOST;
597	        return GCFINALIZECOST;
598	      }
599	      else {
600	        g-&amp;gt;gcstate = GCSpause;  /* end collection */
601	        g-&amp;gt;gcdept = 0;
602	        return 0;
603	      }
604	    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>一种在elf中集成脚本文件的方案</title>
      <link>http://sysfork.com/post/2017/a-solution-for-elf-integrate-scripts/</link>
      <pubDate>Mon, 01 May 2017 22:30:00 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/a-solution-for-elf-integrate-scripts/</guid>
      <description>

&lt;p&gt;进行游戏服务器开发时，我们将&lt;code&gt;C++&lt;/code&gt;的部分称之为引擎层，而&lt;code&gt;lua&lt;/code&gt;称之为脚本层。但是往往有些核心逻辑是各个游戏公用的，
或者说有些引擎层的代码用&lt;code&gt;C++&lt;/code&gt;写起来十分麻烦，我们还是会使用&lt;code&gt;lua&lt;/code&gt;来编写。这就带来了一些问题，我们的游戏目录结构如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├─bin               // 可执行文件
└─scripts           // 脚本目录，lua文件
    ├─framework     // 核心lua文件，各个项目公用的
    └─server        // 游戏逻辑lua文件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;scripts/framework&lt;/code&gt;是各个项目公用的，并且和&lt;code&gt;bin&lt;/code&gt;目录中的可执行文件同时发布和更新。所以有一个想法，就是将&lt;code&gt;framework&lt;/code&gt;中
的lua文件集成到可执行文件中，减少维护的成本。&lt;/p&gt;

&lt;h1 id=&#34;文件存储&#34;&gt;文件存储&lt;/h1&gt;

&lt;p&gt;下面是elf文件的示意图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Elf-layout--en.svg/260px-Elf-layout--en.svg.png&#34; alt=&#34;elf&#34; /&gt;&lt;/p&gt;

&lt;p&gt;elf文件有多个section，除了一些预定义的section如&lt;code&gt;.rodata&lt;/code&gt;、&lt;code&gt;.text&lt;/code&gt;、&lt;code&gt;.init&lt;/code&gt;等，我们也可以定义一些自己的section。所以我们可以将所需要的lua文件
放进这个section中，在执行的时候动态读出来，实现目的。我们可以使用&lt;a href=&#34;https://linux.die.net/man/1/objcopy&#34;&gt;objcopy&lt;/a&gt;命令来实现创建自定义section的功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objcopy infile.out --add-section .lua-data=section_file outfile.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而&lt;code&gt;framework&lt;/code&gt;里面有多个文件，而且包含嵌套的文件夹，我们需要一个将文件夹变成单个文件的功能，类似于&lt;a href=&#34;https://linux.die.net/man/1/tar&#34;&gt;tar&lt;/a&gt;。虽然创建
section时使用&lt;code&gt;tar&lt;/code&gt;命令是简单的，但是在读取的时候需要一些第三方的库来支持，这是比较麻烦的。而由于我们的目录中只包含&lt;code&gt;lua&lt;/code&gt;文件，所以可以简化设计。
首先空文件夹对于我们是无意义的，只需要&lt;code&gt;lua&lt;/code&gt;文件就可以。所以最终我们得到如下的表:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;┌────────────────────┐
│ libs/json.lua      │
├────────────────────┤
│ core/entity.lua    │
├────────────────────┤
│ app/game.lua       │
├────────────────────┤
│ libs/bson.lua      │
└────────────────────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以按照如下的格式转换成单个文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;┌────────┬───────────┐
│name_len│content_len│
├────────┴───────────┤
│ core.entity        │
├────────────────────┤
│name_len│content_len│
├────────────────────┤
│ libs.bson          │
├────────────────────┤
│ .................  │
└────────────────────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;name_len&lt;/code&gt;为文件名的长度，这里直接转换成了lua中&lt;code&gt;require&lt;/code&gt;的格式，使用点符号。&lt;code&gt;content_len&lt;/code&gt;是文件内容的长度，即文件的具体内容长度。最后我们可以使用&lt;code&gt;zip&lt;/code&gt;指令
将这部分内容压缩存储在&lt;code&gt;elf&lt;/code&gt;文件中。完整的代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
#coding: utf-8

import os, struct, StringIO, zlib, subprocess, sys, tempfile, argparse

argParser = argparse.ArgumentParser()

argParser.add_argument(&amp;quot;luafolder&amp;quot;, type=str)
argParser.add_argument(&amp;quot;exe&amp;quot;, type=str)
argParser.add_argument(&amp;quot;out&amp;quot;, type=str)

args = argParser.parse_args()

files = []

path = args.luafolder

for (dirpath, dirname, filenames) in os.walk(path):
    dirp = dirpath[len(path):]
    if dirp:
        if dirp[-1] != &amp;quot;/&amp;quot;:
            dirp += &amp;quot;/&amp;quot;

        while dirp[0] == &amp;quot;/&amp;quot;:
            dirp = dirp[1:]

    files.extend([dirp + x for x in filenames])

output = StringIO.StringIO()

for fpath in files:
    realp = path + &amp;quot;/&amp;quot; + fpath
    filesize = os.path.getsize(realp)

    if fpath.endswith(&amp;quot;.lua&amp;quot;):
        fpath = fpath[:-4]
    elif fpath.endswith(&amp;quot;.luac&amp;quot;):
        fpath = fpath[:-5]
    else:
        continue

    package_pattern = fpath.replace(&amp;quot;/&amp;quot;, &amp;quot;.&amp;quot;)
    package_pattern = &amp;quot;pg.&amp;quot; + package_pattern
    with open(realp, &amp;quot;rb&amp;quot;) as rf:
        content = rf.read()
        output.write(struct.pack(&amp;quot;=hL&amp;quot;, len(package_pattern), len(content)))
        output.write(package_pattern)
        output.write(content)

f = tempfile.NamedTemporaryFile()

outdata = output.getvalue()
f.write(struct.pack(&amp;quot;=L&amp;quot;, len(outdata)))
f.write(zlib.compress(output.getvalue()))
f.flush()

subprocess.call(&amp;quot;objcopy %s --remove-section .lua-data&amp;quot;%(args.exe, ), shell=True)
subprocess.call(&amp;quot;objcopy %s --add-section .lua-data=%s %s&amp;quot;%(args.exe, f.name, args.out), shell=True)

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;文件内容的读取&#34;&gt;文件内容的读取&lt;/h1&gt;

&lt;p&gt;我们需要使用&lt;code&gt;elf.h&lt;/code&gt;文件来读取文件内容。根据上述的格式示意图，&lt;code&gt;elf&lt;/code&gt;文件开头的是Header，其格式为&lt;code&gt;ElfXX_Ehdr&lt;/code&gt;，
我们可以直接读取文件内容到内存。然后读取&lt;code&gt;e_shoff&lt;/code&gt;字段获得section header的位置，定位到位置并依次读取内容到&lt;code&gt;ElfXX_Shdr&lt;/code&gt;
结构体中，然后通过各个entry的&lt;code&gt;sh_name&lt;/code&gt;得到最终section，然后读取文件达到目的。完整代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static std::map&amp;lt;std::string, std::string&amp;gt; readElfLuaData(const std::string &amp;amp;filepath) {
    std::map&amp;lt;std::string, std::string&amp;gt; files;
#if __x86_64__
    typedef Elf64_Ehdr ELF_EHDR;
    typedef Elf64_Shdr ELF_SHDR;
#else
    typedef Elf32_Ehdr ELF_EHDR;
    typedef Elf32_Shdr ELF_SHDR;
#endif

    std::ifstream ifs(filepath);

    ELF_EHDR hdr;
    ifs.read(reinterpret_cast&amp;lt;char *&amp;gt;(&amp;amp;hdr), sizeof(hdr));

    std::vector&amp;lt;ELF_SHDR&amp;gt; sh_tables(hdr.e_shnum);
    ifs.seekg(static_cast&amp;lt;long&amp;gt;(hdr.e_shoff));

    for (size_t i = 0; i &amp;lt; hdr.e_shnum; ++i) {
        ifs.read(reinterpret_cast&amp;lt;char *&amp;gt;(&amp;amp;sh_tables[i]), sizeof(sh_tables[i]));
    }

    // read shstr

    std::vector&amp;lt;char&amp;gt; shstr(sh_tables[hdr.e_shstrndx].sh_size);
    ifs.seekg(static_cast&amp;lt;long&amp;gt;(sh_tables[hdr.e_shstrndx].sh_offset));
    ifs.read(shstr.data(), static_cast&amp;lt;long&amp;gt;(shstr.size()));

    ELF_SHDR *lua_sh = nullptr;

    for (size_t i = 0; i &amp;lt; hdr.e_shnum; ++i) {
        char *name = shstr.data() + sh_tables[i].sh_name;
        if (strcmp(name, &amp;quot;.lua-data&amp;quot;) == 0) {
            lua_sh = &amp;amp;sh_tables[i];
            break;
        }
    }

    if (lua_sh) {
        std::vector&amp;lt;char&amp;gt; buf(lua_sh-&amp;gt;sh_size);
        ifs.seekg(static_cast&amp;lt;long&amp;gt;(lua_sh-&amp;gt;sh_offset));
        ifs.read(buf.data(), static_cast&amp;lt;std::streamsize&amp;gt;(buf.size()));

        size_t idx = 0;
#define READ_TO(TARGET, SIZE)                                                                      \
    memcpy(TARGET, buf.data() + idx, SIZE);                                                        \
    idx += SIZE;

        uint32_t raw_len = 0;
        READ_TO(&amp;amp;raw_len, sizeof(raw_len));

        std::vector&amp;lt;char&amp;gt; tmp(raw_len);
        uLongf dest_len = tmp.size();
        uncompress(reinterpret_cast&amp;lt;Bytef *&amp;gt;(tmp.data()), &amp;amp;dest_len,
                   reinterpret_cast&amp;lt;Bytef *&amp;gt;(buf.data() + idx), buf.size() - idx);

        buf.swap(tmp);
        idx = 0;

        while (idx &amp;lt; dest_len) {
            uint16_t name_len;
            uint32_t content_len;
            READ_TO(&amp;amp;name_len, sizeof(name_len));
            READ_TO(&amp;amp;content_len, sizeof(content_len));
            std::string filename(name_len, 0), content(content_len, 0);
            READ_TO(&amp;amp;*filename.begin(), filename.size());
            READ_TO(&amp;amp;*content.begin(), content.size());
            files.emplace(std::piecewise_construct, std::forward_as_tuple(std::move(filename)),
                          std::forward_as_tuple(std::move(content)));
        }
#undef READ_TO
    }
    return files;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来便可以通过添加到&lt;code&gt;package.preload&lt;/code&gt;实现在lua中调用这些文件的目的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lua与C交互中的死循环检测</title>
      <link>http://sysfork.com/post/2017/lua-c-detect-inifinite-loop/</link>
      <pubDate>Fri, 21 Apr 2017 17:37:30 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-c-detect-inifinite-loop/</guid>
      <description>

&lt;p&gt;现在很多游戏引擎都是&lt;code&gt;C++&lt;/code&gt; + &lt;code&gt;lua&lt;/code&gt;的结构，一旦某个服务器开发人员大意写出死循环代码，很容易导致服务无响应，影响服务器稳定。所以引擎中最好能提供一个死循环的检测机制，一旦出现死循环则执行一些行为打断当前流程。&lt;/p&gt;

&lt;p&gt;死循环的检测是一个&lt;a href=&#34;https://en.wikipedia.org/wiki/Halting_problem&#34;&gt;停机问题&lt;/a&gt;。我们无法判断到底是任务执行时间过长，还是进入了真正的死循环，好在这对我们的服务来说区别并不重要。所以一个简单的判断条件是，执行时间是否超过了预定的阈值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C++&lt;/code&gt;中集成&lt;code&gt;lua&lt;/code&gt;，调用到游戏逻辑时，一般通过&lt;a href=&#34;http://pgl.yoyo.org/luai/i/lua_pcall&#34;&gt;pcall&lt;/a&gt;，但是一旦调用了&lt;code&gt;pcall&lt;/code&gt;，代码的执行路径便进入了&lt;code&gt;lua&lt;/code&gt;的世界，除非通过信号机制才能在当前线程中中断，实现执行其他分支的目的。除此之外，&lt;code&gt;lua&lt;/code&gt;还提供了&lt;code&gt;debug.sethook&lt;/code&gt;函数，可以在执行正常逻辑中触发&lt;code&gt;hook&lt;/code&gt;，实现监测超时的功能。所以我们有以下两种方案：&lt;/p&gt;

&lt;h1 id=&#34;使用-debug-sethook-来实现&#34;&gt;使用&lt;code&gt;debug.sethook()&lt;/code&gt;来实现&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;debug.sethook ([thread,] hook, mask [, count])
Sets the given function as a hook. The string mask and the number count describe when the hook will be called. The string mask may have the following characters, with the given meaning:&lt;/p&gt;

&lt;p&gt;&amp;ldquo;c&amp;rdquo;: the hook is called every time Lua calls a function;
&amp;ldquo;r&amp;rdquo;: the hook is called every time Lua returns from a function;
&amp;ldquo;l&amp;rdquo;: the hook is called every time Lua enters a new line of code.
With a count different from zero, the hook is called after every count instructions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以我们只要在执行&lt;code&gt;pcall&lt;/code&gt;之前设定类似如下的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;debug.sethook(function()error(&amp;quot;timeout&amp;quot;)end, &amp;quot;c&amp;quot;, 10000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理论上只要代码指令数超过10000条就能触发&lt;code&gt;error&lt;/code&gt;。好像挺完美的。&lt;/p&gt;

&lt;p&gt;But，在&lt;code&gt;luajit&lt;/code&gt;下这条不一定成立，因为执行的逻辑被&lt;code&gt;jit&lt;/code&gt;编译了，而在这种情况下，&lt;code&gt;hook&lt;/code&gt;是不会触发的&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If your program is running in a tight loop and never falls back to the interpreter, the debug hook never runs and can&amp;rsquo;t throw the &amp;ldquo;interrupted!&amp;rdquo; error.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但是还有一个未公开的编译选项&lt;code&gt;LUAJIT_ENABLE_CHECKHOOK&lt;/code&gt;，在&lt;code&gt;lj_record.c&lt;/code&gt;文件的最后面，上面写道&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Regularly check for instruction/line hooks from compiled code and
exit to the interpreter if the hooks are set.&lt;/p&gt;

&lt;p&gt;This is a compile-time option and disabled by default, since the
hook checks may be quite expensive in tight loops.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看似可以，但是注意，如果&lt;code&gt;hook&lt;/code&gt;被设置了，则执行的代价是比较昂贵的。对于游戏而言，大部分的时间都在&lt;code&gt;lua&lt;/code&gt;层，而为了监测死循环，几乎
要在所有的lua执行过程中设置&lt;code&gt;hook&lt;/code&gt;，这是不太容易接受的。好在下面的注释提到了&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can set the instruction hook via lua_sethook() with a count of 1
from a signal handler or another native thread. Please have a look
at the first few functions in luajit.c for an example (Ctrl-C handler).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;嗯，看样子只能使用第二种方案了。&lt;/p&gt;

&lt;h1 id=&#34;使用信号来实现&#34;&gt;使用信号来实现&lt;/h1&gt;

&lt;p&gt;在lua的命令行程序中我们可以通过&lt;code&gt;Ctrl-C&lt;/code&gt;中断正在执行的程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;  for i=1,10000000 do sum = sum + i end
^Cinterrupted!
stack traceback:
        stdin:1: in main chunk
        [C]: in ?

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仔细看&lt;code&gt;lua.c&lt;/code&gt;文件，可以看到以下代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;static void lstop (lua_State *L, lua_Debug *ar) {
  (void)ar;  /* unused arg. */
  lua_sethook(L, NULL, 0, 0);
  luaL_error(L, &amp;quot;interrupted!&amp;quot;);
}


static void laction (int i) {
  signal(i, SIG_DFL); /* if another SIGINT happens before lstop,
                              terminate process (default action) */
  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
}

// ....
//in docall
signal(SIGINT, laction);
status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
signal(SIGINT, SIG_DFL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嗯，在执行&lt;code&gt;pcall&lt;/code&gt;之前设置了信号处理函数，捕捉&lt;code&gt;Ctrl-C&lt;/code&gt;的信号，一旦发生，则立马调用&lt;code&gt;lua_sethook&lt;/code&gt;函数，指定在执行下一行代码时调用&lt;code&gt;lstop&lt;/code&gt;，而在&lt;code&gt;lstop&lt;/code&gt;中就直接抛出&lt;code&gt;error&lt;/code&gt;了。所以问题是 &lt;strong&gt;&lt;code&gt;lua_sethook&lt;/code&gt;是可以在信号处理函数中调用的&lt;/strong&gt;？&lt;/p&gt;

&lt;p&gt;答案：是&lt;/p&gt;

&lt;p&gt;从源码中可以看到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* This function can be called asynchronously (e.g. during a signal). */
LUA_API int lua_sethook(lua_State *L, lua_Hook func, int mask, int count)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外，从&lt;code&gt;luajit&lt;/code&gt;的源码注释来看，不仅仅在信号处理函数中，在其他线程中也能被调用
&amp;gt; from a signal handler or another native thread.&lt;/p&gt;

&lt;p&gt;所以，这种方案是可行的。因此，对于单线程程序而言，可以通过设置&lt;code&gt;alarm&lt;/code&gt;来实现超时设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alarm(10);// trigger after 10s
signal(SIGALRM, laction);
status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
alarm(0)
signal(SIGALRM, SIG_DFL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而对于多线程程序，可以直接启一个定时器来来&lt;code&gt;check&lt;/code&gt;，而不用使用很恶心的信号。&lt;/p&gt;

&lt;p&gt;值得一提的是，使用这种方式触发超时&lt;code&gt;error&lt;/code&gt;可以很轻易地在&lt;code&gt;pcall&lt;/code&gt;中捕获，从而而已实现堆栈的打印等功能，方便查找和定位问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lua Table中HashMap介绍</title>
      <link>http://sysfork.com/post/2016/lua-hashtable-introduction/</link>
      <pubDate>Thu, 01 Sep 2016 17:40:08 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2016/lua-hashtable-introduction/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.lua.org/pil/2.5.html&#34;&gt;Table&lt;/a&gt; 在Lua中有着极其重要的应用，从核心语言实现，如&lt;a href=&#34;https://en.wikipedia.org/wiki/String_interning&#34;&gt;short string intern&lt;/a&gt;，
到利用&lt;a href=&#34;https://www.lua.org/pil/13.html&#34;&gt;metatable&lt;/a&gt;实现的&lt;a href=&#34;lua-users.org/wiki/LuaClassesWithMetatable&#34;&gt;class&lt;/a&gt;，table几乎无所不能。如此高频度地利用也就意味着lua必须要有一个高效的
table实现。&lt;/p&gt;

&lt;p&gt;很多语言提供了array和associative array两种数据结构。array是指以某个指定的最小整数下标(一般是0)开始的连续存储的数据结构，它有vector、list、array、ArrayList等多种名称；associative array，中文
也叫关联数组，即将一对key/pair之间关联起来，它一般也被称为map、dict等。Lua并不提供array，因为数组本身也是一种特殊的关联数组。但是从内部表示上，array和map有着极大的不同，array只需要一块连续的
内存即可实现，而map则有多种实现。Lua为了效率，将一部分整数下标的元素存储在array part中，而将其他元素存储在hashmap中，实现在外部接口不变的情况下实现了效率的最大化。array部分没有什么特别需要
优化的，其就是一整块连续的内存，存储和读取的时间复杂度都是O(1)，而hashmap的实现称为了lua table设计的重点。&lt;/p&gt;

&lt;p&gt;map有多种实现手段，在stl中，默认的map使用的是红黑树，存储和读取的时间复杂度都是O(logn)；虽然红黑树的表现十分稳定，但是实现比较复杂而且无法满足极端性能要求，
C++11中添加新的&lt;a href=&#34;http://en.cppreference.com/w/cpp/container/unordered_map&#34;&gt;unordered_map&lt;/a&gt;，其实现就是使用了一个hashmap。hashmap的基本流程是使用一个hash函数来将
一个key映射到一块连续内存中，实现在理想情况下访问和删除接近O(1)的时间复杂度。&lt;/p&gt;

&lt;p&gt;由于一般key的取值范围大于hashmap slot数目，所以不可避免地出现冲突的状况。在教科书中，解决这种冲突一般有两种方法：&lt;a href=&#34;https://en.wikipedia.org/wiki/Hash_table#Separate_chaining&#34;&gt;链表法&lt;/a&gt;
和&lt;a href=&#34;https://en.wikipedia.org/wiki/Open_addressing&#34;&gt;开放寻址法&lt;/a&gt;。链表法的实现比较简单，将冲突的元素使用链表链接起来即可；而开放寻址法则需要多次计算，直至找到一个没有冲突的slot为止。
这两者都有自己的优缺点，链表法由于使用了链表，无法充分利用CPU缓存，并且实现深拷贝难度较大；而开放寻址法无法实现删除元素的功能，并且当元素密度比较大时，效率非常低。&lt;/p&gt;

&lt;p&gt;Lua table使用了一个折中的方案，叫做&lt;a href=&#34;https://en.wikipedia.org/wiki/Coalesced_hashing&#34;&gt;Coalesced_hashing&lt;/a&gt;，结合使用了链表法和开放寻址法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/4/4c/CoalescedHash.jpg&#34; alt=&#34;Coalesced_hashing&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当插入一个元素时，定义其原本应该在的位置为mainposition，如果mainpoisition对应的slot是空的，则直接插入；如果非空，看看在那个位置上的元素的mainposition是不是当前的slot，如果不是的
话，则将其移动到任意一个空的slot(位置A)，然后将当前的元素插入到mainposition位置，并将当前的next字段设置成位置A，形成链表。如果占用元素mainposition就是当前位置，则将待插入的
元素插入到任意一个空的位置上，并链接到占用元素的后面。&lt;/p&gt;

&lt;p&gt;通过上面的过程，实现了所有的元素都尽量保存在mainposition上，当查找的时候也能使用更少的次数来找到元素位置。这对元素本来就在hashmap中，效率是比较高的。但是，当元素不在hashmap中，查找的代价
比较高。&lt;/p&gt;

&lt;p&gt;lua table的代码实现在&lt;a href=&#34;https://www.lua.org/source/5.3/ltable.c.html&#34;&gt;这里&lt;/a&gt;，实现非常简洁明了，也不是很难懂，但是对于平时经常使用lua的同学来说读一读还是很有必要的。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>