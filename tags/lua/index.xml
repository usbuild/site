<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lua on sysğŸ”±fork</title>
    <link>http://sysfork.com/tags/lua/</link>
    <description>Recent content in Lua on sysğŸ”±fork</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Mon, 01 May 2017 22:30:00 +0800</lastBuildDate>
    <atom:link href="http://sysfork.com/tags/lua/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ä¸€ç§åœ¨elfä¸­é›†æˆè„šæœ¬æ–‡ä»¶çš„æ–¹æ¡ˆ</title>
      <link>http://sysfork.com/post/a-solution-for-elf-integrate-scripts/</link>
      <pubDate>Mon, 01 May 2017 22:30:00 +0800</pubDate>
      
      <guid>http://sysfork.com/post/a-solution-for-elf-integrate-scripts/</guid>
      <description>

&lt;p&gt;è¿›è¡Œæ¸¸æˆæœåŠ¡å™¨å¼€å‘æ—¶ï¼Œæˆ‘ä»¬å°†&lt;code&gt;C++&lt;/code&gt;çš„éƒ¨åˆ†ç§°ä¹‹ä¸ºå¼•æ“å±‚ï¼Œè€Œ&lt;code&gt;lua&lt;/code&gt;ç§°ä¹‹ä¸ºè„šæœ¬å±‚ã€‚ä½†æ˜¯å¾€å¾€æœ‰äº›æ ¸å¿ƒé€»è¾‘æ˜¯å„ä¸ªæ¸¸æˆå…¬ç”¨çš„ï¼Œ
æˆ–è€…è¯´æœ‰äº›å¼•æ“å±‚çš„ä»£ç ç”¨&lt;code&gt;C++&lt;/code&gt;å†™èµ·æ¥ååˆ†éº»çƒ¦ï¼Œæˆ‘ä»¬è¿˜æ˜¯ä¼šä½¿ç”¨&lt;code&gt;lua&lt;/code&gt;æ¥ç¼–å†™ã€‚è¿™å°±å¸¦æ¥äº†ä¸€äº›é—®é¢˜ï¼Œæˆ‘ä»¬çš„æ¸¸æˆç›®å½•ç»“æ„å¦‚ä¸‹:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;â”œâ”€bin               // å¯æ‰§è¡Œæ–‡ä»¶
â””â”€scripts           // è„šæœ¬ç›®å½•ï¼Œluaæ–‡ä»¶
    â”œâ”€framework     // æ ¸å¿ƒluaæ–‡ä»¶ï¼Œå„ä¸ªé¡¹ç›®å…¬ç”¨çš„
    â””â”€server        // æ¸¸æˆé€»è¾‘luaæ–‡ä»¶
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶ä¸­&lt;code&gt;scripts/framework&lt;/code&gt;æ˜¯å„ä¸ªé¡¹ç›®å…¬ç”¨çš„ï¼Œå¹¶ä¸”å’Œ&lt;code&gt;bin&lt;/code&gt;ç›®å½•ä¸­çš„å¯æ‰§è¡Œæ–‡ä»¶åŒæ—¶å‘å¸ƒå’Œæ›´æ–°ã€‚æ‰€ä»¥æœ‰ä¸€ä¸ªæƒ³æ³•ï¼Œå°±æ˜¯å°†&lt;code&gt;framework&lt;/code&gt;ä¸­
çš„luaæ–‡ä»¶é›†æˆåˆ°å¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼Œå‡å°‘ç»´æŠ¤çš„æˆæœ¬ã€‚&lt;/p&gt;

&lt;h1 id=&#34;æ–‡ä»¶å­˜å‚¨&#34;&gt;æ–‡ä»¶å­˜å‚¨&lt;/h1&gt;

&lt;p&gt;ä¸‹é¢æ˜¯elfæ–‡ä»¶çš„ç¤ºæ„å›¾&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Elf-layout--en.svg/260px-Elf-layout--en.svg.png&#34; alt=&#34;elf&#34; /&gt;&lt;/p&gt;

&lt;p&gt;elfæ–‡ä»¶æœ‰å¤šä¸ªsectionï¼Œé™¤äº†ä¸€äº›é¢„å®šä¹‰çš„sectionå¦‚&lt;code&gt;.rodata&lt;/code&gt;ã€&lt;code&gt;.text&lt;/code&gt;ã€&lt;code&gt;.init&lt;/code&gt;ç­‰ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å®šä¹‰ä¸€äº›è‡ªå·±çš„sectionã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°†æ‰€éœ€è¦çš„luaæ–‡ä»¶
æ”¾è¿›è¿™ä¸ªsectionä¸­ï¼Œåœ¨æ‰§è¡Œçš„æ—¶å€™åŠ¨æ€è¯»å‡ºæ¥ï¼Œå®ç°ç›®çš„ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨&lt;a href=&#34;https://linux.die.net/man/1/objcopy&#34;&gt;objcopy&lt;/a&gt;å‘½ä»¤æ¥å®ç°åˆ›å»ºè‡ªå®šä¹‰sectionçš„åŠŸèƒ½ã€‚&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objcopy infile.out --add-section .lua-data=section_file outfile.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ç„¶è€Œ&lt;code&gt;framework&lt;/code&gt;é‡Œé¢æœ‰å¤šä¸ªæ–‡ä»¶ï¼Œè€Œä¸”åŒ…å«åµŒå¥—çš„æ–‡ä»¶å¤¹ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå°†æ–‡ä»¶å¤¹å˜æˆå•ä¸ªæ–‡ä»¶çš„åŠŸèƒ½ï¼Œç±»ä¼¼äº&lt;a href=&#34;https://linux.die.net/man/1/tar&#34;&gt;tar&lt;/a&gt;ã€‚è™½ç„¶åˆ›å»º
sectionæ—¶ä½¿ç”¨&lt;code&gt;tar&lt;/code&gt;å‘½ä»¤æ˜¯ç®€å•çš„ï¼Œä½†æ˜¯åœ¨è¯»å–çš„æ—¶å€™éœ€è¦ä¸€äº›ç¬¬ä¸‰æ–¹çš„åº“æ¥æ”¯æŒï¼Œè¿™æ˜¯æ¯”è¾ƒéº»çƒ¦çš„ã€‚è€Œç”±äºæˆ‘ä»¬çš„ç›®å½•ä¸­åªåŒ…å«&lt;code&gt;lua&lt;/code&gt;æ–‡ä»¶ï¼Œæ‰€ä»¥å¯ä»¥ç®€åŒ–è®¾è®¡ã€‚
é¦–å…ˆç©ºæ–‡ä»¶å¤¹å¯¹äºæˆ‘ä»¬æ˜¯æ— æ„ä¹‰çš„ï¼Œåªéœ€è¦&lt;code&gt;lua&lt;/code&gt;æ–‡ä»¶å°±å¯ä»¥ã€‚æ‰€ä»¥æœ€ç»ˆæˆ‘ä»¬å¾—åˆ°å¦‚ä¸‹çš„è¡¨:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ libs/json.lua      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ core/entity.lua    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ app/game.lua       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ libs/bson.lua      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;æˆ‘ä»¬å¯ä»¥æŒ‰ç…§å¦‚ä¸‹çš„æ ¼å¼è½¬æ¢æˆå•ä¸ªæ–‡ä»¶&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚name_lenâ”‚content_lenâ”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ core.entity        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚name_lenâ”‚content_lenâ”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ libs.bson          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ .................  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶ä¸­&lt;code&gt;name_len&lt;/code&gt;ä¸ºæ–‡ä»¶åçš„é•¿åº¦ï¼Œè¿™é‡Œç›´æ¥è½¬æ¢æˆäº†luaä¸­&lt;code&gt;require&lt;/code&gt;çš„æ ¼å¼ï¼Œä½¿ç”¨ç‚¹ç¬¦å·ã€‚&lt;code&gt;content_len&lt;/code&gt;æ˜¯æ–‡ä»¶å†…å®¹çš„é•¿åº¦ï¼Œå³æ–‡ä»¶çš„å…·ä½“å†…å®¹é•¿åº¦ã€‚æœ€åæˆ‘ä»¬å¯ä»¥ä½¿ç”¨&lt;code&gt;zip&lt;/code&gt;æŒ‡ä»¤
å°†è¿™éƒ¨åˆ†å†…å®¹å‹ç¼©å­˜å‚¨åœ¨&lt;code&gt;elf&lt;/code&gt;æ–‡ä»¶ä¸­ã€‚å®Œæ•´çš„ä»£ç å¦‚ä¸‹:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
#coding: utf-8

import os, struct, StringIO, zlib, subprocess, sys, tempfile, argparse

argParser = argparse.ArgumentParser()

argParser.add_argument(&amp;quot;luafolder&amp;quot;, type=str)
argParser.add_argument(&amp;quot;exe&amp;quot;, type=str)
argParser.add_argument(&amp;quot;out&amp;quot;, type=str)

args = argParser.parse_args()

files = []

path = args.luafolder

for (dirpath, dirname, filenames) in os.walk(path):
    dirp = dirpath[len(path):]
    if dirp:
        if dirp[-1] != &amp;quot;/&amp;quot;:
            dirp += &amp;quot;/&amp;quot;

        while dirp[0] == &amp;quot;/&amp;quot;:
            dirp = dirp[1:]

    files.extend([dirp + x for x in filenames])

output = StringIO.StringIO()

for fpath in files:
    realp = path + &amp;quot;/&amp;quot; + fpath
    filesize = os.path.getsize(realp)

    if fpath.endswith(&amp;quot;.lua&amp;quot;):
        fpath = fpath[:-4]
    elif fpath.endswith(&amp;quot;.luac&amp;quot;):
        fpath = fpath[:-5]
    else:
        continue

    package_pattern = fpath.replace(&amp;quot;/&amp;quot;, &amp;quot;.&amp;quot;)
    package_pattern = &amp;quot;pg.&amp;quot; + package_pattern
    with open(realp, &amp;quot;rb&amp;quot;) as rf:
        content = rf.read()
        output.write(struct.pack(&amp;quot;=hL&amp;quot;, len(package_pattern), len(content)))
        output.write(package_pattern)
        output.write(content)

f = tempfile.NamedTemporaryFile()

outdata = output.getvalue()
f.write(struct.pack(&amp;quot;=L&amp;quot;, len(outdata)))
f.write(zlib.compress(output.getvalue()))
f.flush()

subprocess.call(&amp;quot;objcopy %s --remove-section .lua-data&amp;quot;%(args.exe, ), shell=True)
subprocess.call(&amp;quot;objcopy %s --add-section .lua-data=%s %s&amp;quot;%(args.exe, f.name, args.out), shell=True)

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;æ–‡ä»¶å†…å®¹çš„è¯»å–&#34;&gt;æ–‡ä»¶å†…å®¹çš„è¯»å–&lt;/h1&gt;

&lt;p&gt;æˆ‘ä»¬éœ€è¦ä½¿ç”¨&lt;code&gt;elf.h&lt;/code&gt;æ–‡ä»¶æ¥è¯»å–æ–‡ä»¶å†…å®¹ã€‚æ ¹æ®ä¸Šè¿°çš„æ ¼å¼ç¤ºæ„å›¾ï¼Œ&lt;code&gt;elf&lt;/code&gt;æ–‡ä»¶å¼€å¤´çš„æ˜¯Headerï¼Œå…¶æ ¼å¼ä¸º&lt;code&gt;ElfXX_Ehdr&lt;/code&gt;ï¼Œ
æˆ‘ä»¬å¯ä»¥ç›´æ¥è¯»å–æ–‡ä»¶å†…å®¹åˆ°å†…å­˜ã€‚ç„¶åè¯»å–&lt;code&gt;e_shoff&lt;/code&gt;å­—æ®µè·å¾—section headerçš„ä½ç½®ï¼Œå®šä½åˆ°ä½ç½®å¹¶ä¾æ¬¡è¯»å–å†…å®¹åˆ°&lt;code&gt;ElfXX_Shdr&lt;/code&gt;
ç»“æ„ä½“ä¸­ï¼Œç„¶åé€šè¿‡å„ä¸ªentryçš„&lt;code&gt;sh_name&lt;/code&gt;å¾—åˆ°æœ€ç»ˆsectionï¼Œç„¶åè¯»å–æ–‡ä»¶è¾¾åˆ°ç›®çš„ã€‚å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static std::map&amp;lt;std::string, std::string&amp;gt; readElfLuaData(const std::string &amp;amp;filepath) {
    std::map&amp;lt;std::string, std::string&amp;gt; files;
#if __x86_64__
    typedef Elf64_Ehdr ELF_EHDR;
    typedef Elf64_Shdr ELF_SHDR;
#else
    typedef Elf32_Ehdr ELF_EHDR;
    typedef Elf32_Shdr ELF_SHDR;
#endif

    std::ifstream ifs(filepath);

    ELF_EHDR hdr;
    ifs.read(reinterpret_cast&amp;lt;char *&amp;gt;(&amp;amp;hdr), sizeof(hdr));

    std::vector&amp;lt;ELF_SHDR&amp;gt; sh_tables(hdr.e_shnum);
    ifs.seekg(static_cast&amp;lt;long&amp;gt;(hdr.e_shoff));

    for (size_t i = 0; i &amp;lt; hdr.e_shnum; ++i) {
        ifs.read(reinterpret_cast&amp;lt;char *&amp;gt;(&amp;amp;sh_tables[i]), sizeof(sh_tables[i]));
    }

    // read shstr

    std::vector&amp;lt;char&amp;gt; shstr(sh_tables[hdr.e_shstrndx].sh_size);
    ifs.seekg(static_cast&amp;lt;long&amp;gt;(sh_tables[hdr.e_shstrndx].sh_offset));
    ifs.read(shstr.data(), static_cast&amp;lt;long&amp;gt;(shstr.size()));

    ELF_SHDR *lua_sh = nullptr;

    for (size_t i = 0; i &amp;lt; hdr.e_shnum; ++i) {
        char *name = shstr.data() + sh_tables[i].sh_name;
        if (strcmp(name, &amp;quot;.lua-data&amp;quot;) == 0) {
            lua_sh = &amp;amp;sh_tables[i];
            break;
        }
    }

    if (lua_sh) {
        std::vector&amp;lt;char&amp;gt; buf(lua_sh-&amp;gt;sh_size);
        ifs.seekg(static_cast&amp;lt;long&amp;gt;(lua_sh-&amp;gt;sh_offset));
        ifs.read(buf.data(), static_cast&amp;lt;std::streamsize&amp;gt;(buf.size()));

        size_t idx = 0;
#define READ_TO(TARGET, SIZE)                                                                      \
    memcpy(TARGET, buf.data() + idx, SIZE);                                                        \
    idx += SIZE;

        uint32_t raw_len = 0;
        READ_TO(&amp;amp;raw_len, sizeof(raw_len));

        std::vector&amp;lt;char&amp;gt; tmp(raw_len);
        uLongf dest_len = tmp.size();
        uncompress(reinterpret_cast&amp;lt;Bytef *&amp;gt;(tmp.data()), &amp;amp;dest_len,
                   reinterpret_cast&amp;lt;Bytef *&amp;gt;(buf.data() + idx), buf.size() - idx);

        buf.swap(tmp);
        idx = 0;

        while (idx &amp;lt; dest_len) {
            uint16_t name_len;
            uint32_t content_len;
            READ_TO(&amp;amp;name_len, sizeof(name_len));
            READ_TO(&amp;amp;content_len, sizeof(content_len));
            std::string filename(name_len, 0), content(content_len, 0);
            READ_TO(&amp;amp;*filename.begin(), filename.size());
            READ_TO(&amp;amp;*content.begin(), content.size());
            files.emplace(std::piecewise_construct, std::forward_as_tuple(std::move(filename)),
                          std::forward_as_tuple(std::move(content)));
        }
#undef READ_TO
    }
    return files;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;æ¥ä¸‹æ¥ä¾¿å¯ä»¥é€šè¿‡æ·»åŠ åˆ°&lt;code&gt;package.preload&lt;/code&gt;å®ç°åœ¨luaä¸­è°ƒç”¨è¿™äº›æ–‡ä»¶çš„ç›®çš„ã€‚&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>luaä¸Cäº¤äº’ä¸­çš„æ­»å¾ªç¯æ£€æµ‹</title>
      <link>http://sysfork.com/post/lua-c-detect-inifinite-loop/</link>
      <pubDate>Fri, 21 Apr 2017 17:37:30 +0800</pubDate>
      
      <guid>http://sysfork.com/post/lua-c-detect-inifinite-loop/</guid>
      <description>

&lt;p&gt;ç°åœ¨å¾ˆå¤šæ¸¸æˆå¼•æ“éƒ½æ˜¯&lt;code&gt;C++&lt;/code&gt; + &lt;code&gt;lua&lt;/code&gt;çš„ç»“æ„ï¼Œä¸€æ—¦æŸä¸ªæœåŠ¡å™¨å¼€å‘äººå‘˜å¤§æ„å†™å‡ºæ­»å¾ªç¯ä»£ç ï¼Œå¾ˆå®¹æ˜“å¯¼è‡´æœåŠ¡æ— å“åº”ï¼Œå½±å“æœåŠ¡å™¨ç¨³å®šã€‚æ‰€ä»¥å¼•æ“ä¸­æœ€å¥½èƒ½æä¾›ä¸€ä¸ªæ­»å¾ªç¯çš„æ£€æµ‹æœºåˆ¶ï¼Œä¸€æ—¦å‡ºç°æ­»å¾ªç¯åˆ™æ‰§è¡Œä¸€äº›è¡Œä¸ºæ‰“æ–­å½“å‰æµç¨‹ã€‚&lt;/p&gt;

&lt;p&gt;æ­»å¾ªç¯çš„æ£€æµ‹æ˜¯ä¸€ä¸ª&lt;a href=&#34;https://en.wikipedia.org/wiki/Halting_problem&#34;&gt;åœæœºé—®é¢˜&lt;/a&gt;ã€‚æˆ‘ä»¬æ— æ³•åˆ¤æ–­åˆ°åº•æ˜¯ä»»åŠ¡æ‰§è¡Œæ—¶é—´è¿‡é•¿ï¼Œè¿˜æ˜¯è¿›å…¥äº†çœŸæ­£çš„æ­»å¾ªç¯ï¼Œå¥½åœ¨è¿™å¯¹æˆ‘ä»¬çš„æœåŠ¡æ¥è¯´åŒºåˆ«å¹¶ä¸é‡è¦ã€‚æ‰€ä»¥ä¸€ä¸ªç®€å•çš„åˆ¤æ–­æ¡ä»¶æ˜¯ï¼Œæ‰§è¡Œæ—¶é—´æ˜¯å¦è¶…è¿‡äº†é¢„å®šçš„é˜ˆå€¼ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C++&lt;/code&gt;ä¸­é›†æˆ&lt;code&gt;lua&lt;/code&gt;ï¼Œè°ƒç”¨åˆ°æ¸¸æˆé€»è¾‘æ—¶ï¼Œä¸€èˆ¬é€šè¿‡&lt;a href=&#34;http://pgl.yoyo.org/luai/i/lua_pcall&#34;&gt;pcall&lt;/a&gt;ï¼Œä½†æ˜¯ä¸€æ—¦è°ƒç”¨äº†&lt;code&gt;pcall&lt;/code&gt;ï¼Œä»£ç çš„æ‰§è¡Œè·¯å¾„ä¾¿è¿›å…¥äº†&lt;code&gt;lua&lt;/code&gt;çš„ä¸–ç•Œï¼Œé™¤éé€šè¿‡ä¿¡å·æœºåˆ¶æ‰èƒ½åœ¨å½“å‰çº¿ç¨‹ä¸­ä¸­æ–­ï¼Œå®ç°æ‰§è¡Œå…¶ä»–åˆ†æ”¯çš„ç›®çš„ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œ&lt;code&gt;lua&lt;/code&gt;è¿˜æä¾›äº†&lt;code&gt;debug.sethook&lt;/code&gt;å‡½æ•°ï¼Œå¯ä»¥åœ¨æ‰§è¡Œæ­£å¸¸é€»è¾‘ä¸­è§¦å‘&lt;code&gt;hook&lt;/code&gt;ï¼Œå®ç°ç›‘æµ‹è¶…æ—¶çš„åŠŸèƒ½ã€‚æ‰€ä»¥æˆ‘ä»¬æœ‰ä»¥ä¸‹ä¸¤ç§æ–¹æ¡ˆï¼š&lt;/p&gt;

&lt;h1 id=&#34;ä½¿ç”¨-debug-sethook-æ¥å®ç°&#34;&gt;ä½¿ç”¨&lt;code&gt;debug.sethook()&lt;/code&gt;æ¥å®ç°&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;debug.sethook ([thread,] hook, mask [, count])
Sets the given function as a hook. The string mask and the number count describe when the hook will be called. The string mask may have the following characters, with the given meaning:&lt;/p&gt;

&lt;p&gt;&amp;ldquo;c&amp;rdquo;: the hook is called every time Lua calls a function;
&amp;ldquo;r&amp;rdquo;: the hook is called every time Lua returns from a function;
&amp;ldquo;l&amp;rdquo;: the hook is called every time Lua enters a new line of code.
With a count different from zero, the hook is called after every count instructions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;æ‰€ä»¥æˆ‘ä»¬åªè¦åœ¨æ‰§è¡Œ&lt;code&gt;pcall&lt;/code&gt;ä¹‹å‰è®¾å®šç±»ä¼¼å¦‚ä¸‹çš„ä»£ç :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;debug.sethook(function()error(&amp;quot;timeout&amp;quot;)end, &amp;quot;c&amp;quot;, 10000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ç†è®ºä¸Šåªè¦ä»£ç æŒ‡ä»¤æ•°è¶…è¿‡10000æ¡å°±èƒ½è§¦å‘&lt;code&gt;error&lt;/code&gt;ã€‚å¥½åƒæŒºå®Œç¾çš„ã€‚&lt;/p&gt;

&lt;p&gt;Butï¼Œåœ¨&lt;code&gt;luajit&lt;/code&gt;ä¸‹è¿™æ¡ä¸ä¸€å®šæˆç«‹ï¼Œå› ä¸ºæ‰§è¡Œçš„é€»è¾‘è¢«&lt;code&gt;jit&lt;/code&gt;ç¼–è¯‘äº†ï¼Œè€Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ&lt;code&gt;hook&lt;/code&gt;æ˜¯ä¸ä¼šè§¦å‘çš„&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If your program is running in a tight loop and never falls back to the interpreter, the debug hook never runs and can&amp;rsquo;t throw the &amp;ldquo;interrupted!&amp;rdquo; error.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ä½†æ˜¯è¿˜æœ‰ä¸€ä¸ªæœªå…¬å¼€çš„ç¼–è¯‘é€‰é¡¹&lt;code&gt;LUAJIT_ENABLE_CHECKHOOK&lt;/code&gt;ï¼Œåœ¨&lt;code&gt;lj_record.c&lt;/code&gt;æ–‡ä»¶çš„æœ€åé¢ï¼Œä¸Šé¢å†™é“&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Regularly check for instruction/line hooks from compiled code and
exit to the interpreter if the hooks are set.&lt;/p&gt;

&lt;p&gt;This is a compile-time option and disabled by default, since the
hook checks may be quite expensive in tight loops.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;çœ‹ä¼¼å¯ä»¥ï¼Œä½†æ˜¯æ³¨æ„ï¼Œå¦‚æœ&lt;code&gt;hook&lt;/code&gt;è¢«è®¾ç½®äº†ï¼Œåˆ™æ‰§è¡Œçš„ä»£ä»·æ˜¯æ¯”è¾ƒæ˜‚è´µçš„ã€‚å¯¹äºæ¸¸æˆè€Œè¨€ï¼Œå¤§éƒ¨åˆ†çš„æ—¶é—´éƒ½åœ¨&lt;code&gt;lua&lt;/code&gt;å±‚ï¼Œè€Œä¸ºäº†ç›‘æµ‹æ­»å¾ªç¯ï¼Œå‡ ä¹
è¦åœ¨æ‰€æœ‰çš„luaæ‰§è¡Œè¿‡ç¨‹ä¸­è®¾ç½®&lt;code&gt;hook&lt;/code&gt;ï¼Œè¿™æ˜¯ä¸å¤ªå®¹æ˜“æ¥å—çš„ã€‚å¥½åœ¨ä¸‹é¢çš„æ³¨é‡Šæåˆ°äº†&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can set the instruction hook via lua_sethook() with a count of 1
from a signal handler or another native thread. Please have a look
at the first few functions in luajit.c for an example (Ctrl-C handler).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;å—¯ï¼Œçœ‹æ ·å­åªèƒ½ä½¿ç”¨ç¬¬äºŒç§æ–¹æ¡ˆäº†ã€‚&lt;/p&gt;

&lt;h1 id=&#34;ä½¿ç”¨ä¿¡å·æ¥å®ç°&#34;&gt;ä½¿ç”¨ä¿¡å·æ¥å®ç°&lt;/h1&gt;

&lt;p&gt;åœ¨luaçš„å‘½ä»¤è¡Œç¨‹åºä¸­æˆ‘ä»¬å¯ä»¥é€šè¿‡&lt;code&gt;Ctrl-C&lt;/code&gt;ä¸­æ–­æ­£åœ¨æ‰§è¡Œçš„ç¨‹åº&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;  for i=1,10000000 do sum = sum + i end
^Cinterrupted!
stack traceback:
        stdin:1: in main chunk
        [C]: in ?

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ä»”ç»†çœ‹&lt;code&gt;lua.c&lt;/code&gt;æ–‡ä»¶ï¼Œå¯ä»¥çœ‹åˆ°ä»¥ä¸‹ä»£ç &lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;static void lstop (lua_State *L, lua_Debug *ar) {
  (void)ar;  /* unused arg. */
  lua_sethook(L, NULL, 0, 0);
  luaL_error(L, &amp;quot;interrupted!&amp;quot;);
}


static void laction (int i) {
  signal(i, SIG_DFL); /* if another SIGINT happens before lstop,
                              terminate process (default action) */
  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
}

// ....
//in docall
signal(SIGINT, laction);
status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
signal(SIGINT, SIG_DFL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å—¯ï¼Œåœ¨æ‰§è¡Œ&lt;code&gt;pcall&lt;/code&gt;ä¹‹å‰è®¾ç½®äº†ä¿¡å·å¤„ç†å‡½æ•°ï¼Œæ•æ‰&lt;code&gt;Ctrl-C&lt;/code&gt;çš„ä¿¡å·ï¼Œä¸€æ—¦å‘ç”Ÿï¼Œåˆ™ç«‹é©¬è°ƒç”¨&lt;code&gt;lua_sethook&lt;/code&gt;å‡½æ•°ï¼ŒæŒ‡å®šåœ¨æ‰§è¡Œä¸‹ä¸€è¡Œä»£ç æ—¶è°ƒç”¨&lt;code&gt;lstop&lt;/code&gt;ï¼Œè€Œåœ¨&lt;code&gt;lstop&lt;/code&gt;ä¸­å°±ç›´æ¥æŠ›å‡º&lt;code&gt;error&lt;/code&gt;äº†ã€‚æ‰€ä»¥é—®é¢˜æ˜¯ &lt;strong&gt;&lt;code&gt;lua_sethook&lt;/code&gt;æ˜¯å¯ä»¥åœ¨ä¿¡å·å¤„ç†å‡½æ•°ä¸­è°ƒç”¨çš„&lt;/strong&gt;ï¼Ÿ&lt;/p&gt;

&lt;p&gt;ç­”æ¡ˆï¼šæ˜¯&lt;/p&gt;

&lt;p&gt;ä»æºç ä¸­å¯ä»¥çœ‹åˆ°&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* This function can be called asynchronously (e.g. during a signal). */
LUA_API int lua_sethook(lua_State *L, lua_Hook func, int mask, int count)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;é™¤æ­¤ä¹‹å¤–ï¼Œä»&lt;code&gt;luajit&lt;/code&gt;çš„æºç æ³¨é‡Šæ¥çœ‹ï¼Œä¸ä»…ä»…åœ¨ä¿¡å·å¤„ç†å‡½æ•°ä¸­ï¼Œåœ¨å…¶ä»–çº¿ç¨‹ä¸­ä¹Ÿèƒ½è¢«è°ƒç”¨
&amp;gt; from a signal handler or another native thread.&lt;/p&gt;

&lt;p&gt;æ‰€ä»¥ï¼Œè¿™ç§æ–¹æ¡ˆæ˜¯å¯è¡Œçš„ã€‚å› æ­¤ï¼Œå¯¹äºå•çº¿ç¨‹ç¨‹åºè€Œè¨€ï¼Œå¯ä»¥é€šè¿‡è®¾ç½®&lt;code&gt;alarm&lt;/code&gt;æ¥å®ç°è¶…æ—¶è®¾ç½®&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alarm(10);// trigger after 10s
signal(SIGALRM, laction);
status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
alarm(0)
signal(SIGALRM, SIG_DFL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è€Œå¯¹äºå¤šçº¿ç¨‹ç¨‹åºï¼Œå¯ä»¥ç›´æ¥å¯ä¸€ä¸ªå®šæ—¶å™¨æ¥æ¥&lt;code&gt;check&lt;/code&gt;ï¼Œè€Œä¸ç”¨ä½¿ç”¨å¾ˆæ¶å¿ƒçš„ä¿¡å·ã€‚&lt;/p&gt;

&lt;p&gt;å€¼å¾—ä¸€æçš„æ˜¯ï¼Œä½¿ç”¨è¿™ç§æ–¹å¼è§¦å‘è¶…æ—¶&lt;code&gt;error&lt;/code&gt;å¯ä»¥å¾ˆè½»æ˜“åœ°åœ¨&lt;code&gt;pcall&lt;/code&gt;ä¸­æ•è·ï¼Œä»è€Œè€Œå·²å®ç°å †æ ˆçš„æ‰“å°ç­‰åŠŸèƒ½ï¼Œæ–¹ä¾¿æŸ¥æ‰¾å’Œå®šä½é—®é¢˜ã€‚&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lua Tableä¸­HashMapä»‹ç»</title>
      <link>http://sysfork.com/post/lua-hashtable-introduction/</link>
      <pubDate>Thu, 01 Sep 2016 17:40:08 +0800</pubDate>
      
      <guid>http://sysfork.com/post/lua-hashtable-introduction/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.lua.org/pil/2.5.html&#34;&gt;Table&lt;/a&gt; åœ¨Luaä¸­æœ‰ç€æå…¶é‡è¦çš„åº”ç”¨ï¼Œä»æ ¸å¿ƒè¯­è¨€å®ç°ï¼Œå¦‚&lt;a href=&#34;https://en.wikipedia.org/wiki/String_interning&#34;&gt;short string intern&lt;/a&gt;ï¼Œ
åˆ°åˆ©ç”¨&lt;a href=&#34;https://www.lua.org/pil/13.html&#34;&gt;metatable&lt;/a&gt;å®ç°çš„&lt;a href=&#34;lua-users.org/wiki/LuaClassesWithMetatable&#34;&gt;class&lt;/a&gt;ï¼Œtableå‡ ä¹æ— æ‰€ä¸èƒ½ã€‚å¦‚æ­¤é«˜é¢‘åº¦åœ°åˆ©ç”¨ä¹Ÿå°±æ„å‘³ç€luaå¿…é¡»è¦æœ‰ä¸€ä¸ªé«˜æ•ˆçš„
tableå®ç°ã€‚&lt;/p&gt;

&lt;p&gt;å¾ˆå¤šè¯­è¨€æä¾›äº†arrayå’Œassociative arrayä¸¤ç§æ•°æ®ç»“æ„ã€‚arrayæ˜¯æŒ‡ä»¥æŸä¸ªæŒ‡å®šçš„æœ€å°æ•´æ•°ä¸‹æ ‡(ä¸€èˆ¬æ˜¯0)å¼€å§‹çš„è¿ç»­å­˜å‚¨çš„æ•°æ®ç»“æ„ï¼Œå®ƒæœ‰vectorã€listã€arrayã€ArrayListç­‰å¤šç§åç§°ï¼›associative arrayï¼Œä¸­æ–‡
ä¹Ÿå«å…³è”æ•°ç»„ï¼Œå³å°†ä¸€å¯¹key/pairä¹‹é—´å…³è”èµ·æ¥ï¼Œå®ƒä¸€èˆ¬ä¹Ÿè¢«ç§°ä¸ºmapã€dictç­‰ã€‚Luaå¹¶ä¸æä¾›arrayï¼Œå› ä¸ºæ•°ç»„æœ¬èº«ä¹Ÿæ˜¯ä¸€ç§ç‰¹æ®Šçš„å…³è”æ•°ç»„ã€‚ä½†æ˜¯ä»å†…éƒ¨è¡¨ç¤ºä¸Šï¼Œarrayå’Œmapæœ‰ç€æå¤§çš„ä¸åŒï¼Œarrayåªéœ€è¦ä¸€å—è¿ç»­çš„
å†…å­˜å³å¯å®ç°ï¼Œè€Œmapåˆ™æœ‰å¤šç§å®ç°ã€‚Luaä¸ºäº†æ•ˆç‡ï¼Œå°†ä¸€éƒ¨åˆ†æ•´æ•°ä¸‹æ ‡çš„å…ƒç´ å­˜å‚¨åœ¨array partä¸­ï¼Œè€Œå°†å…¶ä»–å…ƒç´ å­˜å‚¨åœ¨hashmapä¸­ï¼Œå®ç°åœ¨å¤–éƒ¨æ¥å£ä¸å˜çš„æƒ…å†µä¸‹å®ç°äº†æ•ˆç‡çš„æœ€å¤§åŒ–ã€‚arrayéƒ¨åˆ†æ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«éœ€è¦
ä¼˜åŒ–çš„ï¼Œå…¶å°±æ˜¯ä¸€æ•´å—è¿ç»­çš„å†…å­˜ï¼Œå­˜å‚¨å’Œè¯»å–çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯O(1)ï¼Œè€Œhashmapçš„å®ç°ç§°ä¸ºäº†lua tableè®¾è®¡çš„é‡ç‚¹ã€‚&lt;/p&gt;

&lt;p&gt;mapæœ‰å¤šç§å®ç°æ‰‹æ®µï¼Œåœ¨stlä¸­ï¼Œé»˜è®¤çš„mapä½¿ç”¨çš„æ˜¯çº¢é»‘æ ‘ï¼Œå­˜å‚¨å’Œè¯»å–çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯O(logn)ï¼›è™½ç„¶çº¢é»‘æ ‘çš„è¡¨ç°ååˆ†ç¨³å®šï¼Œä½†æ˜¯å®ç°æ¯”è¾ƒå¤æ‚è€Œä¸”æ— æ³•æ»¡è¶³æç«¯æ€§èƒ½è¦æ±‚ï¼Œ
C++11ä¸­æ·»åŠ æ–°çš„&lt;a href=&#34;http://en.cppreference.com/w/cpp/container/unordered_map&#34;&gt;unordered_map&lt;/a&gt;ï¼Œå…¶å®ç°å°±æ˜¯ä½¿ç”¨äº†ä¸€ä¸ªhashmapã€‚hashmapçš„åŸºæœ¬æµç¨‹æ˜¯ä½¿ç”¨ä¸€ä¸ªhashå‡½æ•°æ¥å°†
ä¸€ä¸ªkeyæ˜ å°„åˆ°ä¸€å—è¿ç»­å†…å­˜ä¸­ï¼Œå®ç°åœ¨ç†æƒ³æƒ…å†µä¸‹è®¿é—®å’Œåˆ é™¤æ¥è¿‘O(1)çš„æ—¶é—´å¤æ‚åº¦ã€‚&lt;/p&gt;

&lt;p&gt;ç”±äºä¸€èˆ¬keyçš„å–å€¼èŒƒå›´å¤§äºhashmap slotæ•°ç›®ï¼Œæ‰€ä»¥ä¸å¯é¿å…åœ°å‡ºç°å†²çªçš„çŠ¶å†µã€‚åœ¨æ•™ç§‘ä¹¦ä¸­ï¼Œè§£å†³è¿™ç§å†²çªä¸€èˆ¬æœ‰ä¸¤ç§æ–¹æ³•ï¼š&lt;a href=&#34;https://en.wikipedia.org/wiki/Hash_table#Separate_chaining&#34;&gt;é“¾è¡¨æ³•&lt;/a&gt;
å’Œ&lt;a href=&#34;https://en.wikipedia.org/wiki/Open_addressing&#34;&gt;å¼€æ”¾å¯»å€æ³•&lt;/a&gt;ã€‚é“¾è¡¨æ³•çš„å®ç°æ¯”è¾ƒç®€å•ï¼Œå°†å†²çªçš„å…ƒç´ ä½¿ç”¨é“¾è¡¨é“¾æ¥èµ·æ¥å³å¯ï¼›è€Œå¼€æ”¾å¯»å€æ³•åˆ™éœ€è¦å¤šæ¬¡è®¡ç®—ï¼Œç›´è‡³æ‰¾åˆ°ä¸€ä¸ªæ²¡æœ‰å†²çªçš„slotä¸ºæ­¢ã€‚
è¿™ä¸¤è€…éƒ½æœ‰è‡ªå·±çš„ä¼˜ç¼ºç‚¹ï¼Œé“¾è¡¨æ³•ç”±äºä½¿ç”¨äº†é“¾è¡¨ï¼Œæ— æ³•å……åˆ†åˆ©ç”¨CPUç¼“å­˜ï¼Œå¹¶ä¸”å®ç°æ·±æ‹·è´éš¾åº¦è¾ƒå¤§ï¼›è€Œå¼€æ”¾å¯»å€æ³•æ— æ³•å®ç°åˆ é™¤å…ƒç´ çš„åŠŸèƒ½ï¼Œå¹¶ä¸”å½“å…ƒç´ å¯†åº¦æ¯”è¾ƒå¤§æ—¶ï¼Œæ•ˆç‡éå¸¸ä½ã€‚&lt;/p&gt;

&lt;p&gt;Lua tableä½¿ç”¨äº†ä¸€ä¸ªæŠ˜ä¸­çš„æ–¹æ¡ˆï¼Œå«åš&lt;a href=&#34;https://en.wikipedia.org/wiki/Coalesced_hashing&#34;&gt;Coalesced_hashing&lt;/a&gt;ï¼Œç»“åˆä½¿ç”¨äº†é“¾è¡¨æ³•å’Œå¼€æ”¾å¯»å€æ³•ã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/4/4c/CoalescedHash.jpg&#34; alt=&#34;Coalesced_hashing&#34; /&gt;&lt;/p&gt;

&lt;p&gt;å½“æ’å…¥ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œå®šä¹‰å…¶åŸæœ¬åº”è¯¥åœ¨çš„ä½ç½®ä¸ºmainpositionï¼Œå¦‚æœmainpoisitionå¯¹åº”çš„slotæ˜¯ç©ºçš„ï¼Œåˆ™ç›´æ¥æ’å…¥ï¼›å¦‚æœéç©ºï¼Œçœ‹çœ‹åœ¨é‚£ä¸ªä½ç½®ä¸Šçš„å…ƒç´ çš„mainpositionæ˜¯ä¸æ˜¯å½“å‰çš„slotï¼Œå¦‚æœä¸æ˜¯çš„
è¯ï¼Œåˆ™å°†å…¶ç§»åŠ¨åˆ°ä»»æ„ä¸€ä¸ªç©ºçš„slot(ä½ç½®A)ï¼Œç„¶åå°†å½“å‰çš„å…ƒç´ æ’å…¥åˆ°mainpositionä½ç½®ï¼Œå¹¶å°†å½“å‰çš„nextå­—æ®µè®¾ç½®æˆä½ç½®Aï¼Œå½¢æˆé“¾è¡¨ã€‚å¦‚æœå ç”¨å…ƒç´ mainpositionå°±æ˜¯å½“å‰ä½ç½®ï¼Œåˆ™å°†å¾…æ’å…¥çš„
å…ƒç´ æ’å…¥åˆ°ä»»æ„ä¸€ä¸ªç©ºçš„ä½ç½®ä¸Šï¼Œå¹¶é“¾æ¥åˆ°å ç”¨å…ƒç´ çš„åé¢ã€‚&lt;/p&gt;

&lt;p&gt;é€šè¿‡ä¸Šé¢çš„è¿‡ç¨‹ï¼Œå®ç°äº†æ‰€æœ‰çš„å…ƒç´ éƒ½å°½é‡ä¿å­˜åœ¨mainpositionä¸Šï¼Œå½“æŸ¥æ‰¾çš„æ—¶å€™ä¹Ÿèƒ½ä½¿ç”¨æ›´å°‘çš„æ¬¡æ•°æ¥æ‰¾åˆ°å…ƒç´ ä½ç½®ã€‚è¿™å¯¹å…ƒç´ æœ¬æ¥å°±åœ¨hashmapä¸­ï¼Œæ•ˆç‡æ˜¯æ¯”è¾ƒé«˜çš„ã€‚ä½†æ˜¯ï¼Œå½“å…ƒç´ ä¸åœ¨hashmapä¸­ï¼ŒæŸ¥æ‰¾çš„ä»£ä»·
æ¯”è¾ƒé«˜ã€‚&lt;/p&gt;

&lt;p&gt;lua tableçš„ä»£ç å®ç°åœ¨&lt;a href=&#34;https://www.lua.org/source/5.3/ltable.c.html&#34;&gt;è¿™é‡Œ&lt;/a&gt;ï¼Œå®ç°éå¸¸ç®€æ´æ˜äº†ï¼Œä¹Ÿä¸æ˜¯å¾ˆéš¾æ‡‚ï¼Œä½†æ˜¯å¯¹äºå¹³æ—¶ç»å¸¸ä½¿ç”¨luaçš„åŒå­¦æ¥è¯´è¯»ä¸€è¯»è¿˜æ˜¯å¾ˆæœ‰å¿…è¦çš„ã€‚&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>