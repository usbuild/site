<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lua on sysğŸ”±fork</title>
    <link>http://sysfork.com/tags/lua/</link>
    <description>Recent content in Lua on sysğŸ”±fork</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy; 2017. All rights reserved.</copyright>
    <lastBuildDate>Thu, 25 May 2017 14:26:47 +0800</lastBuildDate>
    <atom:link href="http://sysfork.com/tags/lua/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>lua 5.1 åˆ†æ”¯è¯­å¥ bytecode çš„ç”Ÿæˆï¼ˆäºŒï¼‰</title>
      <link>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-2/</link>
      <pubDate>Thu, 25 May 2017 14:26:47 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-2/</guid>
      <description>&lt;p&gt;ä¸Šç¯‡æˆ‘ä»¬è°ˆåˆ°äº† IF è¯­å¥çš„ bytecode ç”Ÿæˆï¼Œä»Šå¤©æ¥è°ˆè°ˆå¸ƒå°”è¡¨è¾¾å¼ä¸çŸ­è·¯æ±‚å€¼ã€‚&lt;/p&gt;

&lt;p&gt;è€ƒè™‘åˆ°ä¸‹é¢çš„è¡¨è¾¾å¼&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;a = a or 1024
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶ç”Ÿæˆçš„å­—èŠ‚ç ä¸º&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1       [1]     GETGLOBAL       0 -1    ; a
2       [1]     TEST            0 0 1
3       [1]     JMP             1       ; to 5
4       [1]     LOADK           0 -2    ; 1024
5       [1]     SETGLOBAL       0 -1    ; a
6       [1]     RETURN          0 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶å®ä¸&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;if not a then
    a = 1024
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ç”Ÿæˆçš„ä»£ç å‡ ä¹ä¸€è‡´ï¼Œåªæ˜¯å°‘äº†åƒè‡ªå·±èµ‹å€¼çš„é‚£éƒ¨åˆ†ã€‚ç°åœ¨æˆ‘ä»¬çœ‹çœ‹è¿™æ¡çŸ­è·¯æ±‚å€¼è¯­å¥çš„å­—èŠ‚ç æ˜¯æ€ä¹ˆç”Ÿæˆçš„ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a = a or 1024&lt;/code&gt; è¿™æ˜¯ä¸€ä¸ªèµ‹å€¼è¯­å¥ï¼Œæ‰€ä»¥è°ƒç”¨ä½¿ç”¨çš„æ˜¯&lt;code&gt;assignment&lt;/code&gt;å‡½æ•°ï¼Œå…¶ä¸­æˆ‘ä»¬å…³æ³¨çš„è°ƒç”¨é“¾æ˜¯
&lt;code&gt;assignment -&amp;gt; luaK_storeevar -&amp;gt; luaK_exp2anyreg -&amp;gt; luaK_exp2nextreg -&amp;gt; exp2reg&lt;/code&gt; ç”±äº &lt;code&gt;a or 1024&lt;/code&gt;æ˜¯ä¸ªäºŒå…ƒè¿ç®—ç¬¦ï¼Œ
åœ¨ä»£ç ä¸­å¯ä»¥çœ‹åˆ°ï¼Œåœ¨è¯»åˆ°&lt;code&gt;or&lt;/code&gt;ä¹‹å‰æ˜¯&lt;code&gt;luaK_infix&lt;/code&gt;ï¼Œè¯»åˆ°&lt;code&gt;or&lt;/code&gt;ä¹‹åæ˜¯&lt;code&gt;luaK_postfix&lt;/code&gt;ï¼Œæˆ‘ä»¬çœ‹çœ‹ä¸¤è€…çš„åšæ³•ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- luaK_infix
716	    case OPR_OR: {
717	      luaK_goiffalse(fs, v);
718	      break;
719	    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;-- luaK_postfix
746	    case OPR_OR: {
747	      lua_assert(e1-&amp;gt;f == NO_JUMP);  /* list must be closed */
748	      luaK_dischargevars(fs, e2);
749	      luaK_concat(fs, &amp;amp;e2-&amp;gt;t, e1-&amp;gt;t);
750	      *e1 = *e2;
751	      break;
752	    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…³é”®è¿˜æ˜¯ä¸Šæ–‡è¯´åˆ°çš„&lt;code&gt;luaK_goiffalse&lt;/code&gt;ï¼Œ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;580	  luaK_concat(fs, &amp;amp;e-&amp;gt;t, pc);  /* insert last jump in `t&#39; list */
581	  luaK_patchtohere(fs, e-&amp;gt;f);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å¦‚æœè¿”å› true çš„è¯ï¼Œé‚£ä¹ˆè·³è½¬åˆ°æŸä¸ªâ€œæœªçŸ¥â€çš„åœ°æ–¹ï¼Œfalse çš„è¯ç›´æ¥æ‰§è¡Œä¸‹ä¸€å¥ã€‚é‚£ä¹ˆè¿™ä¸ªâ€œæœªçŸ¥â€çš„åœ°æ–¹æ˜¯æ€ä¹ˆç¡®å®šçš„å‘¢ï¼Ÿ
ç­”æ¡ˆåœ¨&lt;code&gt;exp2reg&lt;/code&gt;é‡Œé¢ã€‚&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;394	  if (hasjumps(e)) {
395	    int final;  /* position after whole expression */
396	    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
397	    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
398	    if (need_value(fs, e-&amp;gt;t) || need_value(fs, e-&amp;gt;f)) {
399	      int fj = (e-&amp;gt;k == VJMP) ? NO_JUMP : luaK_jump(fs);
400	      p_f = code_label(fs, reg, 0, 1);
401	      p_t = code_label(fs, reg, 1, 0);
402	      luaK_patchtohere(fs, fj);
403	    }
404	    final = luaK_getlabel(fs);
405	    patchlistaux(fs, e-&amp;gt;f, final, reg, p_f);
406	    patchlistaux(fs, e-&amp;gt;t, final, reg, p_t);
407	  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ç”±äºæˆ‘ä»¬è®¾ç½®äº†&lt;code&gt;e-&amp;gt;t&lt;/code&gt;æˆ–&lt;code&gt;e-&amp;gt;f&lt;/code&gt;ï¼Œæ‰€ä»¥&lt;code&gt;hasjumps&lt;/code&gt;åˆ¤æ–­æˆç«‹ã€‚ç”±äº&lt;code&gt;TESTSET&lt;/code&gt;å·²ç»æä¾›äº†èµ‹å€¼çš„å¯„å­˜å™¨ï¼Œå› æ­¤æ˜¯ä¸éœ€è¦é¢å¤–è®°å½•åˆ¤æ–­ç»“æœçš„ã€‚è€Œå¯¹äºå…¶ä»–çš„å…¥&lt;code&gt;LT&lt;/code&gt;ã€&lt;code&gt;JMP&lt;/code&gt;ç­‰ï¼Œå…¶æœ¬èº«æ˜¯ä¸è®°å½•ä»»ä½•åˆ¤æ–­ç»“æœçš„ï¼Œä¸ºäº†è®°å½•åªèƒ½åœ¨ JMP å®Œæˆä¹‹åï¼Œè®¾ç½®åˆ°å¯„å­˜å™¨ä¸­ï¼Œ
è¿™ä¹Ÿå°±æ˜¯æ­¤å¤„&lt;code&gt;code_label&lt;/code&gt;å­˜åœ¨çš„åŸå› ã€‚æ¥ä¸‹æ¥æ˜¯&lt;code&gt;patchlistaux&lt;/code&gt;ï¼Œå…¶å®šä¹‰å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;150	static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
151	                          int dtarget) {
152	  while (list != NO_JUMP) {
153	    int next = getjump(fs, list);
154	    if (patchtestreg(fs, list, reg))
155	      fixjump(fs, list, vtarget);
156	    else
157	      fixjump(fs, list, dtarget);  /* jump to default target */
158	    list = next;
159	  }
160	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶ä¸­ &lt;code&gt;patchtestreg&lt;/code&gt;å®šä¹‰å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;131	static int patchtestreg (FuncState *fs, int node, int reg) {
132	  Instruction *i = getjumpcontrol(fs, node);
133	  if (GET_OPCODE(*i) != OP_TESTSET)
134	    return 0;  /* cannot patch other instructions */
135	  if (reg != NO_REG &amp;amp;&amp;amp; reg != GETARG_B(*i))
136	    SETARG_A(*i, reg);
137	  else  /* no register to put value or register already has the value */
138	    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));
139	
140	  return 1;
141	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶ä¸­&lt;code&gt;vtarget&lt;/code&gt;æ˜¯æˆ‘ä»¬å½“å‰çš„ä½ç½®&lt;code&gt;final&lt;/code&gt;ï¼Œè€Œ&lt;code&gt;dtarget&lt;/code&gt;æ˜¯&lt;code&gt;p_f&lt;/code&gt;æˆ–&lt;code&gt;p_t&lt;/code&gt;ã€‚è¿™ä¸¤æ¡è¯­å¥çš„ä½œç”¨å…¶å®æ˜¯å°†æœ€ç»ˆ&lt;code&gt;TESTSET&lt;/code&gt;æŒ‡ä»¤çš„ç»“æœä¼ é€åˆ°&lt;code&gt;reg&lt;/code&gt;ï¼Œ
å¦‚æœä¸æ˜¯&lt;code&gt;TESTSET&lt;/code&gt;çš„è¯é‚£ä¹ˆè¯´æ˜ä¸äº§ç”Ÿå€¼ï¼Œé‚£&lt;code&gt;reg&lt;/code&gt;å°±éœ€è¦ä¸Šé¢çš„&lt;code&gt;codelabel&lt;/code&gt;æ¥äº§ç”Ÿäº†ã€‚è‡³æ­¤è¿™éƒ¨åˆ†ä»£ç åˆ†æå®Œæˆã€‚&lt;/p&gt;

&lt;p&gt;ä¸‹é¢æ˜¯ä¸€äº›å‡½æ•°çš„ç®€å•è§£é‡Šï¼Œå¯ä»¥ç¨å¾®çœ‹çœ‹ï¼š&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaK_nil&lt;/code&gt;å‡½æ•°ï¼Œç”Ÿæˆçš„æ˜¯&lt;code&gt;LOADNIL&lt;/code&gt;å­—èŠ‚ç ï¼Œå…¶ä½œç”¨æ˜¯å°†from ~ from + nä¹‹é—´çš„å¯„å­˜å™¨è®¾ç½®æˆnilï¼Œè¿™é‡Œåšäº†ä¸€äº›ä¼˜åŒ–å¦‚ï¼šå¦‚æœåˆå¹¶ç›¸é‚»çš„&lt;code&gt;LOADNIL&lt;/code&gt;ï¼Œå‡½æ•°åˆå§‹åŒ–æ—¶å¯ä»¥ä¸éœ€è¦é‡å¤åˆå§‹åŒ–ç­‰ã€‚
æ³¨æ„ä¼˜åŒ–çš„å‰ææ˜¯&lt;code&gt;fs-&amp;gt;pc &amp;gt; fs-&amp;gt;lasttarget&lt;/code&gt;ï¼Œå³è¿™æ¡æŒ‡ä»¤å¿…é¡»å¯ä»¥çœç•¥ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaK_jump&lt;/code&gt;å‡½æ•°ï¼Œå…¶ç›®çš„æ˜¯ç”Ÿæˆä¸€ä¸ª&lt;code&gt;JMP&lt;/code&gt;æŒ‡ä»¤ã€‚è¿™æ˜¯ä¸ªæ— æ¡ä»¶è·³è½¬æŒ‡ä»¤ã€‚é‚£ä¹ˆå…¶ç›®æ ‡å‘¢ï¼Ÿå…¶å®å°±æ˜¯ &lt;code&gt;fs-&amp;gt;jps&lt;/code&gt;ã€‚æ³¨æ„åé¢çš„&lt;code&gt;luaK_contat&lt;/code&gt;ï¼Œå…¶ç›®çš„æ˜¯å°†l2é“¾æ¥åˆ°l1çš„åé¢ï¼Œè¿™æ˜¯ä¸ºäº†è¿ç»­è·³è½¬
è€ƒè™‘çš„ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;condjump&lt;/code&gt; ç”Ÿæˆæ¡ä»¶è·³è½¬è¯­å¥ï¼Œluaä¸ºäº†ç”Ÿæˆå­—èŠ‚ç çš„ä¾¿åˆ©æ€§ï¼Œæ¯ä¸ªæ¡ä»¶è°ƒè½¬è¯­å¥å¦‚&lt;code&gt;LT&lt;/code&gt;, &lt;code&gt;TEST&lt;/code&gt;ç­‰åé¢éƒ½è·Ÿç€ä¸€ä¸ª&lt;code&gt;JMP&lt;/code&gt;ï¼Œå½“æ¡ä»¶ä¸æ»¡è¶³æ—¶ç›´æ¥æŒ‡å‘&lt;code&gt;JMP&lt;/code&gt;è¯­å¥ï¼Œå¦åˆ™å°±è·³åˆ°&lt;code&gt;JMP&lt;/code&gt;çš„ä¸‹ä¸€æ¡ï¼Œ
å‡å°‘äº†ç¼–ç çš„å¤æ‚åº¦å•Š&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fixjump&lt;/code&gt;æŠŠ&lt;code&gt;PC&lt;/code&gt;å¤„çš„æŒ‡ä»¤ï¼ˆå½“ç„¶æ˜¯JMPæŒ‡ä»¤ï¼‰æ”¹æˆç›®æ ‡ä¸º&lt;code&gt;dest&lt;/code&gt;ï¼Œå½“ç„¶æ˜¯ç›¸å¯¹åœ°å€äº†&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaK_getlabel&lt;/code&gt;ï¼Œæ ‡è®°ä¸€ä¸‹ï¼ŒæŠŠå½“å‰çš„lasttargetæ”¹æˆpcï¼Œè¿™ä¸ªlasttargetå°±æ˜¯å’Œä¸Šé¢çš„&lt;code&gt;luaK_nil&lt;/code&gt;ç»“åˆèµ·æ¥çš„ï¼Œé˜²æ­¢ä¸Šé¢çš„è¯¯ä¼˜åŒ–ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getjump&lt;/code&gt;å’Œä¸Šé¢çš„fixjumpç›¸å¯¹åº”ï¼Œè¿”å›PCæ‰€åœ¨é‚£æ¡æŒ‡ä»¤çš„è·³è½¬ç›®æ ‡ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getjumpcontrol&lt;/code&gt; ç”±äº&lt;code&gt;JMP&lt;/code&gt;ä¸Šä¸€æ¡å¾ˆå¤šæƒ…å†µä¸‹éƒ½æ˜¯è·Ÿç€æ¡ä»¶è·³è½¬æŒ‡ä»¤çš„ï¼Œé‚£ä¹ˆè¿™æ¡æŒ‡ä»¤å°±æ˜¯è·å–è¿™æ¡æ¡ä»¶è·³è½¬æŒ‡ä»¤çš„ã€‚å¦‚æœæ˜¯é‚£ä¹ˆè¿”å›ä¸Šä¸€æ¡ï¼Œå¦åˆ™è¿”å›å½“å‰pcã€‚é™¤äº†&lt;code&gt;jmp&lt;/code&gt;ä¹‹å¤–ï¼Œå…¶ä»–å¦‚&lt;code&gt;FORLOOP&lt;/code&gt;, &lt;code&gt;FORPREP&lt;/code&gt;ç­‰æŒ‡ä»¤ä¹Ÿä¼šäº§ç”Ÿè·³è½¬&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchtestreg&lt;/code&gt; ä¿®æ”¹&lt;code&gt;TESTSET&lt;/code&gt;æŒ‡ä»¤ï¼Œè¿™ä¸ªæŒ‡ä»¤ä¸€èˆ¬ç”¨äºçŸ­è·¯æ±‚å€¼ï¼Œ&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchlistaux&lt;/code&gt; å¯¹äºä¸€ä¸ªjump listï¼Œå¦‚æœæ˜¯&lt;code&gt;TESTSET&lt;/code&gt;ï¼Œé‚£ä¹ˆå°†èµ‹å€¼å¯„å­˜å™¨ä¿®æ”¹ä¸ºregå¹¶å°†jumpç›®çš„åœ°ä¿®æ”¹ä¸ºvtarget, å¦åˆ™ä¿®æ”¹ä¸ºdtargetã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dischargejpc&lt;/code&gt; å¯¹jpcè¿›è¡Œ&lt;code&gt;patchlistaux&lt;/code&gt;ï¼Œå…¶ä¸­vtargetå’Œdtargetéƒ½æ˜¯pc&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchlist&lt;/code&gt; å¦‚æœtargetä¸ºpcï¼Œé‚£ä¹ˆè°ƒç”¨patchtohereï¼›å¦åˆ™è°ƒç”¨patchlistaux&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patchtohere&lt;/code&gt;å…ˆgetlabelæ ‡è®°ä¸€ä¸‹ï¼Œç„¶åå°†å½“å‰çš„listæ”¾åˆ°jpcåé¢&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jpc&lt;/code&gt;é‚£äº›å°†è¦è·³åˆ°å½“å‰ä½ç½®çš„é“¾è¡¨ï¼Œç”±äºæ‰€æœ‰codeçš„å¢åŠ çš„æ¬§å¼&lt;code&gt;luaK_code&lt;/code&gt;ï¼Œæ‰€ä»¥ä¼šåœ¨è¿™ä¸ªå‡½æ•°ä¸­è°ƒç”¨&lt;code&gt;dischargejpc&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>lua 5.1 åˆ†æ”¯è¯­å¥ bytecode çš„ç”Ÿæˆï¼ˆä¸€ï¼‰</title>
      <link>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-1/</link>
      <pubDate>Sat, 20 May 2017 15:57:13 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-cond-statment-bytecode-generate-1/</guid>
      <description>

&lt;p&gt;æœ¬æ–‡åªå¯¹ &lt;code&gt;IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END&lt;/code&gt; è¯­æ³•çš„å­—èŠ‚ç ç”Ÿæˆè¿‡ç¨‹è¿›è¡Œæè¿°ã€‚&lt;/p&gt;

&lt;h2 id=&#34;ç”Ÿæˆçš„ç»“æœ&#34;&gt;ç”Ÿæˆçš„ç»“æœ&lt;/h2&gt;

&lt;p&gt;é¦–å…ˆæˆ‘ä»¬çœ‹ä¸‹é¢çš„ç¤ºä¾‹ï¼Œä»…ä¸ºæ¼”ç¤ºï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local cond1 = true
local cond2 = true
if cond1 then
    cond1 = false
elseif cond2 then
    cond2 = false
else
    cond1 = false
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ä½¿ç”¨&lt;code&gt;luac -l -l&lt;/code&gt;é€‰é¡¹åˆ—å‡ºæ¥çš„ç»“æœä¸º&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;main &amp;lt;test.lua:0,0&amp;gt; (12 instructions, 48 bytes at 0x184e530)
0+ params, 2 slots, 0 upvalues, 2 locals, 0 constants, 0 functions
        1       [1]     LOADBOOL        0 1 0
        2       [2]     LOADBOOL        1 1 0
        3       [3]     TEST            0 0 0
        4       [3]     JMP             2       ; to 7
        5       [4]     LOADBOOL        0 0 0
        6       [4]     JMP             5       ; to 12
        7       [5]     TEST            1 0 0
        8       [5]     JMP             2       ; to 11
        9       [6]     LOADBOOL        1 0 0
        10      [6]     JMP             1       ; to 12
        11      [8]     LOADBOOL        0 0 0
        12      [9]     RETURN          0 1
constants (0) for 0x184e530:
locals (2) for 0x184e530:
        0       cond1   2       12
        1       cond2   3       12
upvalues (0) for 0x184e530:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è¿™é‡Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æœ€ç»ˆçš„ç”Ÿæˆç»“æœã€‚æˆ‘ä»¬å…³æ³¨çš„æ˜¯å…¶ä¸­çš„&lt;code&gt;TEST&lt;/code&gt;å’Œ&lt;code&gt;JUMP&lt;/code&gt;ã€‚åœ¨ç¬¬3è¡Œçš„&lt;code&gt;TEST&lt;/code&gt;ï¼Œå…¶æ„æ€æ˜¯å¦‚æœ0å·å¯„å­˜å™¨ä¸­çš„å†…å®¹(cond1)
ä¸ºfalse(0)çš„è¯ï¼Œé‚£ä¹ˆå°±æ‰§è¡Œä¸‹é¢çš„&lt;code&gt;JMP&lt;/code&gt;è¯­å¥ï¼Œå¦åˆ™å°±è°ƒè¿‡&lt;code&gt;JMP&lt;/code&gt;ç›´æ¥åˆ°ç¬¬5è¡Œã€‚&lt;code&gt;LUA&lt;/code&gt;ä¸­çš„åˆ†æ”¯å®ç°éƒ½æ˜¯ä½¿ç”¨&lt;code&gt;TEST&lt;/code&gt;ç­‰åé¢ç´§è·Ÿ&lt;code&gt;JMP&lt;/code&gt;å®ç°çš„ï¼Œ
ä»ä¸» dispatch ä»£ç ä¸­å¯ä»¥çœ‹åˆ°&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // ...
      case OP_TEST: {
        if (l_isfalse(ra) != GETARG_C(i))
          dojump(L, pc, GETARG_sBx(*pc));
        pc++;
        continue;
      }
      case OP_TESTSET: {
        TValue *rb = RB(i);
        if (l_isfalse(rb) != GETARG_C(i)) {
          setobjs2s(L, ra, rb);
          dojump(L, pc, GETARG_sBx(*pc));
        }
        pc++;
        continue;
      }
      // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;JMP&lt;/code&gt;è·³è½¬ï¼Œæ°¸è¿œéƒ½æ˜¯åˆ†æ”¯ä¸æˆç«‹çš„æƒ…å†µï¼Œè€Œ&lt;code&gt;TEST&lt;/code&gt;æˆåŠŸåçš„è·³è½¬æ°¸è¿œæ˜¯è·³è¿‡ä¸‹ä¸€è¡Œï¼Œå¤±è´¥çš„è¯ç»§ç»­æ‰§è¡Œæ¥ä¸‹æ¥çš„JMPã€‚&lt;code&gt;if&lt;/code&gt;è¯­å¥çš„å­—èŠ‚ç è§£æå°±åˆ°è¿™é‡Œï¼Œåé¢çš„&lt;code&gt;elseif&lt;/code&gt;ç­‰éƒ½æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œå†äº†è§£è¿™ä¸ªäº‹å®ä¹‹åã€‚
é‚£ä¹ˆè¿™ç§å­—èŠ‚ç æ˜¯æ€ä¹ˆç”Ÿæˆçš„å‘¢ï¼Ÿä¸‹é¢æ¥åˆ†æä¸‹ã€‚&lt;/p&gt;

&lt;h2 id=&#34;ç”Ÿæˆçš„è¿‡ç¨‹&#34;&gt;ç”Ÿæˆçš„è¿‡ç¨‹&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt;è¯­å¥çš„ä»£ç åœ¨&lt;code&gt;lparser.c&lt;/code&gt;é‡Œé¢ï¼Œæœ€ä¸Šå±‚å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void ifstat (LexState *ls, int line) {
  /* ifstat -&amp;gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
  FuncState *fs = ls-&amp;gt;fs;
  int flist;
  int escapelist = NO_JUMP;
  flist = test_then_block(ls);  /* IF cond THEN block */
  while (ls-&amp;gt;t.token == TK_ELSEIF) {
    luaK_concat(fs, &amp;amp;escapelist, luaK_jump(fs)); // å°† escapelist ä¸²èµ·æ¥ï¼Œè¿™é‡Œçš„ luaK_jump ä¼šè·³è½¬åˆ° end
    luaK_patchtohere(fs, flist); // æŠŠä¸Šé¢é‚£ä¸ª`JMP(1/3)` åœ°å€ä¿®æ”¹å¯¹
    flist = test_then_block(ls);  /* ELSEIF cond THEN block */
  }
  if (ls-&amp;gt;t.token == TK_ELSE) {
    luaK_concat(fs, &amp;amp;escapelist, luaK_jump(fs));
    luaK_patchtohere(fs, flist);
    luaX_next(ls);  /* skip ELSE (after patch, for correct line info) */
    block(ls);  /* `else&#39; part */
  }
  else
    luaK_concat(fs, &amp;amp;escapelist, flist); // è¿™é‡ŒæŠŠ flist ä¸²èµ·æ¥äº†ï¼Œæ„æ€æ˜¯æ²¡æœ‰ else è¯­å¥ï¼Œæ­¤æ—¶ flist æŒ‡å‘å°±æ˜¯ end
  luaK_patchtohere(fs, escapelist); // ä¿®æ”¹ escapelist åˆ° end è¯­å¥çš„ç»“å°¾
  check_match(ls, TK_END, TK_IF, line);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;åœ¨è¯»å– token çš„æ—¶å€™ï¼Œé‡åˆ° &lt;code&gt;if ... then&lt;/code&gt; ä¼šç”Ÿæˆ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TEST reg 0 predict
JMP ??? (1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ç”±äºæˆ‘ä»¬ä¸çŸ¥é“åé¢ä»£ç çš„å†…å®¹ï¼Œæ‰€ä»¥æ— æ³•ç¡®å®š&lt;code&gt;???&lt;/code&gt;è¯¥å¡«å†™å¤šå°‘ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯è¦è®°ä½è¿™ä¸ªä½ç½®ï¼Œå°†æ¥æˆ‘ä»¬è¦æŠŠå€¼å¡«å†™è¿›å»ï¼Œè¿™ä¸ªå€¼å…¶å®å°±å­˜
åœ¨&lt;code&gt;flist&lt;/code&gt;ã€‚ç„¶åæˆ‘ä»¬è¯»åˆ°&lt;code&gt;elseif cond then&lt;/code&gt;è¯­å¥ï¼Œè¿™å°±æ„å‘³ç€ç¬¬ä¸€æ®µä»£ç çš„ç»“æŸæ­¤æ—¶åº”è¯¥è¦è·³è½¬å‡ºè¿™ä¸ª&lt;code&gt;if&lt;/code&gt;
è¯­å¥ï¼Œæ‰€ä»¥æ­¤æ—¶åº”è¯¥æ’å…¥ä¸€ä¸ª&lt;code&gt;JMP(2)&lt;/code&gt;åˆ°æ•´ä¸ªè¯­å¥çš„ç»“æŸï¼Œå› ä¸ºæœ‰å¤šä¸ª block çš„å­˜åœ¨ï¼Œåé¢å¯èƒ½ä¼šæœ‰å¾ˆå¤šè¿™ç§ç±»ä¼¼çš„
&lt;code&gt;JMP&lt;/code&gt;ï¼Œå¦‚ä¸Šé¢ç¤ºä¾‹ä¸­çš„å„ç§&lt;code&gt;to 12&lt;/code&gt;ï¼Œè¿™äº›ä½ç½®éƒ½æ— æ³•ç¡®å®šï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªescapelistæ¥æŒ‡å‘è¿™ä¸ªåœ°å€ï¼Œæ–¹ä¾¿åé¢å¤„ç†ã€‚
ç°åœ¨å›å¤´çœ‹&lt;code&gt;JMP(1)&lt;/code&gt;ä½ç½®å°±ç¡®å®šäº†ï¼Œæ‰€ä»¥å½“å‰çš„PCå°±æ˜¯&lt;code&gt;flist&lt;/code&gt;çš„æŒ‡å‘ç”±äº&lt;code&gt;elseif&lt;/code&gt;åˆæ˜¯ä¸€ä¸ªåˆ†æ”¯è¯­å¥ï¼Œæ‰€ä»¥åˆå¯ä»¥ç”Ÿæˆä¸€æ®µ &lt;code&gt;TEST &amp;amp; JMP(3)&lt;/code&gt;ä»£ç äº†ã€‚åŒæ ·&lt;code&gt;JMP(2)&lt;/code&gt;çš„ä½ç½®æ˜¯æ— æ³•ç¡®å®šçš„ã€‚
ç°åœ¨æ¥è°ˆè°ˆ&lt;code&gt;escapelist&lt;/code&gt;ï¼Œå®šä¹‰&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int escapelist = NO_JUMP;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è¿™æ˜¯ä¸ª int å•Šï¼Œå¯¹äºå¤šä¸ªä½ç½®çš„&lt;code&gt;JMP(2)&lt;/code&gt;è¦æ€ä¹ˆå¤„ç†ï¼Ÿlua é‡‡ç”¨äº†ä¸€ç§å·§å¦™çš„æœºåˆ¶ï¼Œç”±äºæ­¤æ—¶çš„&lt;code&gt;JMP&lt;/code&gt;æ˜¯æ— æ•ˆçš„ï¼Œè¿˜æ²¡æœ‰è§£æåˆ°æ­£å¼åœ°å€çš„ï¼Œ
æ‰€ä»¥å…¶ä¸­çš„ç›®æ ‡åœ°å€åŸŸæ˜¯æ²¡æœ‰ä½¿ç”¨çš„ã€‚å› æ­¤ï¼Œå¯ä»¥é‡‡ç”¨ä¸²èµ·æ¥çš„æ–¹å¼ï¼ŒescapcelistæŒ‡å‘ç¬¬ä¸€ä¸ªæ²¡æœ‰è§£æçš„&lt;code&gt;JMP&lt;/code&gt;ï¼Œç„¶åè¿™ä¸ª&lt;code&gt;JMP&lt;/code&gt;çš„æŒ‡å‘åœ°å€
æ˜¯ä¸‹ä¸€ä¸ªæ²¡æœ‰è§£æçš„&lt;code&gt;JMP&lt;/code&gt;ï¼Œè¿™æ ·ä¸€æ¥å°±å½¢æˆäº†é“¾è¡¨çš„ç»“æ„ã€‚åé¢å¯ä»¥ä¸€èµ·ä¿®æ”¹ç›®æ ‡åœ°å€é€šè¿‡&lt;code&gt;luaK_patchtohere&lt;/code&gt;æ¥å®ç°ã€‚&lt;/p&gt;

&lt;h2 id=&#34;äº‹æƒ…æ²¡é‚£ä¹ˆç®€å•&#34;&gt;äº‹æƒ…æ²¡é‚£ä¹ˆç®€å•&lt;/h2&gt;

&lt;p&gt;æˆ‘ä»¬æˆ‘ä»¬è¯¦ç»†æŸ¥çœ‹çš„è¯ï¼Œ&lt;code&gt;test_then_block&lt;/code&gt; -&amp;gt; &lt;code&gt;cond&lt;/code&gt; -&amp;gt; &lt;code&gt;luaK_goiftrue&lt;/code&gt;ï¼Œçœ‹çœ‹&lt;code&gt;luaK_goiftrue&lt;/code&gt;å‡½æ•°çš„å®ç°ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void luaK_goiftrue (FuncState *fs, expdesc *e) {
  int pc;  /* pc of last jump */
  luaK_dischargevars(fs, e);
  switch (e-&amp;gt;k) {
    case VK: case VKNUM: case VTRUE: {
      pc = NO_JUMP;  /* always true; do nothing */
      break;
    }
    case VFALSE: {
      pc = luaK_jump(fs);  /* always jump */
      break;
    }
    case VJMP: {
      invertjump(fs, e);
      pc = e-&amp;gt;u.s.info;
      break;
    }
    default: {
      pc = jumponcond(fs, e, 0);
      break;
    }
  }
  luaK_concat(fs, &amp;amp;e-&amp;gt;f, pc);  /* insert last jump in `f&#39; list */
  luaK_patchtohere(fs, e-&amp;gt;t);
  e-&amp;gt;t = NO_JUMP;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å‰é¢çš„å‡ ç§ï¼Œå¦‚VKã€VKNUMã€VTRUEéƒ½æ˜¯å§‹ç»ˆæˆç«‹çš„ï¼Œæ‰€ä»¥å…¶&lt;code&gt;e-&amp;gt;f&lt;/code&gt;æ˜¯ä¸å­˜åœ¨çš„ï¼Œå› æ­¤ä¸º&lt;code&gt;NO_JUMP&lt;/code&gt;ï¼Œè€Œå¯¹äº VFALSEï¼Œå…¶å§‹ç»ˆåº”è¯¥èµ°é”™è¯¯åˆ†æ”¯ï¼Œå› æ­¤å…¶&lt;code&gt;e-&amp;gt;f&lt;/code&gt;ä¸ºä¸€æ¡JMPã€‚&lt;code&gt;VJUMP&lt;/code&gt;æ˜¯æ¯”è¾ƒè¯­å¥ç”Ÿæˆçš„, æ‰€ä»¥å…¶å€¼å°±æ˜¯ä»£è¡¨äº†&lt;code&gt;e-&amp;gt;t&lt;/code&gt;å’Œ&lt;code&gt;e-&amp;gt;f&lt;/code&gt;ï¼Œå› æ­¤å…¶&lt;code&gt;e-&amp;gt;f&lt;/code&gt;
å°±æ˜¯&lt;code&gt;invertjump&lt;/code&gt;äº†ã€‚åœ¨å„ç§é”™è¯¯JMPéƒ½ç”Ÿæˆå®Œä¹‹åï¼Œæ¥ä¸‹æ¥å°±æ˜¯æ­£ç¡®åˆ†æ”¯äº†ï¼Œæ‰€ä»¥ç›´æ¥å°±&lt;code&gt;luaK_patchtohere&lt;/code&gt;äº†ï¼Œå½“å‰çš„å°±æ˜¯æ­£ç¡®çš„é€»è¾‘ã€‚&lt;/p&gt;

&lt;p&gt;æˆ‘ä»¬å…³æ³¨çš„é‡ç‚¹å…¶å®æ˜¯ &lt;code&gt;jumponcond&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static int jumponcond (FuncState *fs, expdesc *e, int cond) {
  if (e-&amp;gt;k == VRELOCABLE) {
    Instruction ie = getcode(fs, e);
    if (GET_OPCODE(ie) == OP_NOT) {
      fs-&amp;gt;pc--;  /* remove previous OP_NOT */
      return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
    }
    /* else go through */
  }
  discharge2anyreg(fs, e);
  freeexp(fs, e);
  return condjump(fs, OP_TESTSET, NO_REG, e-&amp;gt;u.s.info, cond);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å¯¹äº &lt;code&gt;if not xxxx then&lt;/code&gt;ä¹‹ç±»çš„è¯­å¥ï¼Œæ˜¾ç„¶å…¶åˆ¤æ–­ç»“æœå€¼ä¸ä¼šè¢«å¼•ç”¨ï¼ˆåªæ˜¯è¢«åˆ¤æ–­è¯­å¥ä½¿ç”¨è€Œå·²ï¼‰æ‰€ä»¥è¿™é‡Œä½¿ç”¨&lt;code&gt;OP_TEST&lt;/code&gt;ï¼Œå…¶ä»–æ‰€æœ‰æƒ…å†µ
éƒ½æ˜¯ä½¿ç”¨çš„&lt;code&gt;OP_TESTSET&lt;/code&gt;ã€‚æˆ‘ä»¬å¯ä»¥çœ‹çœ‹&lt;code&gt;TESTSET&lt;/code&gt;çš„å®šä¹‰ï¼š&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TESTSET A B C if (R(B) &amp;lt;=&amp;gt; C) then R(A) := R(B) else PC++&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Used to implement and and or logical operators, or for testing a single
register in a conditional statement.&lt;/p&gt;

&lt;p&gt;For TESTSET, register R(B) is coerced into a boolean and compared to
the boolean field C. If R(B) matches C, the next instruction is skipped,
otherwise R(B) is assigned to R(A) and the VM continues with the next
instruction. The and operator uses a C of 0 (false) while or uses a C value
of 1 (true).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;å¦‚æœ Bè½¬æ¢ä¸º booleanå å’Œ Cç›¸ç­‰ï¼Œåˆ™è·³è¿‡ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼›å¦åˆ™å°†Bèµ‹ç»™Aç„¶åç»§ç»­æ‰§è¡Œã€‚è¿™æ¡æŒ‡ä»¤çš„ç›®çš„æ˜¯ä¸ºçŸ­è·¯æ±‚å€¼æœåŠ¡çš„ã€‚é‚£ä¹ˆ&lt;code&gt;TESTSET&lt;/code&gt;æ€
ä¹ˆåˆ°åé¢å˜æˆäº†&lt;code&gt;TEST&lt;/code&gt;å‘¢ï¼Ÿå…¶è¿‡ç¨‹å°±åœ¨&lt;code&gt;dischargejpc&lt;/code&gt;-&amp;gt;&lt;code&gt;patchlistaux&lt;/code&gt;-&amp;gt;&lt;code&gt;patchtestreg&lt;/code&gt;ã€‚&lt;/p&gt;

&lt;p&gt;ä¸Šé¢æˆ‘ä»¬è¯´åˆ°&lt;code&gt;luaK_patchtohere&lt;/code&gt;å°†å¾…å®š&lt;code&gt;JMP&lt;/code&gt;æ”¹æˆå½“å‰pcçš„åŠŸèƒ½ï¼Œå…¶å®å¹¶ä¸æ˜¯ç›´æ¥ä¿®æ”¹çš„ï¼Œè€Œæ˜¯é€šè¿‡æ¯æ¬¡ç”Ÿæˆæ–°çš„å­—èŠ‚ç çš„æ—¶å€™ï¼Œè°ƒç”¨&lt;code&gt;dischargejpc&lt;/code&gt;å®ç°çš„ï¼Œpatch çš„æ—¶å€™åªæ˜¯å°†è¿™ä¸ªä½ç½®ä¸²èµ·æ¥ï¼Œç„¶å &lt;code&gt;dischargejpc&lt;/code&gt;ä¼šä¾¿åˆ©è¿™ä¸ªé“¾è¡¨è¿›è¡Œä¿®æ”¹&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;patchlistaux(fs, fs-&amp;gt;jpc, fs-&amp;gt;pc, NO_REG, fs-&amp;gt;pc);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;é™¤æ­¤ä¹‹å¤–ï¼Œ&lt;code&gt;patchlistaux&lt;/code&gt;è¿˜è¿›è¡Œçš„ä¸€é¡¹æ“ä½œå°±æ˜¯&lt;code&gt;patchtestreg&lt;/code&gt;ï¼Œå®ƒçš„ä½œç”¨å°±æ˜¯å¤„ç†&lt;code&gt;TESTSET&lt;/code&gt;ï¼Œ&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;131	static int patchtestreg (FuncState *fs, int node, int reg) {
132	  Instruction *i = getjumpcontrol(fs, node);
133	  if (GET_OPCODE(*i) != OP_TESTSET)
134	    return 0;  /* cannot patch other instructions */
135	  if (reg != NO_REG &amp;amp;&amp;amp; reg != GETARG_B(*i)) // å‰è€…è¡¨ç¤ºä¸éœ€è¦å¯„å­˜ï¼Œåè€…ä¸¤è€…ç›¸åŒçš„è¯ä¹Ÿæ˜¯ä¸éœ€è¦ä¿®æ”¹çš„
136	    SETARG_A(*i, reg);
137	  else  /* no register to put value or register already has the value */
138	    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i)); // å¯¹äºä¸éœ€è¦è¿”å›å€¼çš„æƒ…å†µï¼Œç›´æ¥ä¿®æ”¹ä¸º TEST
139	
140	  return 1;
141	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ä¸Šé¢çš„ä»‹ç»åªæ˜¯ æ¡ä»¶è¯­å¥çš„ä¸€éƒ¨åˆ†ï¼Œåé¢çš„æ–‡ç« ä¼šå¯¹çŸ­è·¯æ±‚å€¼ï¼Œcompare è¿ç®—ç¬¦ç­‰åšè§£é‡Šã€‚&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>è§£ælua gc ä¸­çš„å‚æ•°æ§åˆ¶</title>
      <link>http://sysfork.com/post/2017/lua-gc-paramter-internal/</link>
      <pubDate>Wed, 10 May 2017 20:05:41 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-gc-paramter-internal/</guid>
      <description>&lt;p&gt;lua gc è°ƒä¼˜ä¸»è¦æ¶‰åŠåˆ°ä¸¤ä¸ªä¸¤ä¸ªå‚æ•°&lt;code&gt;setpause&lt;/code&gt;å’Œ&lt;code&gt;setstepmul&lt;/code&gt;ï¼Œä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;collectgarbage(&amp;quot;setpause&amp;quot;, 200)
collectgarbage(&amp;quot;setstepmul&amp;quot;, 200)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è¿™ä¸¤ä¸ªå€¼çš„é»˜è®¤å€¼éƒ½æ˜¯&lt;code&gt;200&lt;/code&gt;ï¼Œé‚£ä¹ˆè¿™ä»£è¡¨ç€ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿé€šè¿‡æŸ¥çœ‹ä»£ç &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static const char *const opts[] = {&amp;quot;stop&amp;quot;, &amp;quot;restart&amp;quot;, &amp;quot;collect&amp;quot;,
  &amp;quot;count&amp;quot;, &amp;quot;step&amp;quot;, &amp;quot;setpause&amp;quot;, &amp;quot;setstepmul&amp;quot;, NULL};
static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
  LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶å®&lt;code&gt;collectgarbage&lt;/code&gt;å¯¹åº”çš„å°±æ˜¯&lt;code&gt;lua_gc&lt;/code&gt;æ–¹æ³•ï¼Œä¸‹é¢æ˜¯å…¶ä¸­çš„éƒ¨åˆ†é€»è¾‘çš„ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;LUA_API int lua_gc (lua_State *L, int what, int data) {
  switch (what) {
    case LUA_GCSTOP: g-&amp;gt;GCthreshold = MAX_LUMEM;
    case LUA_GCRESTART: g-&amp;gt;GCthreshold = g-&amp;gt;totalbytes;
    case LUA_GCCOLLECT: luaC_fullgc(L);
    case LUA_GCCOUNT: res = cast_int(g-&amp;gt;totalbytes &amp;gt;&amp;gt; 10);
    case LUA_GCCOUNTB:  res = cast_int(g-&amp;gt;totalbytes &amp;amp; 0x3ff);
    case LUA_GCSTEP: {
      lu_mem a = (cast(lu_mem, data) &amp;lt;&amp;lt; 10);
      if (a &amp;lt;= g-&amp;gt;totalbytes)
        g-&amp;gt;GCthreshold = g-&amp;gt;totalbytes - a;
      else
        g-&amp;gt;GCthreshold = 0;
      while (g-&amp;gt;GCthreshold &amp;lt;= g-&amp;gt;totalbytes) {
        luaC_step(L);
        if (g-&amp;gt;gcstate == GCSpause) {  /* end of cycle? */
          res = 1;  /* signal it */
          break;
        }
      }
      break;
    }
    case LUA_GCSETPAUSE: res = g-&amp;gt;gcpause; g-&amp;gt;gcpause = data;
    case LUA_GCSETSTEPMUL: res = g-&amp;gt;gcstepmul; g-&amp;gt;gcstepmul = data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶ä¸­æˆ‘ä»¬çœ‹åˆ°ä¸€äº›æœ‰æ„æ€çš„å‚æ•°ï¼Œåœ¨&lt;code&gt;g(global_State)&lt;/code&gt;ä¸­æœ‰å¦‚ä¸‹å®šä¹‰ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*
** `global state&#39;, shared by all threads of this state
*/
typedef struct global_State {
//.....
  lu_mem GCthreshold;
  lu_mem totalbytes;  /* number of bytes currently allocated */
  lu_mem estimate;  /* an estimate of number of bytes actually in use */
  lu_mem gcdept;  /* how much GC is `behind schedule&#39; */
  int gcpause;  /* size of pause between successive GCs */
  int gcstepmul;  /* GC `granularity&#39; */
//......
} global_State;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å¯ä»¥çœ‹åˆ°ï¼Œå¯¹äº&lt;code&gt;LUA_GCSTOP&lt;/code&gt;æ˜¯å°†&lt;code&gt;GCthreshold&lt;/code&gt;è®¾ç½®æˆä¸€ä¸ªå¾ˆå¤§çš„å€¼&lt;code&gt;MAX_LUMEM&lt;/code&gt;(&lt;code&gt;~(size_t)0)-2&lt;/code&gt;)ï¼Œè€Œ&lt;code&gt;LUA_GCRESTART&lt;/code&gt;åˆ™å°†&lt;code&gt;GCthreshold&lt;/code&gt;è®¾ç½®æˆ&lt;code&gt;totalbytes&lt;/code&gt;ã€‚å¯¹äº&lt;code&gt;LUA_GCSETPAUSE&lt;/code&gt;å’Œ&lt;code&gt;LUA_GCSETSTEPMUL&lt;/code&gt;åˆ™æ˜¯åˆ†åˆ«è®¾ç½®äº†&lt;code&gt;gcpause&lt;/code&gt;å’Œ&lt;code&gt;gcstepmul&lt;/code&gt;çš„å€¼ã€‚ä»æ³¨é‡Šä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å„è‡ªå€¼çš„è§£é‡Šã€‚&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;å‚æ•°&lt;/th&gt;
&lt;th&gt;æ„ä¹‰&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GCthreshold&lt;/td&gt;
&lt;td&gt;GCçš„é—¨æ§›ï¼Œå½“totalbyteså¤§äºè¿™ä¸ªå€¼æ—¶è§¦å‘gc step&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;totalbytes&lt;/td&gt;
&lt;td&gt;ç”±å†…å­˜åˆ†é…å™¨åˆ†é…çš„&lt;strong&gt;å®é™…&lt;/strong&gt;å†…å­˜&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;estimate&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;ä¼°è®¡&lt;/strong&gt;çš„ï¼Œæ­£åœ¨ä½¿ç”¨çš„å†…å­˜å¤§å°ï¼Œå°äº &lt;code&gt;totalbytes&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ä¸‹é¢è¿™æ®µä»£ç æ˜¯ä»£ç ä¸­éšå¤„å¯è§ï¼Œå¦‚&lt;code&gt;lua_createtable&lt;/code&gt;ç­‰ï¼Œåœ¨æ‰§è¡Œæ“ä½œä¹‹å‰éƒ½ä¼šæ£€æŸ¥æ˜¯å¦éœ€è¦è§¦å‘&lt;code&gt;gc&lt;/code&gt;ï¼Œä»¥ä¿è¯å†…å­˜åˆ©ç”¨ç‡ã€‚&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;80	#define luaC_checkGC(L) { \
81	  condhardstacktests(luaD_reallocstack(L, L-&amp;gt;stacksize - EXTRA_STACK - 1)); \
82	  if (G(L)-&amp;gt;totalbytes &amp;gt;= G(L)-&amp;gt;GCthreshold) \
83		luaC_step(L); }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å½“ &lt;code&gt;totalbytes &amp;gt;= GCthreshold&lt;/code&gt;æ—¶è§¦å‘stepã€‚å› æ­¤&lt;code&gt;LUA_GCRESTART&lt;/code&gt;ä¹‹åï¼Œä¸‹ä¸€æ¬¡&lt;code&gt;checkGC&lt;/code&gt;çš„æ—¶å€™ä¼šç«‹å³å‡ºå‘&lt;code&gt;luaC_step&lt;/code&gt;ã€‚å¯ä»¥çœ‹åˆ°
&lt;code&gt;totalbytes&lt;/code&gt;å’Œ&lt;code&gt;GCthreshold&lt;/code&gt;æ˜¯æ§åˆ¶&lt;code&gt;GC&lt;/code&gt;çš„å…³é”®å‚æ•°ã€‚&lt;/p&gt;

&lt;p&gt;æ¯ä¸ªå›æ”¶å‘¨æœŸç»“æŸé‡ç½®&lt;code&gt;GCthreshold&lt;/code&gt; ï¼Œè¿™é‡Œç”¨åˆ°äº†çš„estimateã€‚å› ä¸ºå¸¦æœ‰ __gc å…ƒæ–¹æ³•çš„ &lt;code&gt;userdata&lt;/code&gt; éœ€è¦ä¸¤ä¸ªgcå‘¨æœŸ
æ‰èƒ½å›æ”¶ï¼Œåœ¨ç¬¬ä¸€ä¸ªgcå‘¨æœŸä¸­å…¶ &lt;code&gt;__gc&lt;/code&gt;å…ƒæ–¹æ³•ä¼šè¢«è°ƒç”¨ï¼Œè€Œåœ¨ç¬¬äºŒä¸ªå›æ”¶å‘¨æœŸå†…å†…å­˜ä¼šè¢«çœŸæ­£å›æ”¶ã€‚å› æ­¤ï¼Œ&lt;code&gt;estimate&lt;/code&gt;æ˜¯ä¸åŒ…å«é‚£äº›&lt;code&gt;__gc&lt;/code&gt;å…ƒæ–¹æ³•è¢«è°ƒç”¨çš„&lt;code&gt;userdata&lt;/code&gt;çš„ï¼Œè€Œ&lt;code&gt;totalbytes&lt;/code&gt;ä¼šåŒ…å«ï¼ˆå› ä¸ºå…¶åæ˜ çš„æ˜¯çœŸå®å†…å­˜å ç”¨æƒ…å†µï¼‰ã€‚&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define setthreshold(g)  (g-&amp;gt;GCthreshold = (g-&amp;gt;estimate/100) * g-&amp;gt;gcpause)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ç”±è¿™æ®µä»£ç å¯ä»¥çœ‹å‡ºï¼Œæˆ‘ä»¬è®¾ç½®çš„&lt;code&gt;gcpause&lt;/code&gt;å€¼å½±å“çš„æ˜¯ä¸‹ä¸€å‘¨æœŸå¼€å§‹çš„äº‹ä»¶ï¼Œé»˜è®¤&lt;code&gt;200&lt;/code&gt;çš„æ„æ€æ—¶ï¼Œå½“å½“å‰&lt;strong&gt;çœŸå®&lt;/strong&gt;å†…å­˜å ç”¨è¶…è¿‡å½“å‰&lt;strong&gt;ä¼°è®¡&lt;/strong&gt;å†…å­˜å ç”¨çš„ä¸¤å€æ—¶ï¼Œæ‰å¼€å¯ä¸‹ä¸€å›æ”¶å‘¨æœŸã€‚æ‰€ä»¥å¦‚æœä½ å«&lt;code&gt;__gc&lt;/code&gt;æ–¹æ³•çš„&lt;code&gt;userdata&lt;/code&gt;è¿‡å¤§çš„è¯ï¼Œå¾ˆå¯èƒ½åœ¨ç¬¬ä¸€æ¬¡å‘¨æœŸç»“æŸåç«‹é©¬å¼€å¯äº†ç¬¬äºŒå‘¨æœŸã€‚å¦‚æœè®¾ç½®çš„&lt;code&gt;gcpause&lt;/code&gt;å€¼å°äº&lt;code&gt;100&lt;/code&gt;çš„è¯ï¼Œé‚£ä¹ˆåŒæ ·ä¸¤æ¬¡&lt;code&gt;gc&lt;/code&gt;å‘¨æœŸä¸­é—´æ˜¯æ²¡æœ‰é—´éš”çš„ã€‚&lt;/p&gt;

&lt;p&gt;æ¥ä¸‹æ¥çœ‹&lt;code&gt;luaC_step&lt;/code&gt;çš„ä»£ç &lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;610	void luaC_step (lua_State *L) {
611	  global_State *g = G(L);
612	  l_mem lim = (GCSTEPSIZE/100) * g-&amp;gt;gcstepmul;
613	  if (lim == 0)
614	    lim = (MAX_LUMEM-1)/2;  /* no limit */
615	  g-&amp;gt;gcdept += g-&amp;gt;totalbytes - g-&amp;gt;GCthreshold;
616	  do {
617	    lim -= singlestep(L);
618	    if (g-&amp;gt;gcstate == GCSpause)
619	      break;
620	  } while (lim &amp;gt; 0);
621	  if (g-&amp;gt;gcstate != GCSpause) {
622	    if (g-&amp;gt;gcdept &amp;lt; GCSTEPSIZE)
623	      g-&amp;gt;GCthreshold = g-&amp;gt;totalbytes + GCSTEPSIZE;  /* - lim/g-&amp;gt;gcstepmul;*/
624	    else {
625	      g-&amp;gt;gcdept -= GCSTEPSIZE;
626	      g-&amp;gt;GCthreshold = g-&amp;gt;totalbytes;
627	    }
628	  }
629	  else {
630	    setthreshold(g);
631	  }
632	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è¿™é‡Œ&lt;code&gt;stepmul&lt;/code&gt;æ§åˆ¶çš„å°±æ˜¯&lt;code&gt;step&lt;/code&gt;çš„é•¿åº¦ï¼Œè¶Šå¤§åˆ™æ¯æ­¥æ‰€è¿›è¡Œçš„æ“ä½œä¹Ÿå°±è¶Šå¤šï¼Œæ‹¥æœ‰æ›´å¤šçš„ã€Œè´¹ã€ã€‚å…¶ä¸­&lt;code&gt;GCSTEPSIZE&lt;/code&gt;çš„å€¼ä¸º&lt;code&gt;1024&lt;/code&gt;ã€‚ä¹Ÿå°±æ˜¯è¯´é»˜è®¤&lt;code&gt;stepmul&lt;/code&gt;ä¸º200çš„æƒ…å†µä¸‹ï¼Œå¤§çº¦å¯å·²è¿›è¡Œ&lt;code&gt;2048&lt;/code&gt;ã€Œè´¹ã€ï¼Œé‚£ä¹ˆã€Œè´¹ã€æ˜¯æ€ä¹ˆå®šä¹‰çš„å‘¢ï¼Ÿä»ä»£ç å¯ä»¥çœ‹åˆ°æ¸…é™¤ä¸€æ¡&lt;code&gt;string&lt;/code&gt;è¡¨å’Œä»»æ„ä¸€ä¸ª&lt;code&gt;gc&lt;/code&gt;å¯¹è±¡ä¸º&lt;code&gt;10&lt;/code&gt;ã€Œè´¹ã€ï¼Œè°ƒç”¨&lt;code&gt;__gc&lt;/code&gt;å…ƒæ–¹æ³•ä¸º&lt;code&gt;100&lt;/code&gt;ã€Œè´¹ã€ï¼Œé™¤éæ˜¯&lt;code&gt;sweep&lt;/code&gt;é˜¶æ®µå¦åˆ™å†…å­˜ä¸ä¼šå‡å°‘ï¼Œå› æ­¤ä¸èƒ½ä½¿ç”¨å†…å­˜å·®å€¼æ¥è¡¨ç¤ºå·¥ä½œè¿›åº¦ï¼Œæ‰€ä»¥å¼•å…¥äº†ã€Œè´¹ã€ã€‚å¦‚æœä½ æŠŠ&lt;code&gt;stepmul&lt;/code&gt;è®¾ç½®ä¸º&lt;code&gt;0&lt;/code&gt;çš„è¯ï¼Œé‚£ä¹ˆ&lt;code&gt;lim&lt;/code&gt;å°±æ˜¯&lt;code&gt;(MAX_LUMEM-1)/2&lt;/code&gt;
ä¸ºä»€ä¹ˆæ˜¯è¿™ä¹ˆå¥‡æ€ªçš„æ•°å€¼ï¼Ÿå› ä¸º&lt;code&gt;MAX_LUAEME&lt;/code&gt;æ˜¯&lt;code&gt;~(size_t)0)-2&lt;/code&gt;ï¼Œæ— ç¬¦å·æ•´å‹ï¼Œè€Œ&lt;code&gt;l_mem&lt;/code&gt;æ˜¯æœ‰ç¬¦å·çš„ï¼Œç›´æ¥èµ‹å€¼ä¼šæº¢å‡ºçš„ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;luaC_step&lt;/code&gt;çš„è®¾è®¡æ€è·¯æ˜¯ï¼š æ¯å½“æ–°å¢åˆ†é…çš„å†…å­˜æ•°è¶…è¿‡&lt;code&gt;GCSTEPSIZE&lt;/code&gt;å°±è§¦å‘ä¸€æ¬¡ã€‚ç”±äºluaåªä¼šåœ¨gcè¿‡ç¨‹ä¸­é‡Šæ”¾å¯¹è±¡ï¼Œæ‰€ä»¥
&lt;code&gt;totalbytes&lt;/code&gt;åœ¨gcè¿‡ç¨‹å¤–æ—¶åªå¢ä¸å‡çš„ï¼Œå› æ­¤&lt;code&gt;luaC_step&lt;/code&gt;æ€»æ˜¯ä¼šå¾—ä»¥è§¦å‘ã€‚ä¸ºäº†å‡†ç¡®è®°å½•æ–°å¢å†…å­˜ä½¿ç”¨é‡ï¼Œlua ä½¿ç”¨äº†&lt;code&gt;gcdept&lt;/code&gt;å˜é‡ã€‚
è¿™ç§è®¾è®¡æ˜¯ä¸ºäº†é˜²æ­¢&lt;code&gt;luaC_step&lt;/code&gt;è¢«é¢‘ç¹è§¦å‘ï¼Œæ§åˆ¶ä¸€ä¸ªè¾ƒåˆç†çš„ç²’åº¦ã€‚&lt;/p&gt;

&lt;p&gt;å¦å¤–ï¼Œ&lt;code&gt;gcdept&lt;/code&gt;åœ¨æ¯ä¸ªå‘¨æœŸæœ«å°¾ä¼šæ¸…é›¶ã€‚&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;592	    case GCSfinalize: {
593	      if (g-&amp;gt;tmudata) {
594	        GCTM(L);
595	        if (g-&amp;gt;estimate &amp;gt; GCFINALIZECOST)
596	          g-&amp;gt;estimate -= GCFINALIZECOST;
597	        return GCFINALIZECOST;
598	      }
599	      else {
600	        g-&amp;gt;gcstate = GCSpause;  /* end collection */
601	        g-&amp;gt;gcdept = 0;
602	        return 0;
603	      }
604	    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ä¸€ç§åœ¨elfä¸­é›†æˆè„šæœ¬æ–‡ä»¶çš„æ–¹æ¡ˆ</title>
      <link>http://sysfork.com/post/2017/a-solution-for-elf-integrate-scripts/</link>
      <pubDate>Mon, 01 May 2017 22:30:00 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/a-solution-for-elf-integrate-scripts/</guid>
      <description>

&lt;p&gt;è¿›è¡Œæ¸¸æˆæœåŠ¡å™¨å¼€å‘æ—¶ï¼Œæˆ‘ä»¬å°†&lt;code&gt;C++&lt;/code&gt;çš„éƒ¨åˆ†ç§°ä¹‹ä¸ºå¼•æ“å±‚ï¼Œè€Œ&lt;code&gt;lua&lt;/code&gt;ç§°ä¹‹ä¸ºè„šæœ¬å±‚ã€‚ä½†æ˜¯å¾€å¾€æœ‰äº›æ ¸å¿ƒé€»è¾‘æ˜¯å„ä¸ªæ¸¸æˆå…¬ç”¨çš„ï¼Œ
æˆ–è€…è¯´æœ‰äº›å¼•æ“å±‚çš„ä»£ç ç”¨&lt;code&gt;C++&lt;/code&gt;å†™èµ·æ¥ååˆ†éº»çƒ¦ï¼Œæˆ‘ä»¬è¿˜æ˜¯ä¼šä½¿ç”¨&lt;code&gt;lua&lt;/code&gt;æ¥ç¼–å†™ã€‚è¿™å°±å¸¦æ¥äº†ä¸€äº›é—®é¢˜ï¼Œæˆ‘ä»¬çš„æ¸¸æˆç›®å½•ç»“æ„å¦‚ä¸‹:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;â”œâ”€bin               // å¯æ‰§è¡Œæ–‡ä»¶
â””â”€scripts           // è„šæœ¬ç›®å½•ï¼Œluaæ–‡ä»¶
    â”œâ”€framework     // æ ¸å¿ƒluaæ–‡ä»¶ï¼Œå„ä¸ªé¡¹ç›®å…¬ç”¨çš„
    â””â”€server        // æ¸¸æˆé€»è¾‘luaæ–‡ä»¶
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶ä¸­&lt;code&gt;scripts/framework&lt;/code&gt;æ˜¯å„ä¸ªé¡¹ç›®å…¬ç”¨çš„ï¼Œå¹¶ä¸”å’Œ&lt;code&gt;bin&lt;/code&gt;ç›®å½•ä¸­çš„å¯æ‰§è¡Œæ–‡ä»¶åŒæ—¶å‘å¸ƒå’Œæ›´æ–°ã€‚æ‰€ä»¥æœ‰ä¸€ä¸ªæƒ³æ³•ï¼Œå°±æ˜¯å°†&lt;code&gt;framework&lt;/code&gt;ä¸­
çš„luaæ–‡ä»¶é›†æˆåˆ°å¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼Œå‡å°‘ç»´æŠ¤çš„æˆæœ¬ã€‚&lt;/p&gt;

&lt;h1 id=&#34;æ–‡ä»¶å­˜å‚¨&#34;&gt;æ–‡ä»¶å­˜å‚¨&lt;/h1&gt;

&lt;p&gt;ä¸‹é¢æ˜¯elfæ–‡ä»¶çš„ç¤ºæ„å›¾&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Elf-layout--en.svg/260px-Elf-layout--en.svg.png&#34; alt=&#34;elf&#34; /&gt;&lt;/p&gt;

&lt;p&gt;elfæ–‡ä»¶æœ‰å¤šä¸ªsectionï¼Œé™¤äº†ä¸€äº›é¢„å®šä¹‰çš„sectionå¦‚&lt;code&gt;.rodata&lt;/code&gt;ã€&lt;code&gt;.text&lt;/code&gt;ã€&lt;code&gt;.init&lt;/code&gt;ç­‰ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å®šä¹‰ä¸€äº›è‡ªå·±çš„sectionã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°†æ‰€éœ€è¦çš„luaæ–‡ä»¶
æ”¾è¿›è¿™ä¸ªsectionä¸­ï¼Œåœ¨æ‰§è¡Œçš„æ—¶å€™åŠ¨æ€è¯»å‡ºæ¥ï¼Œå®ç°ç›®çš„ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨&lt;a href=&#34;https://linux.die.net/man/1/objcopy&#34;&gt;objcopy&lt;/a&gt;å‘½ä»¤æ¥å®ç°åˆ›å»ºè‡ªå®šä¹‰sectionçš„åŠŸèƒ½ã€‚&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objcopy infile.out --add-section .lua-data=section_file outfile.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ç„¶è€Œ&lt;code&gt;framework&lt;/code&gt;é‡Œé¢æœ‰å¤šä¸ªæ–‡ä»¶ï¼Œè€Œä¸”åŒ…å«åµŒå¥—çš„æ–‡ä»¶å¤¹ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå°†æ–‡ä»¶å¤¹å˜æˆå•ä¸ªæ–‡ä»¶çš„åŠŸèƒ½ï¼Œç±»ä¼¼äº&lt;a href=&#34;https://linux.die.net/man/1/tar&#34;&gt;tar&lt;/a&gt;ã€‚è™½ç„¶åˆ›å»º
sectionæ—¶ä½¿ç”¨&lt;code&gt;tar&lt;/code&gt;å‘½ä»¤æ˜¯ç®€å•çš„ï¼Œä½†æ˜¯åœ¨è¯»å–çš„æ—¶å€™éœ€è¦ä¸€äº›ç¬¬ä¸‰æ–¹çš„åº“æ¥æ”¯æŒï¼Œè¿™æ˜¯æ¯”è¾ƒéº»çƒ¦çš„ã€‚è€Œç”±äºæˆ‘ä»¬çš„ç›®å½•ä¸­åªåŒ…å«&lt;code&gt;lua&lt;/code&gt;æ–‡ä»¶ï¼Œæ‰€ä»¥å¯ä»¥ç®€åŒ–è®¾è®¡ã€‚
é¦–å…ˆç©ºæ–‡ä»¶å¤¹å¯¹äºæˆ‘ä»¬æ˜¯æ— æ„ä¹‰çš„ï¼Œåªéœ€è¦&lt;code&gt;lua&lt;/code&gt;æ–‡ä»¶å°±å¯ä»¥ã€‚æ‰€ä»¥æœ€ç»ˆæˆ‘ä»¬å¾—åˆ°å¦‚ä¸‹çš„è¡¨:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ libs/json.lua      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ core/entity.lua    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ app/game.lua       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ libs/bson.lua      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;æˆ‘ä»¬å¯ä»¥æŒ‰ç…§å¦‚ä¸‹çš„æ ¼å¼è½¬æ¢æˆå•ä¸ªæ–‡ä»¶&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚name_lenâ”‚content_lenâ”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ core.entity        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚name_lenâ”‚content_lenâ”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ libs.bson          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ .................  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å…¶ä¸­&lt;code&gt;name_len&lt;/code&gt;ä¸ºæ–‡ä»¶åçš„é•¿åº¦ï¼Œè¿™é‡Œç›´æ¥è½¬æ¢æˆäº†luaä¸­&lt;code&gt;require&lt;/code&gt;çš„æ ¼å¼ï¼Œä½¿ç”¨ç‚¹ç¬¦å·ã€‚&lt;code&gt;content_len&lt;/code&gt;æ˜¯æ–‡ä»¶å†…å®¹çš„é•¿åº¦ï¼Œå³æ–‡ä»¶çš„å…·ä½“å†…å®¹é•¿åº¦ã€‚æœ€åæˆ‘ä»¬å¯ä»¥ä½¿ç”¨&lt;code&gt;zip&lt;/code&gt;æŒ‡ä»¤
å°†è¿™éƒ¨åˆ†å†…å®¹å‹ç¼©å­˜å‚¨åœ¨&lt;code&gt;elf&lt;/code&gt;æ–‡ä»¶ä¸­ã€‚å®Œæ•´çš„ä»£ç å¦‚ä¸‹:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
#coding: utf-8

import os, struct, StringIO, zlib, subprocess, sys, tempfile, argparse

argParser = argparse.ArgumentParser()

argParser.add_argument(&amp;quot;luafolder&amp;quot;, type=str)
argParser.add_argument(&amp;quot;exe&amp;quot;, type=str)
argParser.add_argument(&amp;quot;out&amp;quot;, type=str)

args = argParser.parse_args()

files = []

path = args.luafolder

for (dirpath, dirname, filenames) in os.walk(path):
    dirp = dirpath[len(path):]
    if dirp:
        if dirp[-1] != &amp;quot;/&amp;quot;:
            dirp += &amp;quot;/&amp;quot;

        while dirp[0] == &amp;quot;/&amp;quot;:
            dirp = dirp[1:]

    files.extend([dirp + x for x in filenames])

output = StringIO.StringIO()

for fpath in files:
    realp = path + &amp;quot;/&amp;quot; + fpath
    filesize = os.path.getsize(realp)

    if fpath.endswith(&amp;quot;.lua&amp;quot;):
        fpath = fpath[:-4]
    elif fpath.endswith(&amp;quot;.luac&amp;quot;):
        fpath = fpath[:-5]
    else:
        continue

    package_pattern = fpath.replace(&amp;quot;/&amp;quot;, &amp;quot;.&amp;quot;)
    package_pattern = &amp;quot;pg.&amp;quot; + package_pattern
    with open(realp, &amp;quot;rb&amp;quot;) as rf:
        content = rf.read()
        output.write(struct.pack(&amp;quot;=hL&amp;quot;, len(package_pattern), len(content)))
        output.write(package_pattern)
        output.write(content)

f = tempfile.NamedTemporaryFile()

outdata = output.getvalue()
f.write(struct.pack(&amp;quot;=L&amp;quot;, len(outdata)))
f.write(zlib.compress(output.getvalue()))
f.flush()

subprocess.call(&amp;quot;objcopy %s --remove-section .lua-data&amp;quot;%(args.exe, ), shell=True)
subprocess.call(&amp;quot;objcopy %s --add-section .lua-data=%s %s&amp;quot;%(args.exe, f.name, args.out), shell=True)

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;æ–‡ä»¶å†…å®¹çš„è¯»å–&#34;&gt;æ–‡ä»¶å†…å®¹çš„è¯»å–&lt;/h1&gt;

&lt;p&gt;æˆ‘ä»¬éœ€è¦ä½¿ç”¨&lt;code&gt;elf.h&lt;/code&gt;æ–‡ä»¶æ¥è¯»å–æ–‡ä»¶å†…å®¹ã€‚æ ¹æ®ä¸Šè¿°çš„æ ¼å¼ç¤ºæ„å›¾ï¼Œ&lt;code&gt;elf&lt;/code&gt;æ–‡ä»¶å¼€å¤´çš„æ˜¯Headerï¼Œå…¶æ ¼å¼ä¸º&lt;code&gt;ElfXX_Ehdr&lt;/code&gt;ï¼Œ
æˆ‘ä»¬å¯ä»¥ç›´æ¥è¯»å–æ–‡ä»¶å†…å®¹åˆ°å†…å­˜ã€‚ç„¶åè¯»å–&lt;code&gt;e_shoff&lt;/code&gt;å­—æ®µè·å¾—section headerçš„ä½ç½®ï¼Œå®šä½åˆ°ä½ç½®å¹¶ä¾æ¬¡è¯»å–å†…å®¹åˆ°&lt;code&gt;ElfXX_Shdr&lt;/code&gt;
ç»“æ„ä½“ä¸­ï¼Œç„¶åé€šè¿‡å„ä¸ªentryçš„&lt;code&gt;sh_name&lt;/code&gt;å¾—åˆ°æœ€ç»ˆsectionï¼Œç„¶åè¯»å–æ–‡ä»¶è¾¾åˆ°ç›®çš„ã€‚å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static std::map&amp;lt;std::string, std::string&amp;gt; readElfLuaData(const std::string &amp;amp;filepath) {
    std::map&amp;lt;std::string, std::string&amp;gt; files;
#if __x86_64__
    typedef Elf64_Ehdr ELF_EHDR;
    typedef Elf64_Shdr ELF_SHDR;
#else
    typedef Elf32_Ehdr ELF_EHDR;
    typedef Elf32_Shdr ELF_SHDR;
#endif

    std::ifstream ifs(filepath);

    ELF_EHDR hdr;
    ifs.read(reinterpret_cast&amp;lt;char *&amp;gt;(&amp;amp;hdr), sizeof(hdr));

    std::vector&amp;lt;ELF_SHDR&amp;gt; sh_tables(hdr.e_shnum);
    ifs.seekg(static_cast&amp;lt;long&amp;gt;(hdr.e_shoff));

    for (size_t i = 0; i &amp;lt; hdr.e_shnum; ++i) {
        ifs.read(reinterpret_cast&amp;lt;char *&amp;gt;(&amp;amp;sh_tables[i]), sizeof(sh_tables[i]));
    }

    // read shstr

    std::vector&amp;lt;char&amp;gt; shstr(sh_tables[hdr.e_shstrndx].sh_size);
    ifs.seekg(static_cast&amp;lt;long&amp;gt;(sh_tables[hdr.e_shstrndx].sh_offset));
    ifs.read(shstr.data(), static_cast&amp;lt;long&amp;gt;(shstr.size()));

    ELF_SHDR *lua_sh = nullptr;

    for (size_t i = 0; i &amp;lt; hdr.e_shnum; ++i) {
        char *name = shstr.data() + sh_tables[i].sh_name;
        if (strcmp(name, &amp;quot;.lua-data&amp;quot;) == 0) {
            lua_sh = &amp;amp;sh_tables[i];
            break;
        }
    }

    if (lua_sh) {
        std::vector&amp;lt;char&amp;gt; buf(lua_sh-&amp;gt;sh_size);
        ifs.seekg(static_cast&amp;lt;long&amp;gt;(lua_sh-&amp;gt;sh_offset));
        ifs.read(buf.data(), static_cast&amp;lt;std::streamsize&amp;gt;(buf.size()));

        size_t idx = 0;
#define READ_TO(TARGET, SIZE)                                                                      \
    memcpy(TARGET, buf.data() + idx, SIZE);                                                        \
    idx += SIZE;

        uint32_t raw_len = 0;
        READ_TO(&amp;amp;raw_len, sizeof(raw_len));

        std::vector&amp;lt;char&amp;gt; tmp(raw_len);
        uLongf dest_len = tmp.size();
        uncompress(reinterpret_cast&amp;lt;Bytef *&amp;gt;(tmp.data()), &amp;amp;dest_len,
                   reinterpret_cast&amp;lt;Bytef *&amp;gt;(buf.data() + idx), buf.size() - idx);

        buf.swap(tmp);
        idx = 0;

        while (idx &amp;lt; dest_len) {
            uint16_t name_len;
            uint32_t content_len;
            READ_TO(&amp;amp;name_len, sizeof(name_len));
            READ_TO(&amp;amp;content_len, sizeof(content_len));
            std::string filename(name_len, 0), content(content_len, 0);
            READ_TO(&amp;amp;*filename.begin(), filename.size());
            READ_TO(&amp;amp;*content.begin(), content.size());
            files.emplace(std::piecewise_construct, std::forward_as_tuple(std::move(filename)),
                          std::forward_as_tuple(std::move(content)));
        }
#undef READ_TO
    }
    return files;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;æ¥ä¸‹æ¥ä¾¿å¯ä»¥é€šè¿‡æ·»åŠ åˆ°&lt;code&gt;package.preload&lt;/code&gt;å®ç°åœ¨luaä¸­è°ƒç”¨è¿™äº›æ–‡ä»¶çš„ç›®çš„ã€‚&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>luaä¸Cäº¤äº’ä¸­çš„æ­»å¾ªç¯æ£€æµ‹</title>
      <link>http://sysfork.com/post/2017/lua-c-detect-inifinite-loop/</link>
      <pubDate>Fri, 21 Apr 2017 17:37:30 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2017/lua-c-detect-inifinite-loop/</guid>
      <description>

&lt;p&gt;ç°åœ¨å¾ˆå¤šæ¸¸æˆå¼•æ“éƒ½æ˜¯&lt;code&gt;C++&lt;/code&gt; + &lt;code&gt;lua&lt;/code&gt;çš„ç»“æ„ï¼Œä¸€æ—¦æŸä¸ªæœåŠ¡å™¨å¼€å‘äººå‘˜å¤§æ„å†™å‡ºæ­»å¾ªç¯ä»£ç ï¼Œå¾ˆå®¹æ˜“å¯¼è‡´æœåŠ¡æ— å“åº”ï¼Œå½±å“æœåŠ¡å™¨ç¨³å®šã€‚æ‰€ä»¥å¼•æ“ä¸­æœ€å¥½èƒ½æä¾›ä¸€ä¸ªæ­»å¾ªç¯çš„æ£€æµ‹æœºåˆ¶ï¼Œä¸€æ—¦å‡ºç°æ­»å¾ªç¯åˆ™æ‰§è¡Œä¸€äº›è¡Œä¸ºæ‰“æ–­å½“å‰æµç¨‹ã€‚&lt;/p&gt;

&lt;p&gt;æ­»å¾ªç¯çš„æ£€æµ‹æ˜¯ä¸€ä¸ª&lt;a href=&#34;https://en.wikipedia.org/wiki/Halting_problem&#34;&gt;åœæœºé—®é¢˜&lt;/a&gt;ã€‚æˆ‘ä»¬æ— æ³•åˆ¤æ–­åˆ°åº•æ˜¯ä»»åŠ¡æ‰§è¡Œæ—¶é—´è¿‡é•¿ï¼Œè¿˜æ˜¯è¿›å…¥äº†çœŸæ­£çš„æ­»å¾ªç¯ï¼Œå¥½åœ¨è¿™å¯¹æˆ‘ä»¬çš„æœåŠ¡æ¥è¯´åŒºåˆ«å¹¶ä¸é‡è¦ã€‚æ‰€ä»¥ä¸€ä¸ªç®€å•çš„åˆ¤æ–­æ¡ä»¶æ˜¯ï¼Œæ‰§è¡Œæ—¶é—´æ˜¯å¦è¶…è¿‡äº†é¢„å®šçš„é˜ˆå€¼ã€‚&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C++&lt;/code&gt;ä¸­é›†æˆ&lt;code&gt;lua&lt;/code&gt;ï¼Œè°ƒç”¨åˆ°æ¸¸æˆé€»è¾‘æ—¶ï¼Œä¸€èˆ¬é€šè¿‡&lt;a href=&#34;http://pgl.yoyo.org/luai/i/lua_pcall&#34;&gt;pcall&lt;/a&gt;ï¼Œä½†æ˜¯ä¸€æ—¦è°ƒç”¨äº†&lt;code&gt;pcall&lt;/code&gt;ï¼Œä»£ç çš„æ‰§è¡Œè·¯å¾„ä¾¿è¿›å…¥äº†&lt;code&gt;lua&lt;/code&gt;çš„ä¸–ç•Œï¼Œé™¤éé€šè¿‡ä¿¡å·æœºåˆ¶æ‰èƒ½åœ¨å½“å‰çº¿ç¨‹ä¸­ä¸­æ–­ï¼Œå®ç°æ‰§è¡Œå…¶ä»–åˆ†æ”¯çš„ç›®çš„ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œ&lt;code&gt;lua&lt;/code&gt;è¿˜æä¾›äº†&lt;code&gt;debug.sethook&lt;/code&gt;å‡½æ•°ï¼Œå¯ä»¥åœ¨æ‰§è¡Œæ­£å¸¸é€»è¾‘ä¸­è§¦å‘&lt;code&gt;hook&lt;/code&gt;ï¼Œå®ç°ç›‘æµ‹è¶…æ—¶çš„åŠŸèƒ½ã€‚æ‰€ä»¥æˆ‘ä»¬æœ‰ä»¥ä¸‹ä¸¤ç§æ–¹æ¡ˆï¼š&lt;/p&gt;

&lt;h1 id=&#34;ä½¿ç”¨-debug-sethook-æ¥å®ç°&#34;&gt;ä½¿ç”¨&lt;code&gt;debug.sethook()&lt;/code&gt;æ¥å®ç°&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;debug.sethook ([thread,] hook, mask [, count])
Sets the given function as a hook. The string mask and the number count describe when the hook will be called. The string mask may have the following characters, with the given meaning:&lt;/p&gt;

&lt;p&gt;&amp;ldquo;c&amp;rdquo;: the hook is called every time Lua calls a function;
&amp;ldquo;r&amp;rdquo;: the hook is called every time Lua returns from a function;
&amp;ldquo;l&amp;rdquo;: the hook is called every time Lua enters a new line of code.
With a count different from zero, the hook is called after every count instructions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;æ‰€ä»¥æˆ‘ä»¬åªè¦åœ¨æ‰§è¡Œ&lt;code&gt;pcall&lt;/code&gt;ä¹‹å‰è®¾å®šç±»ä¼¼å¦‚ä¸‹çš„ä»£ç :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;debug.sethook(function()error(&amp;quot;timeout&amp;quot;)end, &amp;quot;c&amp;quot;, 10000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ç†è®ºä¸Šåªè¦ä»£ç æŒ‡ä»¤æ•°è¶…è¿‡10000æ¡å°±èƒ½è§¦å‘&lt;code&gt;error&lt;/code&gt;ã€‚å¥½åƒæŒºå®Œç¾çš„ã€‚&lt;/p&gt;

&lt;p&gt;Butï¼Œåœ¨&lt;code&gt;luajit&lt;/code&gt;ä¸‹è¿™æ¡ä¸ä¸€å®šæˆç«‹ï¼Œå› ä¸ºæ‰§è¡Œçš„é€»è¾‘è¢«&lt;code&gt;jit&lt;/code&gt;ç¼–è¯‘äº†ï¼Œè€Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ&lt;code&gt;hook&lt;/code&gt;æ˜¯ä¸ä¼šè§¦å‘çš„&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If your program is running in a tight loop and never falls back to the interpreter, the debug hook never runs and can&amp;rsquo;t throw the &amp;ldquo;interrupted!&amp;rdquo; error.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ä½†æ˜¯è¿˜æœ‰ä¸€ä¸ªæœªå…¬å¼€çš„ç¼–è¯‘é€‰é¡¹&lt;code&gt;LUAJIT_ENABLE_CHECKHOOK&lt;/code&gt;ï¼Œåœ¨&lt;code&gt;lj_record.c&lt;/code&gt;æ–‡ä»¶çš„æœ€åé¢ï¼Œä¸Šé¢å†™é“&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Regularly check for instruction/line hooks from compiled code and
exit to the interpreter if the hooks are set.&lt;/p&gt;

&lt;p&gt;This is a compile-time option and disabled by default, since the
hook checks may be quite expensive in tight loops.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;çœ‹ä¼¼å¯ä»¥ï¼Œä½†æ˜¯æ³¨æ„ï¼Œå¦‚æœ&lt;code&gt;hook&lt;/code&gt;è¢«è®¾ç½®äº†ï¼Œåˆ™æ‰§è¡Œçš„ä»£ä»·æ˜¯æ¯”è¾ƒæ˜‚è´µçš„ã€‚å¯¹äºæ¸¸æˆè€Œè¨€ï¼Œå¤§éƒ¨åˆ†çš„æ—¶é—´éƒ½åœ¨&lt;code&gt;lua&lt;/code&gt;å±‚ï¼Œè€Œä¸ºäº†ç›‘æµ‹æ­»å¾ªç¯ï¼Œå‡ ä¹
è¦åœ¨æ‰€æœ‰çš„luaæ‰§è¡Œè¿‡ç¨‹ä¸­è®¾ç½®&lt;code&gt;hook&lt;/code&gt;ï¼Œè¿™æ˜¯ä¸å¤ªå®¹æ˜“æ¥å—çš„ã€‚å¥½åœ¨ä¸‹é¢çš„æ³¨é‡Šæåˆ°äº†&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can set the instruction hook via lua_sethook() with a count of 1
from a signal handler or another native thread. Please have a look
at the first few functions in luajit.c for an example (Ctrl-C handler).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;å—¯ï¼Œçœ‹æ ·å­åªèƒ½ä½¿ç”¨ç¬¬äºŒç§æ–¹æ¡ˆäº†ã€‚&lt;/p&gt;

&lt;h1 id=&#34;ä½¿ç”¨ä¿¡å·æ¥å®ç°&#34;&gt;ä½¿ç”¨ä¿¡å·æ¥å®ç°&lt;/h1&gt;

&lt;p&gt;åœ¨luaçš„å‘½ä»¤è¡Œç¨‹åºä¸­æˆ‘ä»¬å¯ä»¥é€šè¿‡&lt;code&gt;Ctrl-C&lt;/code&gt;ä¸­æ–­æ­£åœ¨æ‰§è¡Œçš„ç¨‹åº&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;  for i=1,10000000 do sum = sum + i end
^Cinterrupted!
stack traceback:
        stdin:1: in main chunk
        [C]: in ?

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ä»”ç»†çœ‹&lt;code&gt;lua.c&lt;/code&gt;æ–‡ä»¶ï¼Œå¯ä»¥çœ‹åˆ°ä»¥ä¸‹ä»£ç &lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;static void lstop (lua_State *L, lua_Debug *ar) {
  (void)ar;  /* unused arg. */
  lua_sethook(L, NULL, 0, 0);
  luaL_error(L, &amp;quot;interrupted!&amp;quot;);
}


static void laction (int i) {
  signal(i, SIG_DFL); /* if another SIGINT happens before lstop,
                              terminate process (default action) */
  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
}

// ....
//in docall
signal(SIGINT, laction);
status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
signal(SIGINT, SIG_DFL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;å—¯ï¼Œåœ¨æ‰§è¡Œ&lt;code&gt;pcall&lt;/code&gt;ä¹‹å‰è®¾ç½®äº†ä¿¡å·å¤„ç†å‡½æ•°ï¼Œæ•æ‰&lt;code&gt;Ctrl-C&lt;/code&gt;çš„ä¿¡å·ï¼Œä¸€æ—¦å‘ç”Ÿï¼Œåˆ™ç«‹é©¬è°ƒç”¨&lt;code&gt;lua_sethook&lt;/code&gt;å‡½æ•°ï¼ŒæŒ‡å®šåœ¨æ‰§è¡Œä¸‹ä¸€è¡Œä»£ç æ—¶è°ƒç”¨&lt;code&gt;lstop&lt;/code&gt;ï¼Œè€Œåœ¨&lt;code&gt;lstop&lt;/code&gt;ä¸­å°±ç›´æ¥æŠ›å‡º&lt;code&gt;error&lt;/code&gt;äº†ã€‚æ‰€ä»¥é—®é¢˜æ˜¯ &lt;strong&gt;&lt;code&gt;lua_sethook&lt;/code&gt;æ˜¯å¯ä»¥åœ¨ä¿¡å·å¤„ç†å‡½æ•°ä¸­è°ƒç”¨çš„&lt;/strong&gt;ï¼Ÿ&lt;/p&gt;

&lt;p&gt;ç­”æ¡ˆï¼šæ˜¯&lt;/p&gt;

&lt;p&gt;ä»æºç ä¸­å¯ä»¥çœ‹åˆ°&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* This function can be called asynchronously (e.g. during a signal). */
LUA_API int lua_sethook(lua_State *L, lua_Hook func, int mask, int count)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;é™¤æ­¤ä¹‹å¤–ï¼Œä»&lt;code&gt;luajit&lt;/code&gt;çš„æºç æ³¨é‡Šæ¥çœ‹ï¼Œä¸ä»…ä»…åœ¨ä¿¡å·å¤„ç†å‡½æ•°ä¸­ï¼Œåœ¨å…¶ä»–çº¿ç¨‹ä¸­ä¹Ÿèƒ½è¢«è°ƒç”¨
&amp;gt; from a signal handler or another native thread.&lt;/p&gt;

&lt;p&gt;æ‰€ä»¥ï¼Œè¿™ç§æ–¹æ¡ˆæ˜¯å¯è¡Œçš„ã€‚å› æ­¤ï¼Œå¯¹äºå•çº¿ç¨‹ç¨‹åºè€Œè¨€ï¼Œå¯ä»¥é€šè¿‡è®¾ç½®&lt;code&gt;alarm&lt;/code&gt;æ¥å®ç°è¶…æ—¶è®¾ç½®&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alarm(10);// trigger after 10s
signal(SIGALRM, laction);
status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
alarm(0)
signal(SIGALRM, SIG_DFL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;è€Œå¯¹äºå¤šçº¿ç¨‹ç¨‹åºï¼Œå¯ä»¥ç›´æ¥å¯ä¸€ä¸ªå®šæ—¶å™¨æ¥æ¥&lt;code&gt;check&lt;/code&gt;ï¼Œè€Œä¸ç”¨ä½¿ç”¨å¾ˆæ¶å¿ƒçš„ä¿¡å·ã€‚&lt;/p&gt;

&lt;p&gt;å€¼å¾—ä¸€æçš„æ˜¯ï¼Œä½¿ç”¨è¿™ç§æ–¹å¼è§¦å‘è¶…æ—¶&lt;code&gt;error&lt;/code&gt;å¯ä»¥å¾ˆè½»æ˜“åœ°åœ¨&lt;code&gt;pcall&lt;/code&gt;ä¸­æ•è·ï¼Œä»è€Œè€Œå·²å®ç°å †æ ˆçš„æ‰“å°ç­‰åŠŸèƒ½ï¼Œæ–¹ä¾¿æŸ¥æ‰¾å’Œå®šä½é—®é¢˜ã€‚&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Lua Tableä¸­HashMapä»‹ç»</title>
      <link>http://sysfork.com/post/2016/lua-hashtable-introduction/</link>
      <pubDate>Thu, 01 Sep 2016 17:40:08 +0800</pubDate>
      
      <guid>http://sysfork.com/post/2016/lua-hashtable-introduction/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.lua.org/pil/2.5.html&#34;&gt;Table&lt;/a&gt; åœ¨Luaä¸­æœ‰ç€æå…¶é‡è¦çš„åº”ç”¨ï¼Œä»æ ¸å¿ƒè¯­è¨€å®ç°ï¼Œå¦‚&lt;a href=&#34;https://en.wikipedia.org/wiki/String_interning&#34;&gt;short string intern&lt;/a&gt;ï¼Œ
åˆ°åˆ©ç”¨&lt;a href=&#34;https://www.lua.org/pil/13.html&#34;&gt;metatable&lt;/a&gt;å®ç°çš„&lt;a href=&#34;lua-users.org/wiki/LuaClassesWithMetatable&#34;&gt;class&lt;/a&gt;ï¼Œtableå‡ ä¹æ— æ‰€ä¸èƒ½ã€‚å¦‚æ­¤é«˜é¢‘åº¦åœ°åˆ©ç”¨ä¹Ÿå°±æ„å‘³ç€luaå¿…é¡»è¦æœ‰ä¸€ä¸ªé«˜æ•ˆçš„
tableå®ç°ã€‚&lt;/p&gt;

&lt;p&gt;å¾ˆå¤šè¯­è¨€æä¾›äº†arrayå’Œassociative arrayä¸¤ç§æ•°æ®ç»“æ„ã€‚arrayæ˜¯æŒ‡ä»¥æŸä¸ªæŒ‡å®šçš„æœ€å°æ•´æ•°ä¸‹æ ‡(ä¸€èˆ¬æ˜¯0)å¼€å§‹çš„è¿ç»­å­˜å‚¨çš„æ•°æ®ç»“æ„ï¼Œå®ƒæœ‰vectorã€listã€arrayã€ArrayListç­‰å¤šç§åç§°ï¼›associative arrayï¼Œä¸­æ–‡
ä¹Ÿå«å…³è”æ•°ç»„ï¼Œå³å°†ä¸€å¯¹key/pairä¹‹é—´å…³è”èµ·æ¥ï¼Œå®ƒä¸€èˆ¬ä¹Ÿè¢«ç§°ä¸ºmapã€dictç­‰ã€‚Luaå¹¶ä¸æä¾›arrayï¼Œå› ä¸ºæ•°ç»„æœ¬èº«ä¹Ÿæ˜¯ä¸€ç§ç‰¹æ®Šçš„å…³è”æ•°ç»„ã€‚ä½†æ˜¯ä»å†…éƒ¨è¡¨ç¤ºä¸Šï¼Œarrayå’Œmapæœ‰ç€æå¤§çš„ä¸åŒï¼Œarrayåªéœ€è¦ä¸€å—è¿ç»­çš„
å†…å­˜å³å¯å®ç°ï¼Œè€Œmapåˆ™æœ‰å¤šç§å®ç°ã€‚Luaä¸ºäº†æ•ˆç‡ï¼Œå°†ä¸€éƒ¨åˆ†æ•´æ•°ä¸‹æ ‡çš„å…ƒç´ å­˜å‚¨åœ¨array partä¸­ï¼Œè€Œå°†å…¶ä»–å…ƒç´ å­˜å‚¨åœ¨hashmapä¸­ï¼Œå®ç°åœ¨å¤–éƒ¨æ¥å£ä¸å˜çš„æƒ…å†µä¸‹å®ç°äº†æ•ˆç‡çš„æœ€å¤§åŒ–ã€‚arrayéƒ¨åˆ†æ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«éœ€è¦
ä¼˜åŒ–çš„ï¼Œå…¶å°±æ˜¯ä¸€æ•´å—è¿ç»­çš„å†…å­˜ï¼Œå­˜å‚¨å’Œè¯»å–çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯O(1)ï¼Œè€Œhashmapçš„å®ç°ç§°ä¸ºäº†lua tableè®¾è®¡çš„é‡ç‚¹ã€‚&lt;/p&gt;

&lt;p&gt;mapæœ‰å¤šç§å®ç°æ‰‹æ®µï¼Œåœ¨stlä¸­ï¼Œé»˜è®¤çš„mapä½¿ç”¨çš„æ˜¯çº¢é»‘æ ‘ï¼Œå­˜å‚¨å’Œè¯»å–çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯O(logn)ï¼›è™½ç„¶çº¢é»‘æ ‘çš„è¡¨ç°ååˆ†ç¨³å®šï¼Œä½†æ˜¯å®ç°æ¯”è¾ƒå¤æ‚è€Œä¸”æ— æ³•æ»¡è¶³æç«¯æ€§èƒ½è¦æ±‚ï¼Œ
C++11ä¸­æ·»åŠ æ–°çš„&lt;a href=&#34;http://en.cppreference.com/w/cpp/container/unordered_map&#34;&gt;unordered_map&lt;/a&gt;ï¼Œå…¶å®ç°å°±æ˜¯ä½¿ç”¨äº†ä¸€ä¸ªhashmapã€‚hashmapçš„åŸºæœ¬æµç¨‹æ˜¯ä½¿ç”¨ä¸€ä¸ªhashå‡½æ•°æ¥å°†
ä¸€ä¸ªkeyæ˜ å°„åˆ°ä¸€å—è¿ç»­å†…å­˜ä¸­ï¼Œå®ç°åœ¨ç†æƒ³æƒ…å†µä¸‹è®¿é—®å’Œåˆ é™¤æ¥è¿‘O(1)çš„æ—¶é—´å¤æ‚åº¦ã€‚&lt;/p&gt;

&lt;p&gt;ç”±äºä¸€èˆ¬keyçš„å–å€¼èŒƒå›´å¤§äºhashmap slotæ•°ç›®ï¼Œæ‰€ä»¥ä¸å¯é¿å…åœ°å‡ºç°å†²çªçš„çŠ¶å†µã€‚åœ¨æ•™ç§‘ä¹¦ä¸­ï¼Œè§£å†³è¿™ç§å†²çªä¸€èˆ¬æœ‰ä¸¤ç§æ–¹æ³•ï¼š&lt;a href=&#34;https://en.wikipedia.org/wiki/Hash_table#Separate_chaining&#34;&gt;é“¾è¡¨æ³•&lt;/a&gt;
å’Œ&lt;a href=&#34;https://en.wikipedia.org/wiki/Open_addressing&#34;&gt;å¼€æ”¾å¯»å€æ³•&lt;/a&gt;ã€‚é“¾è¡¨æ³•çš„å®ç°æ¯”è¾ƒç®€å•ï¼Œå°†å†²çªçš„å…ƒç´ ä½¿ç”¨é“¾è¡¨é“¾æ¥èµ·æ¥å³å¯ï¼›è€Œå¼€æ”¾å¯»å€æ³•åˆ™éœ€è¦å¤šæ¬¡è®¡ç®—ï¼Œç›´è‡³æ‰¾åˆ°ä¸€ä¸ªæ²¡æœ‰å†²çªçš„slotä¸ºæ­¢ã€‚
è¿™ä¸¤è€…éƒ½æœ‰è‡ªå·±çš„ä¼˜ç¼ºç‚¹ï¼Œé“¾è¡¨æ³•ç”±äºä½¿ç”¨äº†é“¾è¡¨ï¼Œæ— æ³•å……åˆ†åˆ©ç”¨CPUç¼“å­˜ï¼Œå¹¶ä¸”å®ç°æ·±æ‹·è´éš¾åº¦è¾ƒå¤§ï¼›è€Œå¼€æ”¾å¯»å€æ³•æ— æ³•å®ç°åˆ é™¤å…ƒç´ çš„åŠŸèƒ½ï¼Œå¹¶ä¸”å½“å…ƒç´ å¯†åº¦æ¯”è¾ƒå¤§æ—¶ï¼Œæ•ˆç‡éå¸¸ä½ã€‚&lt;/p&gt;

&lt;p&gt;Lua tableä½¿ç”¨äº†ä¸€ä¸ªæŠ˜ä¸­çš„æ–¹æ¡ˆï¼Œå«åš&lt;a href=&#34;https://en.wikipedia.org/wiki/Coalesced_hashing&#34;&gt;Coalesced_hashing&lt;/a&gt;ï¼Œç»“åˆä½¿ç”¨äº†é“¾è¡¨æ³•å’Œå¼€æ”¾å¯»å€æ³•ã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/4/4c/CoalescedHash.jpg&#34; alt=&#34;Coalesced_hashing&#34; /&gt;&lt;/p&gt;

&lt;p&gt;å½“æ’å…¥ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œå®šä¹‰å…¶åŸæœ¬åº”è¯¥åœ¨çš„ä½ç½®ä¸ºmainpositionï¼Œå¦‚æœmainpoisitionå¯¹åº”çš„slotæ˜¯ç©ºçš„ï¼Œåˆ™ç›´æ¥æ’å…¥ï¼›å¦‚æœéç©ºï¼Œçœ‹çœ‹åœ¨é‚£ä¸ªä½ç½®ä¸Šçš„å…ƒç´ çš„mainpositionæ˜¯ä¸æ˜¯å½“å‰çš„slotï¼Œå¦‚æœä¸æ˜¯çš„
è¯ï¼Œåˆ™å°†å…¶ç§»åŠ¨åˆ°ä»»æ„ä¸€ä¸ªç©ºçš„slot(ä½ç½®A)ï¼Œç„¶åå°†å½“å‰çš„å…ƒç´ æ’å…¥åˆ°mainpositionä½ç½®ï¼Œå¹¶å°†å½“å‰çš„nextå­—æ®µè®¾ç½®æˆä½ç½®Aï¼Œå½¢æˆé“¾è¡¨ã€‚å¦‚æœå ç”¨å…ƒç´ mainpositionå°±æ˜¯å½“å‰ä½ç½®ï¼Œåˆ™å°†å¾…æ’å…¥çš„
å…ƒç´ æ’å…¥åˆ°ä»»æ„ä¸€ä¸ªç©ºçš„ä½ç½®ä¸Šï¼Œå¹¶é“¾æ¥åˆ°å ç”¨å…ƒç´ çš„åé¢ã€‚&lt;/p&gt;

&lt;p&gt;é€šè¿‡ä¸Šé¢çš„è¿‡ç¨‹ï¼Œå®ç°äº†æ‰€æœ‰çš„å…ƒç´ éƒ½å°½é‡ä¿å­˜åœ¨mainpositionä¸Šï¼Œå½“æŸ¥æ‰¾çš„æ—¶å€™ä¹Ÿèƒ½ä½¿ç”¨æ›´å°‘çš„æ¬¡æ•°æ¥æ‰¾åˆ°å…ƒç´ ä½ç½®ã€‚è¿™å¯¹å…ƒç´ æœ¬æ¥å°±åœ¨hashmapä¸­ï¼Œæ•ˆç‡æ˜¯æ¯”è¾ƒé«˜çš„ã€‚ä½†æ˜¯ï¼Œå½“å…ƒç´ ä¸åœ¨hashmapä¸­ï¼ŒæŸ¥æ‰¾çš„ä»£ä»·
æ¯”è¾ƒé«˜ã€‚&lt;/p&gt;

&lt;p&gt;lua tableçš„ä»£ç å®ç°åœ¨&lt;a href=&#34;https://www.lua.org/source/5.3/ltable.c.html&#34;&gt;è¿™é‡Œ&lt;/a&gt;ï¼Œå®ç°éå¸¸ç®€æ´æ˜äº†ï¼Œä¹Ÿä¸æ˜¯å¾ˆéš¾æ‡‚ï¼Œä½†æ˜¯å¯¹äºå¹³æ—¶ç»å¸¸ä½¿ç”¨luaçš„åŒå­¦æ¥è¯´è¯»ä¸€è¯»è¿˜æ˜¯å¾ˆæœ‰å¿…è¦çš„ã€‚&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>